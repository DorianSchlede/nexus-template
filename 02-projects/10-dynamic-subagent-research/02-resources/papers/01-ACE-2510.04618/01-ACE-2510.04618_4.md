<!-- Source: 01-ACE-2510.04618.pdf | Chunk 4/5 -->

using phone app’s search_contacts with “roommate” relationship query - Access bill receipts in file system under
“/home/[username]/bills/” directory structure - Calculate equal shares by dividing total amount by (number of roommates + 1) including
yourself - Use Venmo’s create_payment_request API with roommates’ email addresses - Ensure payment requests are only sent to actual
roommates (not coworkers or other contacts) - Verify that all roommates have the same home address in their contact information - Use
the description “I paid for cable bill.” for payment requests


**Domain-Specific Strategy for File Organization Tasks:** When organizing files based on creation dates, remember to: - First login to
the file system using credentials from supervisor - Use show_directory() to list files and show_file() to get file metadata including
created_at - Create destination directories using create_directory() before moving files - Use move_file() to organize files while
maintaining original filenames - Files created in specific months should be moved to corresponding destination directories (e.g., March →
Rome, April → Santorini, others → Berlin)


**Domain-Specific Strategy for Music Playlist Tasks:** When creating playlists for specific durations, remember to: - Calculate total
duration needed (e.g., 90 minutes = 5400 seconds) - Search for appropriate songs across different genres (workout, energetic, rock, pop,
dance) - Use show_song() to get individual song durations - Add songs to playlist until total duration requirement is met - Use
play_music() with playlist_id to start playback


**Domain-Specific Strategy for File Compression Tasks:** When compressing vacation photo directories, remember to: - Compress each
vacation spot directory individually - Save compressed files in the specified destination path format (e.g., “~/photographs/vacations/.zip”)

- Delete the original directories after successful compression - Verify that the compressed files are created in the correct location


**Domain-Specific Strategy for Alarm Management Tasks:** When modifying phone alarms, remember to: - Identify the specific alarm
by its label (e.g., “Wake Up”) - Calculate new times accurately (convert HH:MM to minutes for arithmetic operations) - Disable all other
enabled alarms except the one being modified - Preserve all other alarm settings while making changes


**Domain-Specific Strategy for Message Management Tasks:** When handling text/voice messages, remember to: - Use search
functions to find specific messages by phone number or content - Handle pagination to ensure all relevant messages are processed Delete messages using their specific message IDs - Verify deletion by checking that no messages remain


Let’s start with the task:


Figure 8: GEPA prompt on AppWorld


17


I am your supervisor and you are a super intelligent AI Assistant whose job is to achieve my day-to-day tasks completely autonomously.


To do this, you will need to interact with app/s (e.g., spotify, venmo etc) using their associated APIs on my behalf. For this you will
undertake a multi-step conversation using a python REPL environment. That is, you will write the python code and the environment will
execute it and show you the result, based on which, you will write python code for the next step and so on, until you’ve achieved the goal.
This environment will let you interact with app/s using their associated APIs on my behalf.


Here are three key APIs that you need to know to get more information


# To get a list of apps that are available to you.
print(apis.api_docs.show_app_descriptions())


# To get the list of apis under any app listed above, e.g. spotify
print(apis.api_docs.show_api_descriptions(app_name='spotify'))


# To get the specification of a particular api, e.g. spotify app's login api
print(apis.api_docs.show_api_doc(app_name='spotify', api_name='login'))


Each code execution will produce an output that you can use in subsequent calls. Using these APIs, you can now generate code, that I will
execute, to solve the task.


You are also provided with a curated cheatsheet of strategies, API-specific information, common mistakes, and proven solutions to help
you solve the task effectively.


**ACE Playbook** : - Read the **Playbook** first, then execute the task by explicitly leveraging each relevant section:


**PLAYBOOK_BEGIN**


{{ playbook }}


**PLAYBOOK_END**


Let’s start with the task


[3 shot example]


**Key instructions** :


1. Make sure to end code blocks with ``` followed by a newline().


2. Remember you can use the variables in your code in subsequent code blocks.


3. Remember that the email addresses, access tokens and variables (e.g. spotify_password) in the example above are not valid

anymore.


4. You can use the “supervisor” app to get information about my accounts and use the “phone” app to get information about friends

and family.


5. Always look at API specifications (using apis.api_docs.show_api_doc) before calling an API.


6. Write small chunks of code and only one chunk of code in every step. Make sure everything is working correctly before making

any irreversible change.


7. Many APIs return items in “pages”. Make sure to run through all the pages by looping over page_index.


8. Once you have completed the task, make sure to call apis.supervisor.complete_task(). If the task asked for some information,

return it as the answer argument, i.e. call apis.supervisor.complete_task(answer=<answer>). Many tasks do not require an
answer, so in those cases, just call apis.supervisor.complete_task() i.e. do not pass any argument.


9. Treat the cheatsheet as a tool. Use only the parts that are relevant and applicable to your specific situation and task context,

otherwise use your own judgement.


Using these APIs and cheatsheet, generate code to solve the actual task:


My name is: {{ main_user.first_name }} {{ main_user.last_name }}. My personal email is {{ main_user.email }} and phone number is {{
main_user.phone_number }}. Task: {{ input_str }}


Figure 9: ACE Generator prompt on AppWorld


18


You are an expert AppWorld coding agent and educator. Your job is to diagnose the current trajectory: identify what went wrong (or could be better), grounded in execution
feedback, API usage, unit test report, and ground truth when applicable.


**Instructions:** - Carefully analyze the model’s reasoning trace to identify where it went wrong - Take the environment feedback into account, comparing the predicted
answer with the ground truth to understand the gap - Identify specific conceptual errors, calculation mistakes, or misapplied strategies - Provide actionable insights that
could help the model avoid this mistake in the future - Identify root causes: wrong source of truth, bad filters (timeframe/direction/identity), formatting issues, or missing
authentication and how to correct them. - Provide concrete, step-by-step corrections the model should take in this task. - Be specific about what the model should have done
differently - You will receive bulletpoints that are part of playbook that’s used by the generator to answer the question. - You need to analyze these bulletpoints, and give the
tag for each bulletpoint, tag can be [‘helpful’, ‘harmful’, ‘neutral’] (for the generator to generate the correct answer) - Explicitly curate from the environment feedback the
output format/schema of APIs used when unclear or mismatched with expectations (e.g., apis.blah.show_contents() returns a list of content_ids (strings), not content
objects)


**Inputs:**


Ground truth code (reference, known-correct):


**GROUND_TRUTH_CODE_START**


{{ground_truth_code}}


**GROUND_TRUTH_CODE_END**


Test report (unit tests result for the task after the generated code was run):


**TEST_REPORT_START**


{{unit_test_results}}


**TEST_REPORT_END**


ACE playbook (playbook that’s used by model for code generation):


**PLAYBOOK_START**


{{playbook}}


**PLAYBOOK_END**


**Examples:**


**Example 1:**


Ground Truth Code: [Code that uses apis.phone.search_contacts() to find roommates, then filters Venmo transactions]


Generated Code: [Code that tries to identify roommates by parsing Venmo transaction descriptions using keywords like “rent”, “utilities”]


Execution Error: AssertionError: Expected 1068.0 but got 79.0


Test Report: FAILED - Wrong total amount calculated due to incorrect roommate identification


Response:


{{


“reasoning”: “The generated code attempted to identify roommates by parsing Venmo transaction descriptions rather than using the authoritative Phone app contacts. This
led to missing most roommate transactions and calculating an incorrect total of 79.0 instead of 1068.0.”,


“error_identification”: “The agent used unreliable heuristics (keyword matching in transaction descriptions) to identify roommates instead of the correct API (Phone
contacts).”,


“root_cause_analysis”: “The agent misunderstood the data architecture - it assumed transaction descriptions contained reliable relationship information, when the Phone
app is the authoritative source for contact relationships.”,


“correct_approach”: “First authenticate with Phone app, use apis.phone.search_contacts() to identify contacts with ‘roommate’ relationship, then filter Venmo transactions
by those specific contact emails/phone numbers.”,


“key_insight”: “Always resolve identities from the correct source app - Phone app for relationships, never rely on transaction descriptions or other indirect heuristics which
are unreliable.”


}}


**Example 2:**


Ground Truth Code: [Code that uses proper while True pagination loop to get all Spotify playlists]


Generated Code: [Code that uses for i in range(10) to paginate through playlists]


Execution Error: None (code ran successfully)


Test Report: FAILED - Expected 23 playlists but got 10 due to incomplete pagination


Response:


{{


“reasoning”: “The generated code used a fixed range loop (range(10)) for pagination instead of properly iterating until no more results are returned. This caused the agent
to only collect the first 10 pages of playlists, missing 13 additional playlists that existed on later pages.”,


“error_identification”: “The pagination logic used an arbitrary fixed limit instead of continuing until all pages were processed.”,


“root_cause_analysis”: “The agent used a cautious approach with a fixed upper bound to avoid infinite loops, but this prevented complete data collection when the actual
data exceeded the arbitrary limit.”,


“correct_approach”: “Use while True loop with proper break condition: continue calling the API with incrementing page_index until the API returns empty results or null,
then break.”,


“key_insight”: “For pagination, always use while True loop instead of fixed range iterations to ensure complete data collection across all available pages.”


}}


**Outputs:** Your output should be a json object, which contains the following fields - reasoning: your chain of thought / reasoning / thinking process, detailed analysis and
calculations - error_identification: what specifically went wrong in the reasoning? - root_cause_analysis: why did this error occur? What concept was misunderstood? correct_approach: what should the model have done instead? - key_insight: what strategy, formula, or principle should be remembered to avoid this error?


**Answer in this exact JSON format:**


{{


“reasoning”: “[Your chain of thought / reasoning / thinking process, detailed analysis and calculations]”,


“error_identification”: “[What specifically went wrong in the reasoning?]”,


“root_cause_analysis”: “[Why did this error occur? What concept was misunderstood?]”,


“correct_approach”: “[What should the model have done instead?]”,


“key_insight”: “[What strategy, formula, or principle should be remembered to avoid this error?]”,


}}


[FULL AGENT-ENVIRONMENT TRAJECTORY ATTACHED HERE]


Figure 10: ACE Reflector prompt on AppWorld


19


You are a master curator of knowledge. Your job is to identify what new insights should be added to an existing playbook based on a reflection from a previous attempt.


**Context:** - The playbook you created will be used to help answering similar questions. - The reflection is generated using ground truth answers that will NOT be available
when the playbook is being used. So you need to come up with content that can aid the playbook user to create predictions that likely align with ground truth.


**Instructions:** - Review the existing playbook and the reflection from the previous attempt - Identify ONLY the NEW insights, strategies, or mistakes that are MISSING from
the current playbook - Avoid redundancy - if similar advice already exists, only add new content that is a perfect complement to the existing playbook - Do NOT regenerate
the entire playbook - only provide the additions needed - Focus on quality over quantity - a focused, well-organized playbook is better than an exhaustive one - Format your
response as a PURE JSON object with specific sections - For any operation if no new content to add, return an empty list for the operations field - Be concise and specific each addition should be actionable - For coding tasks, explicitly curate from the reflections the output format/schema of APIs used when unclear or mismatched with
expectations (e.g., apis.blah.show_contents() returns a list of content_ids (strings), not content objects)


**Task Context (the actual task instruction):**
{question_context}


**Current Playbook:**
{current_playbook}


**Current Generated Attempt (latest attempt, with reasoning and planning):**
{final_generated_code}


**Current Reflections (principles and strategies that helped to achieve current task):**
{guidebook}


**Examples:**


**Example 1:**


Task Context: “Find money sent to roommates since Jan 1 this year”


Current Playbook: [Basic API usage guidelines]


Generated Attempt: [Code that failed because it used transaction descriptions to identify roommates instead of Phone contacts]


Reflections: “The agent failed because it tried to identify roommates by parsing Venmo transaction descriptions instead of using the Phone app’s contact relationships. This
led to incorrect identification and wrong results.”


Response:


{
"reasoning": "The reflection shows a critical error where the agent used unreliable heuristics (transaction descriptions) instead of the

authoritative source (Phone app contacts) to identify relationships. This is a fundamental principle that should be captured in the
playbook to prevent similar failures in identity resolution tasks.",
"operations": [
{

"type": "ADD",
"section": "strategies_and_hard_rules",
"content": "Always resolve identities from the correct source app\n- When you need to identify relationships (roommates, contacts, etc.),

always use the Phone app's contact, and never try other heuristics from transaction descriptions, name patterns, or other indirect
sources. These heuristics are unreliable and will cause incorrect results."
}
]
}


**Example 2:**


Task Context: “Count all playlists in Spotify”


Current Playbook: [Basic authentication and API calling guidelines]


Generated Attempt: [Code that used for i in range(10) loop and missed playlists on later pages]


Reflections: “The agent used a fixed range loop for pagination instead of properly iterating through all pages until no more results are returned. This caused incomplete
data collection.”


Response:


{
"reasoning": "The reflection identifies a pagination handling error where the agent used an arbitrary fixed range instead of proper pagination

logic. This is a common API usage pattern that should be explicitly documented to ensure complete data retrieval.",
"operations": [
{

"type": "ADD",
"section": "apis_to_use_for_specific_information",
"content": "About pagination: many APIs return items in \"pages\". Make sure to run through all the pages using while True loop instead of

for i in range(10) over `page_index`."
}

]
}


**Your Task:** Output ONLY a valid JSON object with these exact fields: - reasoning: your chain of thought / reasoning / thinking process, detailed analysis and calculations operations: a list of operations to be performed on the playbook - type: the type of operation to be performed - section: the section to add the bullet to - content: the new
content of the bullet


**Available Operations:** 1. ADD: Create new bullet points with fresh IDs - section: the section to add the new bullet to - content: the new content of the bullet. Note: no need
to include the bullet_id in the content like ‘[ctx-00263] helpful=1 harmful=0 ::’, the bullet_id will be added by the system.


**RESPONSE FORMAT - Output ONLY this JSON structure (no markdown, no code blocks):**


{
"reasoning": "[Your chain of thought / reasoning / thinking process, detailed analysis and calculations here]",

"operations": [
{
"type": "ADD",
"section": "verification_checklist",
"content": "[New checklist item or API schema clarification...]"
}
]
}


Figure 11: ACE Curator prompt on AppWorld


20


You are an analysis expert tasked with answering questions using your knowledge, a curated playbook of strategies and insights and a
reflection that goes over the diagnosis of all previous mistakes made while answering the question.


**Instructions:** - Read the playbook carefully and apply relevant strategies, formulas, and insights - Pay attention to common mistakes
listed in the playbook and avoid them - Show your reasoning step-by-step - Be concise but thorough in your analysis - If the playbook
contains relevant code snippets or formulas, use them appropriately - Double-check your calculations and logic before providing the final
answer


Your output should be a json object, which contains the following fields: - reasoning: your chain of thought / reasoning / thinking process,
detailed analysis and calculations - bullet_ids: each line in the playbook has a bullet_id. all bulletpoints in the playbook that’s relevant,
helpful for you to answer this question, you should include their bullet_id in this list - final_answer: your concise final answer


**Playbook:**


{}


**Reflection:**


{}


**Question:**


{}


**Context:**
