<!-- Source: 01-ACE-2510.04618.pdf | Chunk 3/5 -->


[46] Zora Zhiruo Wang, Jiayuan Mao, Daniel Fried, and Graham Neubig. Agent workflow memory. _arXiv_
_preprint arXiv:2409.07429_, 2024.


[47] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Fei Xia, Ed Chi, Quoc V Le, Denny Zhou,
et al. Chain-of-thought prompting elicits reasoning in large language models. _Advances in neural_
_information processing systems_, 35:24824–24837, 2022.


[48] Wujiang Xu, Kai Mei, Hang Gao, Juntao Tan, Zujie Liang, and Yongfeng Zhang. A-mem: Agentic
memory for llm agents. _arXiv preprint arXiv:2502.12110_, 2025.


[49] John Yang, Carlos E Jimenez, Alexander Wettig, Kilian Lieret, Shunyu Yao, Karthik Narasimhan, and
Ofir Press. Swe-agent: Agent-computer interfaces enable automated software engineering. _Advances in_
_Neural Information Processing Systems_, 37:50528–50652, 2024.


[50] Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William W Cohen, Ruslan Salakhutdinov, and
Christopher D Manning. Hotpotqa: A dataset for diverse, explainable multi-hop question answering.
_arXiv preprint arXiv:1809.09600_, 2018.


[51] Jiayi Yao, Hanchen Li, Yuhan Liu, Siddhant Ray, Yihua Cheng, Qizheng Zhang, Kuntai Du, Shan Lu,
and Junchen Jiang. Cacheblend: Fast large language model serving for rag with cached knowledge
fusion. In _Proceedings of the Twentieth European Conference on Computer Systems_, pages 94–109, 2025.


[52] Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao.
React: Synergizing reasoning and acting in language models. In _International Conference on Learning_
_Representations (ICLR)_, 2023.


[53] Jiacheng Ye, Chengzu Li, Lingpeng Kong, and Tao Yu. Generating data for symbolic language with
large language models. _arXiv preprint arXiv:2305.13917_, 2023.


[54] Mert Yuksekgonul, Federico Bianchi, Joseph Boen, Sheng Liu, Zhi Huang, Carlos Guestrin, and James
Zou. Textgrad: Automatic" differentiation" via text. _arXiv preprint arXiv:2406.07496_, 2024.


[55] Matei Zaharia, Omar Khattab, Lingjiao Chen, Jared Quincy Davis, Heather Miller, Chris Potts, James
Zou, Michael Carbin, Jonathan Frankle, Naveen Rao, and Ali Ghodsi. The shift from models to
[compound ai systems. https://bair.berkeley.edu/blog/2024/02/18/compound-ai-systems/, 2024.](https://bair.berkeley.edu/blog/2024/02/18/compound-ai-systems/)


[56] Genghan Zhang, Weixin Liang, Olivia Hsu, and Kunle Olukotun. Adaptive self-improvement llm
agentic system for ml library development. _arXiv preprint arXiv:2502.02534_, 2025.


[57] Qizheng Zhang, Ali Imran, Enkeleda Bardhi, Tushar Swamy, Nathan Zhang, Muhammad Shahbaz,
and Kunle Olukotun. Caravan: Practical online learning of _{_ In-Network _}{_ ML _}_ models with labeling
agents. In _18th USENIX Symposium on Operating Systems Design and Implementation (OSDI 24)_, pages
325–345, 2024.


[58] Qizheng Zhang, Michael Wornow, and Kunle Olukotun. Cost-efficient serving of llm agents via test-time
plan caching. _arXiv preprint arXiv:2506.14852_, 2025.


[59] Huichi Zhou, Yihang Chen, Siyuan Guo, Xue Yan, Kin Hei Lee, Zihan Wang, Ka Yiu Lee, Guchun
Zhang, Kun Shao, Linyi Yang, et al. Agentfly: Fine-tuning llm agents without fine-tuning llms. _arXiv_
_preprint arXiv:2508.16153_, 2025.


[60] Fuzhen Zhuang, Zhiyuan Qi, Keyu Duan, Dongbo Xi, Yongchun Zhu, Hengshu Zhu, Hui Xiong, and
Qing He. A comprehensive survey on transfer learning. _arXiv:1911.02685_, 2019.


13


**A** **Related Work on Agent Memory**


A growing body of work explores how agents can accumulate experience from past trajectories and leverage
external (often non-parametric) memory to guide future actions. AgentFly [59] presents an extensible framework where memory evolves continuously as agents solve tasks, enabling scalable reinforcement learning
and long-horizon reasoning across diverse environments. AWM (Agent Workflow Memory) [46] induces
reusable _workflows_ —structured routines distilled from past trajectories—and selectively injects them into
memory to improve efficiency and generalization in web navigation benchmarks. A-MEM [48] introduces
a dynamically organized memory system inspired by the Zettelkasten method: each stored memory is
annotated with structured attributes ( _e.g.,_ tags, keywords, contextual descriptions) and automatically linked
to relevant past entries, while existing entries are updated to integrate new knowledge, yielding adaptive
and context-aware retrieval. Agentic Plan Caching [58] instead focuses on cost efficiency by extracting
reusable plan templates from agent trajectories and caching them for fast execution at test time.


Together, these works demonstrate the value of external memory for improving adaptability, efficiency, and
generalization in LLM agents. Our work differs by tackling the broader challenge of _context adaptation_, which
spans not only agent memory but also system prompts, factual evidence, and other inputs underpinning AI
systems. We further highlight two fundamental limitations of existing adaptation methods— _brevity bias_ and
_context collapse_ —and show that addressing them is essential for robustness, reliability, and scalability beyond
raw task performance. Accordingly, our evaluation considers not only accuracy but also cost, latency, and
scalability.


**B** **Limitations and Challenges**


A potential limitation of ACE is its reliance on a reasonably strong Reflector: if the Reflector fails to extract
meaningful insights from generated traces or outcomes, the constructed context may become noisy or even
harmful. In domain-specific tasks where no model can extract useful insights, the resulting context will
naturally lack them. This dependency is similar to Dynamic Cheatsheet [41], where the quality of adaptation
hinges on the underlying model’s ability to curate memory. We also note that not all applications require
rich or detailed contexts. Tasks like HotPotQA [50] often benefit more from concise, high-level instructions
( _e.g.,_ how to retrieve and synthesize evidence) than from long contexts. Similarly, games with fixed strategies
such as Game of 24 [41] may only need a single reusable rule, rendering additional context redundant.
Overall, ACE is most beneficial in settings that demand detailed domain knowledge, complex tool use,
or environment-specific strategies that go beyond what is already embedded in model weights or simple
system instructions.


**C** **AppWorld Leaderboard Snapshot (09/2025)**


Figure 5: The AppWorld leaderboard as accessed on 09/20/2025.


14


**D** **Prompts**


We release the language model prompts used in our agentic context engineering framework as well as the
baselines to support research transparency and reproducibility.


I am your supervisor and you are a super intelligent AI Assistant whose job is to achieve my day-to-day tasks completely autonomously.


To do this, you will need to interact with app/s (e.g., spotify, venmo etc) using their associated APIs on my behalf. For this you will
undertake a multi-step conversation using a python REPL environment. That is, you will write the python code and the environment will
execute it and show you the result, based on which, you will write python code for the next step and so on, until you’ve achieved the goal.
This environment will let you interact with app/s using their associated APIs on my behalf.


Here are three key APIs that you need to know to get more information


# To get a list of apps that are available to you.
print(apis.api_docs.show_app_descriptions())


# To get the list of apis under any app listed above, e.g. spotify
print(apis.api_docs.show_api_descriptions(app_name='spotify'))


# To get the specification of a particular api, e.g. spotify app's login api
print(apis.api_docs.show_api_doc(app_name='spotify', api_name='login'))


Each code execution will produce an output that you can use in subsequent calls. Using these APIs, you can now generate code, that I will
execute, to solve the task.


Let’s start with the task


[3 shot example]


**Key instructions** :


1. Make sure to end code blocks with ``` followed by a newline().


2. Remember you can use the variables in your code in subsequent code blocks.


3. Remember that the email addresses, access tokens and variables (e.g. spotify_password) in the example above are not valid

anymore.


4. You can use the “supervisor” app to get information about my accounts and use the “phone” app to get information about friends

and family.


5. Always look at API specifications (using apis.api_docs.show_api_doc) before calling an API.


6. Write small chunks of code and only one chunk of code in every step. Make sure everything is working correctly before making any

irreversible change.


7. Many APIs return items in “pages”. Make sure to run through all the pages by looping over page_index.


8. Once you have completed the task, make sure to call apis.supervisor.complete_task(). If the task asked for some information,

return it as the answer argument, i.e. call apis.supervisor.complete_task(answer=<answer>). Many tasks do not require an
answer, so in those cases, just call apis.supervisor.complete_task() i.e. do not pass any argument.


Using these APIs, generate code to solve the actual task:


My name is: {{ main_user.first_name }} {{ main_user.last_name }}. My personal email is {{ main_user.email }} and phone number is {{
main_user.phone_number }}.


Task: {{ input_str }}


Figure 6: ICL-baseline Generator prompt on AppWorld


15


I am your supervisor and you are a super intelligent AI Assistant whose job is to achieve my day-to-day tasks completely autonomously.
You will be given a cheatsheet containing relevant strategies, patterns, and examples from similar problems to apply and solve the
current task.


To do this, you will need to interact with app/s (e.g., spotify, venmo etc) using their associated APIs on my behalf. For this you will
undertake a multi-step conversation using a python REPL environment. That is, you will write the python code and the environment will
execute it and show you the result, based on which, you will write python code for the next step and so on, until you’ve achieved the goal.
This environment will let you interact with app/s using their associated APIs on my behalf.


Here are three key APIs that you need to know to get more information


# To get a list of apps that are available to you.
print(apis.api_docs.show_app_descriptions())


# To get the list of apis under any app listed above, e.g. spotify
print(apis.api_docs.show_api_descriptions(app_name='spotify'))


# To get the specification of a particular api, e.g. spotify app's login api
print(apis.api_docs.show_api_doc(app_name='spotify', api_name='login'))


Each code execution will produce an output that you can use in subsequent calls. Using these APIs, you can now generate code, that I will
execute, to solve the task.


CHEATSHEET: ’’’ {{ cheat_sheet }} ’’’


**1. ANALYSIS & STRATEGY**


Carefully analyze both the question and cheatsheet before starting
Search for and identify any applicable patterns, strategies, or examples within the cheatsheet
Create a structured approach to solving the problem at hand
Review and document any limitations in the provided reference materials


**2. SOLUTION DEVELOPMENT**


Present your solution using clear, logical steps that others can follow and review
Explain your reasoning and methodology before presenting final conclusions
Provide detailed explanations for each step of the process
Check and verify all assumptions and intermediate calculations


**3. PROGRAMMING TASKS**


When coding is required: - Write clean, efficient Python code - Follow the strict code formatting and execution protocol (always use the
Python code formatting block; furthermore, after the code block, always explicitly request execution by appending: “EXECUTE CODE!”):
python  # Your code here EXECUTE CODE!


All required imports and dependencies should be clearly declared at the top of your code
Include clear inline comments to explain any complex programming logic
Perform result validation after executing your code
Apply optimization techniques from the cheatsheet when applicable
The code should be completely self-contained without external file dependencies–it should be ready to be executed right away
Do not include any placeholders, system-specific paths, or hard-coded local paths
Feel free to use standard and widely-used pip packages
Opt for alternative methods if errors persist during execution
Exclude local paths and engine-specific settings (e.g., avoid configurations like
chess.engine.SimpleEngine.popen_uci(“/usr/bin/stockfish”))


Let’s start with the task


[3 shot example]


**Key instructions** : (1) Make sure to end code blocks with ``` followed by a newline().


2. Remember you can use the variables in your code in subsequent code blocks.


3. Remember that the email addresses, access tokens and variables (e.g. spotify_password) in the example above are not valid

anymore.


4. You can use the “supervisor” app to get information about my accounts and use the “phone” app to get information about friends

and family.


5. Always look at API specifications (using apis.api_docs.show_api_doc) before calling an API.


6. Write small chunks of code and only one chunk of code in every step. Make sure everything is working correctly before making

any irreversible change.


7. Many APIs return items in “pages”. Make sure to run through all the pages by looping over page_index.


8. Once you have completed the task, make sure to call apis.supervisor.complete_task(). If the task asked for some information,

return it as the answer argument, i.e. call apis.supervisor.complete_task(answer=<answer>). Many tasks do not require an
answer, so in those cases, just call apis.supervisor.complete_task() i.e. do not pass any argument.


Using these APIs, generate code to solve the actual task:


My name is: {{ main_user.first_name }} {{ main_user.last_name }}. My personal email is {{ main_user.email }} and phone number is {{
main_user.phone_number }}. Task: {{ input_str }}


Figure 7: Dynamic Cheatsheet Generator prompt on AppWorld


16


I am your supervisor and you are a super intelligent AI Assistant whose job is to achieve my day-to-day tasks completely autonomously.


To do this, you will need to interact with app/s (e.g., spotify, venmo etc) using their associated APIs on my behalf. For this you will
undertake a multi-step conversation using a python REPL environment. That is, you will write the python code and the environment will
execute it and show you the result, based on which, you will write python code for the next step and so on, until you’ve achieved the goal.
This environment will let you interact with app/s using their associated APIs on my behalf.


Here are three key APIs that you need to know to get more information:


# To get a list of apps that are available to you.
print(apis.api_docs.show_app_descriptions())


# To get the list of apis under any app listed above, e.g. spotify
print(apis.api_docs.show_api_descriptions(app_name='spotify'))


# To get the specification of a particular api, e.g. spotify app's login api
print(apis.api_docs.show_api_doc(app_name='spotify', api_name='login'))


Each code execution will produce an output that you can use in subsequent calls. Using these APIs, you can now generate code, that I will
execute, to solve the task.


**Key Instructions:**


1. Always end code blocks with ``` followed by a newline().


2. Remember you can use variables in your code in subsequent code blocks.


3. Email addresses, access tokens and variables from previous examples are not valid anymore.


4. Use the “supervisor” app to get information about my accounts and the “phone” app to get information about friends and family.


5. Always look at API specifications (using apis.api_docs.show_api_doc) before calling an API.


6. Write small chunks of code and only one chunk of code in every step. Make sure everything is working correctly before making

any irreversible changes.


7. Many APIs return items in “pages”. Make sure to run through all the pages by looping over page_index.


8. Once you have completed the task, call apis.supervisor.complete_task(). If the task asked for information, return it as the

answer argument: apis.supervisor.complete_task(answer=<answer>). For tasks without required answers, just call
apis.supervisor.complete_task() without arguments.


**Domain-Specific Strategy for Bill Splitting Tasks:** When splitting bills among roommates, remember to: - First identify roommates
using phone app’s search_contacts with “roommate” relationship query - Access bill receipts in file system under
“/home/[username]/bills/” directory structure - Calculate equal shares by dividing total amount by (number of roommates + 1) including
yourself - Use Venmo’s create_payment_request API with roommates’ email addresses - Ensure payment requests are only sent to actual
roommates (not coworkers or other contacts) - Verify that all roommates have the same home address in their contact information - Use
the description “I paid for cable bill.” for payment requests


**Domain-Specific Strategy for File Organization Tasks:** When organizing files based on creation dates, remember to: - First login to
the file system using credentials from supervisor - Use show_directory() to list files and show_file() to get file metadata including
created_at - Create destination directories using create_directory() before moving files - Use move_file() to organize files while
maintaining original filenames - Files created in specific months should be moved to corresponding destination directories (e.g., March →
Rome, April → Santorini, others → Berlin)


**Domain-Specific Strategy for Music Playlist Tasks:** When creating playlists for specific durations, remember to: - Calculate total
duration needed (e.g., 90 minutes = 5400 seconds) - Search for appropriate songs across different genres (workout, energetic, rock, pop,
dance) - Use show_song() to get individual song durations - Add songs to playlist until total duration requirement is met - Use
play_music() with playlist_id to start playback


**Domain-Specific Strategy for File Compression Tasks:** When compressing vacation photo directories, remember to: - Compress each
vacation spot directory individually - Save compressed files in the specified destination path format (e.g., “~/photographs/vacations/.zip”)

- Delete the original directories after successful compression - Verify that the compressed files are created in the correct location


**Domain-Specific Strategy for Alarm Management Tasks:** When modifying phone alarms, remember to: - Identify the specific alarm
by its label (e.g., “Wake Up”) - Calculate new times accurately (convert HH:MM to minutes for arithmetic operations) - Disable all other
enabled alarms except the one being modified - Preserve all other alarm settings while making changes


**Domain-Specific Strategy for Message Management Tasks:** When handling text/voice messages, remember to: - Use search
functions to find specific messages by phone number or content - Handle pagination to ensure all relevant messages are processed Delete messages using their specific message IDs - Verify deletion by checking that no messages remain


Let’s start with the task:


Figure 8: GEPA prompt on AppWorld


17


I am your supervisor and you are a super intelligent AI Assistant whose job is to achieve my day-to-day tasks completely autonomously.


To do this, you will need to interact with app/s (e.g., spotify, venmo etc) using their associated APIs on my behalf. For this you will
undertake a multi-step conversation using a python REPL environment. That is, you will write the python code and the environment will
execute it and show you the result, based on which, you will write python code for the next step and so on, until you’ve achieved the goal.
This environment will let you interact with app/s using their associated APIs on my behalf.


Here are three key APIs that you need to know to get more information


# To get a list of apps that are available to you.
print(apis.api_docs.show_app_descriptions())


# To get the list of apis under any app listed above, e.g. spotify
print(apis.api_docs.show_api_descriptions(app_name='spotify'))


# To get the specification of a particular api, e.g. spotify app's login api
print(apis.api_docs.show_api_doc(app_name='spotify', api_name='login'))


Each code execution will produce an output that you can use in subsequent calls. Using these APIs, you can now generate code, that I will
execute, to solve the task.


You are also provided with a curated cheatsheet of strategies, API-specific information, common mistakes, and proven solutions to help
you solve the task effectively.


**ACE Playbook** : - Read the **Playbook** first, then execute the task by explicitly leveraging each relevant section:


**PLAYBOOK_BEGIN**


{{ playbook }}


**PLAYBOOK_END**


Let’s start with the task


[3 shot example]


**Key instructions** :


1. Make sure to end code blocks with ``` followed by a newline().

