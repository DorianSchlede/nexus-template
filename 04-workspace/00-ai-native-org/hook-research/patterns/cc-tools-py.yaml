# Hook Pattern Extraction: claude-code-tools
# Source: https://github.com/pchalasani/claude-code-tools
# Extracted: 2025-12-31
# Total Hooks Found: 9 (7 PreToolUse, 1 UserPromptSubmit, 1 StatusLine)

metadata:
  repository: claude-code-tools
  author: Prasad Chalasani
  language: Python (primary), Bash (statusline)
  architecture: Modular plugin system with unified orchestrator hook
  notable_features:
    - Unified bash_hook.py orchestrates multiple check functions
    - Three-way decision system (allow/ask/block)
    - TRASH pattern instead of rm deletion
    - Speed bump pattern for file length limits
    - Cross-platform clipboard integration

# =============================================================================
# PRETOOLUSE HOOKS - Safety & Quality
# =============================================================================

patterns:

  # ---------------------------------------------------------------------------
  # PATTERN 1: Unified Bash Command Orchestrator
  # ---------------------------------------------------------------------------
  - pattern_name: "unified-bash-orchestrator"
    hook_event: "PreToolUse"
    source_repo: "claude-code-tools"
    source_file: "plugins/safety-hooks/hooks/bash_hook.py"
    description: "Master hook that orchestrates multiple safety check functions, combining their decisions with priority (block > ask > allow)."
    implementation:
      matcher: "Bash"
      decision_type: "block|ask|allow"
      exit_code: "0"
    technique:
      summary: "Imports check functions from sub-modules, runs all checks, collects decisions, returns highest-priority decision."
      code_snippet: |
        # Import check functions from other hooks
        from git_add_block_hook import check_git_add_command
        from git_checkout_safety_hook import check_git_checkout_command
        from git_commit_block_hook import check_git_commit_command
        from rm_block_hook import check_rm_command
        from env_file_protection_hook import check_env_file_access

        # Run all checks
        checks = [
            check_rm_command,
            check_git_add_command,
            check_git_checkout_command,
            check_git_commit_command,
            check_env_file_access,
        ]

        block_reasons = []
        ask_reasons = []

        for check_func in checks:
            decision, reason = normalize_check_result(check_func(command))
            if decision == "block":
                block_reasons.append(reason)
            elif decision == "ask":
                ask_reasons.append(reason)

        # Priority: block > ask > allow
        if block_reasons:
            # Return deny with combined reasons
        elif ask_reasons:
            # Return ask with combined reasons
        else:
            # Return approve
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Combined safety check failure reasons with detailed guidance"
    use_case:
      category: "Safety"
      when_to_use: "When you have multiple safety checks that should all run on the same tool"
      when_not_to_use: "For simple single-purpose hooks; adds complexity"
    quality:
      complexity: "medium"
      performance: "<10ms"
      dependencies: ["command_utils"]

  # ---------------------------------------------------------------------------
  # PATTERN 2: TRASH Pattern (rm Block)
  # ---------------------------------------------------------------------------
  - pattern_name: "rm-trash-pattern"
    hook_event: "PreToolUse"
    source_repo: "claude-code-tools"
    source_file: "plugins/safety-hooks/hooks/rm_block_hook.py"
    description: "Blocks all rm commands and instructs Claude to use mv to TRASH directory instead, with documentation in TRASH-FILES.md."
    implementation:
      matcher: "Bash"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Regex detection of rm command variants, returns detailed instructions for TRASH pattern alternative."
      code_snippet: |
        def check_rm_command(command):
            normalized_cmd = ' '.join(command.strip().split())

            if (normalized_cmd.startswith("rm ") or normalized_cmd == "rm" or
                re.search(r'(^|[;&|]\s*)(/\S*/)?rm\b', normalized_cmd)):
                reason_text = (
                    "Instead of using 'rm':\n "
                    "- MOVE files using `mv` to the TRASH directory in the CURRENT folder (create it if needed), \n"
                    "- Add an entry in a markdown file called 'TRASH-FILES.md' in the current directory, "
                    "  where you show a one-liner with the file name, where it moved, and the reason to trash it"
                )
                return True, reason_text
            return False, None
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Instructions to use TRASH directory pattern with documentation"
    use_case:
      category: "Safety"
      when_to_use: "Prevent accidental file deletion while maintaining audit trail"
      when_not_to_use: "Environments where actual deletion is required"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  # ---------------------------------------------------------------------------
  # PATTERN 3: Git Add Smart Staging
  # ---------------------------------------------------------------------------
  - pattern_name: "git-add-smart-staging"
    hook_event: "PreToolUse"
    source_repo: "claude-code-tools"
    source_file: "plugins/safety-hooks/hooks/git_add_block_hook.py"
    description: "Implements tiered git add protection: hard blocks dangerous patterns, asks permission for modified files, allows new files."
    implementation:
      matcher: "Bash"
      decision_type: "block|ask|allow"
      exit_code: "0"
    technique:
      summary: "Uses regex for dangerous patterns, subprocess git dry-run/status to classify files as new vs modified, returns appropriate decision."
      code_snippet: |
        # Hard block patterns: -A, --all, -a, ., ../, wildcards
        dangerous_pattern = re.compile(
            r'^git\s+add\s+(?:.*\s+)?('
            r'-[a-zA-Z]*[Aa][a-zA-Z]*(\s|$)|'  # Flags containing 'A' or 'a'
            r'--all(\s|$)|'                     # Long form --all
            r'\.(\s|$)|'                        # git add . (current directory)
            r'\.\./[\.\w/]*(\s|$)'             # git add ../ or ../.. patterns
            r')', re.IGNORECASE
        )

        if dangerous_pattern.search(normalized_cmd):
            return True, "BLOCKED: Dangerous git add pattern detected!..."

        # Check if staging modified files - requires permission
        modified_files = get_modified_files_being_staged(normalized_cmd)
        if modified_files:
            file_list = ", ".join(modified_files[:5])
            reason = f"Staging modified files: {file_list}"
            return "ask", reason

        return False, None  # Allow new files without permission
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Detailed blocking reason with safe alternatives, or list of modified files requiring approval"
    use_case:
      category: "Safety"
      when_to_use: "Prevent accidental staging of unwanted files while allowing legitimate operations"
      when_not_to_use: "Trusted environments where git add . is acceptable"
    quality:
      complexity: "high"
      performance: "10-50ms"
      dependencies: ["command_utils", "subprocess (git status/dry-run)"]

  # ---------------------------------------------------------------------------
  # PATTERN 4: Git Checkout Safety
  # ---------------------------------------------------------------------------
  - pattern_name: "git-checkout-uncommitted-warning"
    hook_event: "PreToolUse"
    source_repo: "claude-code-tools"
    source_file: "plugins/safety-hooks/hooks/git_checkout_safety_hook.py"
    description: "Blocks git checkout when uncommitted changes exist, showing detailed file list and safe alternatives."
    implementation:
      matcher: "Bash"
      decision_type: "block|allow"
      exit_code: "0"
    technique:
      summary: "Checks git status for uncommitted changes, blocks dangerous patterns unconditionally, warns with file list for others."
      code_snippet: |
        # ALWAYS block these dangerous patterns
        dangerous_patterns = [
            (r'\bgit\s+checkout\s+(-f|--force)\b',
             "'git checkout -f' FORCES checkout and DISCARDS all uncommitted changes!"),
            (r'\bgit\s+checkout\s+\.',
             "'git checkout .' will DISCARD ALL changes in current directory!"),
        ]

        for pattern, message in dangerous_patterns:
            if re.search(pattern, command):
                return True, f"DANGEROUS COMMAND DETECTED!\n\n{message}..."

        # Check for uncommitted changes
        status_result = subprocess.run(
            ["git", "status", "--porcelain"],
            capture_output=True, text=True, cwd=os.getcwd()
        )
        has_changes = bool(status_result.stdout.strip())

        if has_changes:
            warning = f"WARNING: You have {num_changes} uncommitted change(s)!\n"
            warning += "\nOptions:\n"
            warning += "1. Stash changes: git stash\n"
            warning += "2. Commit changes: git commit -am 'message'\n"
            return True, warning
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Warning with uncommitted file list and safe alternatives (stash, commit, restore)"
    use_case:
      category: "Safety"
      when_to_use: "Prevent accidental loss of uncommitted work during branch switching"
      when_not_to_use: "When checkout should proceed regardless of status"
    quality:
      complexity: "medium"
      performance: "10-50ms"
      dependencies: ["command_utils", "subprocess (git status/diff)"]

  # ---------------------------------------------------------------------------
  # PATTERN 5: Git Commit Permission
  # ---------------------------------------------------------------------------
  - pattern_name: "git-commit-ask-permission"
    hook_event: "PreToolUse"
    source_repo: "claude-code-tools"
    source_file: "plugins/safety-hooks/hooks/git_commit_block_hook.py"
    description: "Requires user approval before any git commit, using the ask permission decision type."
    implementation:
      matcher: "Bash"
      decision_type: "ask"
      exit_code: "0"
    technique:
      summary: "Simple pattern match for git commit, returns ask decision to trigger Claude Code permission prompt."
      code_snippet: |
        def check_git_commit_command(command):
            for subcmd in extract_subcommands(command):
                normalized = ' '.join(subcmd.strip().split())
                if normalized.startswith('git commit'):
                    reason = "Git commit requires your approval."
                    return "ask", reason
            return "allow", None

        # Output format
        print(json.dumps({
            "hookSpecificOutput": {
                "hookEventName": "PreToolUse",
                "permissionDecision": "ask",
                "permissionDecisionReason": reason
            }
        }))
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Simple approval request message"
    use_case:
      category: "Safety"
      when_to_use: "Require human review before committing code changes"
      when_not_to_use: "Automated CI/CD pipelines or trusted commit scenarios"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: ["command_utils"]

  # ---------------------------------------------------------------------------
  # PATTERN 6: Environment File Protection
  # ---------------------------------------------------------------------------
  - pattern_name: "env-file-protection"
    hook_event: "PreToolUse"
    source_repo: "claude-code-tools"
    source_file: "plugins/safety-hooks/hooks/env_file_protection_hook.py"
    description: "Blocks all read/write/edit operations on .env files, suggesting the env-safe CLI for safe inspection."
    implementation:
      matcher: "Bash"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Comprehensive regex patterns for all ways .env files could be accessed, with helpful alternative guidance."
      code_snippet: |
        env_patterns = [
            # Direct file reading
            r'\bcat\s+.*\.env\b',
            r'\bless\s+.*\.env\b',
            r'\bhead\s+.*\.env\b',
            # Editors
            r'\bvi\s+.*\.env\b',
            r'\bcode\s+.*\.env\b',
            # Writing/modifying
            r'>\s*\.env\b',
            r'\becho\s+.*>\s*\.env\b',
            r'\bsed\s+.*-i.*\.env\b',
            # Searching
            r'\bgrep\s+.*\.env\b',
            r'\brg\s+.*\.env\b',
        ]

        for pattern in env_patterns:
            if re.search(pattern, normalized_cmd, re.IGNORECASE):
                reason_text = (
                    "Blocked: Direct access to .env files is not allowed.\n\n"
                    "For safe inspection, use the `env-safe` command:\n"
                    "  - `env-safe list` - List all environment variable keys\n"
                    "  - `env-safe check KEY_NAME` - Check if a key exists\n"
                )
                return True, reason_text
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Security explanation and safe alternative commands (env-safe CLI)"
    use_case:
      category: "Safety"
      when_to_use: "Prevent exposure of API keys and secrets in .env files"
      when_not_to_use: "When .env file access is legitimately required"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  # ---------------------------------------------------------------------------
  # PATTERN 7: File Length Limit (Speed Bump)
  # ---------------------------------------------------------------------------
  - pattern_name: "file-length-speed-bump"
    hook_event: "PreToolUse"
    source_repo: "claude-code-tools"
    source_file: "plugins/safety-hooks/hooks/file_length_limit_hook.py"
    description: "Blocks Write/Edit operations that would create source files exceeding 10,000 lines, with a speed bump pattern allowing retry after warning."
    implementation:
      matcher: "Edit|Write"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Calculates resulting line count for Edit (with string replacement) or Write operations, uses flag file for speed bump pattern."
      code_snippet: |
        MAX_FILE_LINES = 10000
        SOURCE_CODE_EXTENSIONS = {'.py', '.tsx', '.ts', '.js', '.rs', '.go', ...}

        def get_resulting_line_count(tool_name, file_path, tool_input):
            if tool_name == "Write":
                return count_lines_in_content(tool_input.get("content", ""))
            elif tool_name == "Edit":
                # Read current file, apply replacement, count result
                old_string = tool_input.get("old_string", "")
                new_string = tool_input.get("new_string", "")
                with open(file_path, 'r') as f:
                    current_content = f.read()
                result_content = current_content.replace(old_string, new_string)
                return count_lines_in_content(result_content)

        # Speed bump pattern using flag file
        flag_file = Path('.claude_file_length_warning.flag')
        if flag_file.exists():
            flag_file.unlink()  # Clear flag, allow operation
            return False, None

        # First attempt - block and create flag
        flag_file.touch()
        return True, f"File would be {resulting_lines} lines. Ask user to approve or refactor."
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "File length warning with line counts and refactoring suggestions"
    use_case:
      category: "Quality"
      when_to_use: "Encourage modular code by flagging large files"
      when_not_to_use: "Legitimate large files (generated code, data files)"
    quality:
      complexity: "medium"
      performance: "10-50ms"
      dependencies: ["pathlib"]

# =============================================================================
# USERPROMPTSUBMIT HOOKS - Session Management
# =============================================================================

  # ---------------------------------------------------------------------------
  # PATTERN 8: Resume Trigger
  # ---------------------------------------------------------------------------
  - pattern_name: "resume-trigger-clipboard"
    hook_event: "UserPromptSubmit"
    source_repo: "claude-code-tools"
    source_file: "plugins/aichat/hooks/aichat_resume_hook.py"
    description: "Detects >resume/>continue/>handoff prompts, copies session ID to clipboard, blocks prompt with instructions to run aichat resume."
    implementation:
      matcher: ""
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Pattern matches trigger words, copies session_id from hook data to clipboard using cross-platform commands, blocks with formatted instructions."
      code_snippet: |
        TRIGGERS = (">resume", ">continue", ">handoff")

        def copy_to_clipboard(text: str) -> bool:
            clipboard_commands = [
                ["pbcopy"],       # macOS
                ["xclip", "-selection", "clipboard"],  # Linux X11
                ["wl-copy"],      # Linux Wayland
                ["clip"],         # Windows
            ]
            for cmd in clipboard_commands:
                try:
                    proc = subprocess.run(cmd, input=text.encode(), capture_output=True)
                    if proc.returncode == 0:
                        return True
                except (subprocess.SubprocessError, FileNotFoundError):
                    continue
            return False

        def main():
            data = json.load(sys.stdin)
            session_id = data.get("session_id", "")
            prompt = data.get("prompt", "").strip()

            if not any(prompt.startswith(t) for t in TRIGGERS):
                sys.exit(0)  # Not our trigger, pass through

            copied = copy_to_clipboard(session_id)

            message = "Session ID copied to clipboard!\n"
            message += "To continue: quit Claude, run: aichat resume <paste>"

            print(json.dumps({"decision": "block", "reason": message}))
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - blocks prompt, provides instructions to user"
    use_case:
      category: "Productivity"
      when_to_use: "Enable quick session handoff when context fills up"
      when_not_to_use: "When different session management is preferred"
    quality:
      complexity: "medium"
      performance: "<10ms"
      dependencies: ["subprocess (clipboard commands)"]

# =============================================================================
# STATUSLINE (Custom Status Display)
# =============================================================================

  # ---------------------------------------------------------------------------
  # PATTERN 9: Context-Aware Statusline
  # ---------------------------------------------------------------------------
  - pattern_name: "powerline-statusline"
    hook_event: "StatusLine"
    source_repo: "claude-code-tools"
    source_file: "scripts/statusline.sh"
    description: "Custom bash statusline with powerline styling, showing model, directory, git status, and color-coded context usage bar."
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Parses JSON input with jq, extracts git status with subprocess, builds ANSI-colored powerline segments with context progress bar."
      code_snippet: |
        #!/bin/bash
        input=$(cat)

        # Extract fields from JSON
        cwd=$(echo "$input" | jq -r '.workspace.current_dir // empty')
        model=$(echo "$input" | jq -r '.model | if type == "object" then .id else . end')

        # Git status
        if git -C "$cwd" rev-parse --git-dir > /dev/null 2>&1; then
            branch=$(git -C "$cwd" branch --show-current)
            status=$(git -C "$cwd" status --porcelain)
            staged=$(echo "$status" | grep -c '^[MADRC]')
            modified=$(echo "$status" | grep -c '^.[MD]')
        fi

        # Context progress bar with color based on usage
        usage=$(echo "$input" | jq '.context_window.current_usage')
        current=$(echo "$usage" | jq '.input_tokens + .cache_creation_input_tokens')
        size=$(echo "$input" | jq '.context_window.context_window_size')
        pct=$((current * 100 / size))

        if [ "$pct" -gt 95 ]; then
            fill_color=$'\033[38;5;196m'  # bright red + blink
        elif [ "$pct" -gt 85 ]; then
            fill_color=$'\033[38;5;208m'  # orange
        elif [ "$pct" -gt 70 ]; then
            fill_color=$'\033[38;5;220m'  # yellow
        else
            fill_color=$'\033[38;5;29m'   # forest green
        fi
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - visual display only"
    use_case:
      category: "Observability"
      when_to_use: "Visual awareness of context usage, git status, and model"
      when_not_to_use: "Minimal terminal setups without Nerd Fonts"
    quality:
      complexity: "medium"
      performance: "10-50ms"
      dependencies: ["jq", "git", "Nerd Fonts"]

# =============================================================================
# UTILITY: Command Parsing
# =============================================================================

utilities:

  - utility_name: "extract-subcommands"
    source_file: "plugins/safety-hooks/hooks/command_utils.py"
    description: "Splits compound bash commands (&&, ||, ;) into individual subcommands for safe analysis."
    code_snippet: |
      def extract_subcommands(command: str) -> list[str]:
          if not command:
              return []
          subcommands = re.split(r'\s*(?:&&|\|\||;)\s*', command)
          return [cmd.strip() for cmd in subcommands if cmd.strip()]
    use_case: "Ensures all parts of compound commands are checked, not just the first"

# =============================================================================
# HOOKS NOT FOUND (In Repository)
# =============================================================================

hooks_not_found:
  - hook_type: "SessionStart"
    note: "No SessionStart hooks in this repository"
  - hook_type: "PostToolUse"
    note: "No PostToolUse hooks in this repository"
  - hook_type: "PreCompact"
    note: "No PreCompact hooks in this repository"
  - hook_type: "Stop"
    note: "No Stop hooks in this repository"
  - hook_type: "SubagentStop"
    note: "No SubagentStop hooks in this repository"
  - hook_type: "Notification"
    note: "No Notification hooks in this repository"

# =============================================================================
# ARCHITECTURE NOTES
# =============================================================================

architecture_patterns:

  - pattern: "Unified Orchestrator"
    description: "bash_hook.py acts as master controller, importing and calling individual check functions"
    benefits:
      - "Single hook configuration, multiple safety checks"
      - "Consistent decision prioritization (block > ask > allow)"
      - "Easy to add/remove individual checks"
    tradeoffs:
      - "All checks run even if first blocks (could short-circuit)"
      - "Tight coupling between orchestrator and check modules"

  - pattern: "Three-Way Decision System"
    description: "Uses allow/ask/block instead of simple pass/fail"
    benefits:
      - "Nuanced control - some operations need confirmation, not blocking"
      - "Uses Claude Code's native permission prompt UI"
    implementation: |
      # Allow: {"decision": "approve"}
      # Ask: {"hookSpecificOutput": {"permissionDecision": "ask", "permissionDecisionReason": "..."}}
      # Block: {"hookSpecificOutput": {"permissionDecision": "deny", "permissionDecisionReason": "..."}}

  - pattern: "Speed Bump Pattern"
    description: "First attempt blocks with warning, second attempt (after flag file) allows"
    benefits:
      - "Forces user acknowledgment without permanent blocking"
      - "File-based state is simple and debuggable"
    tradeoffs:
      - "Flag file can persist if process crashes"
      - "Race conditions possible with concurrent operations"

  - pattern: "Plugin System"
    description: "Hooks organized into plugins (safety-hooks, aichat) with plugin.json manifests"
    benefits:
      - "Modular installation via Claude Code marketplace"
      - "Clear separation of concerns (safety vs productivity)"
      - "$CLAUDE_PLUGIN_ROOT environment variable for path resolution"

# =============================================================================
# SUMMARY
# =============================================================================

summary:
  total_patterns: 9
  by_hook_type:
    PreToolUse: 7
    UserPromptSubmit: 1
    StatusLine: 1
  by_category:
    Safety: 6
    Quality: 1
    Productivity: 1
    Observability: 1
  key_techniques:
    - "Unified orchestrator pattern for multiple checks"
    - "Three-way decision system (allow/ask/block)"
    - "TRASH pattern as safe rm alternative"
    - "Speed bump pattern with flag files"
    - "Cross-platform clipboard integration"
    - "Git status/dry-run for smart file classification"
    - "Comprehensive regex patterns for command detection"
    - "Powerline-style statusline with context awareness"
