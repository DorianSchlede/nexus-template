repo_id: "tdd-guard-part1"
repo_name: "tdd-guard"
scope: "Core handlers, config, entry points"
language: "TypeScript"
extracted_at: "2025-12-31T14:00:00Z"
patterns:

  - pattern_name: "Main Entry Point with Dependency Injection"
    hook_event: "PreToolUse"
    source_file: "src/cli/tdd-guard.ts"
    description: "CLI entry point that reads JSON from stdin, processes through hook pipeline with injectable dependencies, and outputs ValidationResult."
    implementation:
      matcher: "Edit|MultiEdit|Write"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Stdin-based JSON processing with dependency injection for testability. Uses async pipeline with configurable storage, validator, and model provider."
      code_snippet: |
        export async function run(
          input: string,
          config?: Config,
          storage?: Storage,
          provider?: ModelClientProvider
        ): Promise<ValidationResult> {
          const appConfig = config ?? new Config()
          const actualStorage = storage ?? new FileStorage(appConfig)
          const modelProvider = provider ?? new ModelClientProvider()
          const modelClient = modelProvider.getModelClient(appConfig)

          return processHookData(input, {
            storage: actualStorage,
            validator: (context) => validator(context, modelClient),
          })
        }

        if (require.main === module) {
          let inputData = ''
          process.stdin.setEncoding('utf8')
          process.stdin.on('data', (chunk) => { inputData += chunk })
          process.stdin.on('end', async () => {
            const result = await run(inputData)
            console.log(JSON.stringify(result))
            process.exit(0)
          })
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - outputs decision via stdout JSON"
    use_case:
      category: "Quality"
      when_to_use: "When building a hook that needs to validate tool operations through an AI model with configurable backends"

  - pattern_name: "SessionStart Handler with State Initialization"
    hook_event: "SessionStart"
    source_file: "src/hooks/sessionHandler.ts"
    description: "Handles SessionStart events to initialize TDD instructions and clear transient data between sessions."
    implementation:
      matcher: "SessionStart"
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Parses SessionStart schema, ensures instructions file exists with default RULES, and clears transient storage (test results, todos, modifications, lint data)."
      code_snippet: |
        export class SessionHandler {
          private readonly storage: Storage

          constructor(storage?: Storage) {
            this.storage = storage ?? new FileStorage()
          }

          async processSessionStart(hookData: string): Promise<void> {
            const parsedData = JSON.parse(hookData)
            const sessionStartResult = SessionStartSchema.safeParse(parsedData)

            if (!sessionStartResult.success) {
              return
            }

            await this.ensureInstructionsExist()
            await this.storage.clearTransientData()
          }

          private async ensureInstructionsExist(): Promise<void> {
            const existingInstructions = await this.storage.getInstructions()
            if (!existingInstructions) {
              await this.storage.saveInstructions(RULES)
            }
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "Initializes instructions.md with TDD rules if not present"
    use_case:
      category: "Context"
      when_to_use: "When hook needs to initialize state or clear caches at session start"

  - pattern_name: "UserPromptSubmit Command Handler"
    hook_event: "UserPromptSubmit"
    source_file: "src/hooks/userPromptHandler.ts"
    description: "Intercepts user prompts to handle 'tdd-guard on/off' commands for runtime enable/disable of TDD enforcement."
    implementation:
      matcher: "UserPromptSubmit with 'tdd-guard on|off'"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Parses user prompt text, matches against command patterns, updates guard state via GuardManager, returns stopReason to prevent Claude from processing the command."
      code_snippet: |
        export class UserPromptHandler {
          private readonly guardManager: GuardManager
          private readonly GUARD_COMMANDS = {
            ON: 'tdd-guard on',
            OFF: 'tdd-guard off'
          } as const

          async processUserCommand(hookData: string): Promise<ValidationResult | undefined> {
            const data = JSON.parse(hookData)

            if (data.hook_event_name !== 'UserPromptSubmit') {
              return undefined
            }

            const command = data.prompt?.toLowerCase()

            switch (command) {
              case this.GUARD_COMMANDS.ON:
                await this.guardManager.enable()
                return this.createBlockResult('TDD Guard enabled')

              case this.GUARD_COMMANDS.OFF:
                await this.guardManager.disable()
                return this.createBlockResult('TDD Guard disabled')

              default:
                return undefined
            }
          }

          private createBlockResult(message: string): ValidationResult {
            return {
              decision: undefined,
              reason: message,
              continue: false,
              stopReason: message
            }
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - command handling only"
    use_case:
      category: "Coordination"
      when_to_use: "When hook needs slash-command-style user controls for enable/disable or mode switching"

  - pattern_name: "Guard State Management with Ignore Patterns"
    hook_event: "PreToolUse"
    source_file: "src/guard/GuardManager.ts"
    description: "Manages guard enable/disable state and file ignore patterns using minimatch for glob-based filtering."
    implementation:
      matcher: "*.md|*.txt|*.json|*.yml|*.yaml|etc"
      decision_type: "allow"
      exit_code: "0"
    technique:
      summary: "Stores guard config in JSON file, uses minimatch with matchBase option to filter files. Default patterns skip documentation and config files. Patterns are customizable via config."
      code_snippet: |
        export class GuardManager {
          private readonly storage: Storage
          private readonly minimatchOptions = {
            matchBase: true,
            nobrace: false,
            dot: true,
          } as const

          static readonly DEFAULT_IGNORE_PATTERNS = [
            '*.md', '*.txt', '*.log', '*.json',
            '*.yml', '*.yaml', '*.xml', '*.html',
            '*.css', '*.rst',
          ]

          async isEnabled(): Promise<boolean> {
            const config = await this.getConfig()
            return config?.guardEnabled ?? true
          }

          async shouldIgnoreFile(filePath: string): Promise<boolean> {
            const patterns = await this.getIgnorePatterns()
            return patterns.some((pattern) =>
              minimatch(filePath, pattern, this.minimatchOptions)
            )
          }

          private async setGuardEnabled(enabled: boolean): Promise<void> {
            const existingConfig = await this.getConfig()
            const config: GuardConfig = {
              ...existingConfig,
              guardEnabled: enabled,
            }
            await this.storage.saveConfig(JSON.stringify(config))
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - state management only"
    use_case:
      category: "Productivity"
      when_to_use: "When hook needs to skip validation for certain file types or allow runtime toggling"

  - pattern_name: "Central Hook Router with Multi-Event Dispatch"
    hook_event: "PreToolUse|PostToolUse|SessionStart|UserPromptSubmit"
    source_file: "src/hooks/processHookData.ts"
    description: "Central routing function that dispatches hook events to specialized handlers and orchestrates the validation pipeline."
    implementation:
      matcher: "Edit|MultiEdit|Write|TodoWrite"
      decision_type: "block|allow"
      exit_code: "0"
    technique:
      summary: "Event-based dispatch pattern: SessionStart -> session init, UserPromptSubmit -> command handling, PostToolUse -> lint, PreToolUse -> TDD validation. Uses Zod schemas for type-safe parsing."
      code_snippet: |
        export async function processHookData(
          inputData: string,
          deps: ProcessHookDataDeps = {}
        ): Promise<ValidationResult> {
          const parsedData = JSON.parse(inputData)

          const storage = deps.storage ?? new FileStorage()
          const guardManager = new GuardManager(storage)
          const userPromptHandler = deps.userPromptHandler ?? new UserPromptHandler(guardManager)

          // Skip validation for ignored files
          const filePath = extractFilePath(parsedData)
          if (filePath && await guardManager.shouldIgnoreFile(filePath)) {
            return defaultResult
          }

          // Process SessionStart events
          if (parsedData.hook_event_name === 'SessionStart') {
            await sessionHandler.processSessionStart(inputData)
            return defaultResult
          }

          // Process user commands
          const stateResult = await userPromptHandler.processUserCommand(inputData)
          if (stateResult) return stateResult

          // Check if guard is disabled
          const disabledResult = await userPromptHandler.getDisabledResult()
          if (disabledResult) return disabledResult

          // PostToolUse -> lint
          if (hookResult.data.hook_event_name === 'PostToolUse') {
            return await lintHandler.handle(inputData)
          }

          // PreToolUse -> validation
          return await performValidation(deps)
        }
    context_loading:
      mechanism: "none"
      what_loaded: "Routes to appropriate handler which may load context"
    use_case:
      category: "Coordination"
      when_to_use: "When building complex hooks that need to handle multiple event types with different behaviors"

  - pattern_name: "Configuration with Environment Variables and Validation"
    hook_event: "All"
    source_file: "src/config/Config.ts"
    description: "Centralized configuration management with environment variable support, path validation, and multiple client types (CLI, SDK, API)."
    implementation:
      matcher: "N/A"
      decision_type: "none"
      exit_code: "N/A"
    technique:
      summary: "Reads config from options, env vars, or defaults. Validates CLAUDE_PROJECT_DIR for security (absolute path, no traversal, contains cwd). Supports multiple model clients."
      code_snippet: |
        export const DEFAULT_MODEL_VERSION = 'claude-sonnet-4-0'
        export const DEFAULT_CLIENT: ClientType = 'sdk'
        export const DEFAULT_DATA_DIR = path.join('.claude', 'tdd-guard', 'data')

        export class Config {
          readonly dataDir: string
          readonly useSystemClaude: boolean
          readonly anthropicApiKey: string | undefined
          readonly modelVersion: string
          readonly validationClient: ClientType

          constructor(options?: ConfigOptions) {
            this.dataDir = this.getDataDir(options)
            this.anthropicApiKey = this.getAnthropicApiKey(options)
            this.validationClient = this.getValidationClient(options)
          }

          private getValidatedClaudeProjectDir(): string | null {
            const projectDir = process.env.CLAUDE_PROJECT_DIR
            if (!projectDir) return null

            if (!path.isAbsolute(projectDir)) {
              throw new Error('CLAUDE_PROJECT_DIR must be an absolute path')
            }
            if (projectDir.includes('..')) {
              throw new Error('CLAUDE_PROJECT_DIR must not contain path traversal')
            }
            const cwd = process.cwd()
            if (!cwd.startsWith(projectDir)) {
              throw new Error('CLAUDE_PROJECT_DIR must contain cwd')
            }
            return projectDir
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "Provides configuration to all components"
    use_case:
      category: "Safety"
      when_to_use: "When hook needs secure configuration with path validation and multiple deployment modes"

  - pattern_name: "Zod Schema-Based Hook Data Validation"
    hook_event: "All"
    source_file: "src/contracts/schemas/toolSchemas.ts"
    description: "Comprehensive Zod schemas for type-safe parsing and validation of all Claude Code hook data and tool operations."
    implementation:
      matcher: "Edit|MultiEdit|Write|TodoWrite|SessionStart|UserPromptSubmit"
      decision_type: "none"
      exit_code: "N/A"
    technique:
      summary: "Discriminated union schemas for tool operations, type guards for runtime type checking, and schema composition for extensibility."
      code_snippet: |
        export const HookContextSchema = z.object({
          session_id: z.string(),
          transcript_path: z.string(),
          hook_event_name: z.string(),
        })

        export const HookDataSchema = HookContextSchema.extend({
          tool_name: z.string(),
          tool_input: z.unknown(),
        })

        export const EditSchema = z.object({
          file_path: z.string(),
          old_string: z.string(),
          new_string: z.string(),
          replace_all: z.boolean().optional(),
        })

        export const ToolOperationSchema = z.discriminatedUnion('tool_name', [
          EditOperationSchema,
          MultiEditOperationSchema,
          WriteOperationSchema,
          TodoWriteOperationSchema,
        ])

        // Type guards
        export const isEditOperation = (op: ToolOperation): op is EditOperation =>
          op.tool_name === 'Edit'

        export const isTodoWriteOperation = (op: ToolOperation): op is TodoWriteOperation =>
          op.tool_name === 'TodoWrite'
    context_loading:
      mechanism: "none"
      what_loaded: "Provides type-safe parsing for all hook data"
    use_case:
      category: "Safety"
      when_to_use: "When hook needs robust validation of incoming JSON data with TypeScript type inference"

  - pattern_name: "PostToolUse Linting with Notification State"
    hook_event: "PostToolUse"
    source_file: "src/hooks/postToolLint.ts"
    description: "Runs linting after file modifications, tracks notification state to avoid repeated blocking, formats issues for Claude feedback."
    implementation:
      matcher: "Edit|MultiEdit|Write"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Extracts file paths from tool operations, runs linter, persists results with notification flag. Only blocks when PreToolUse has notified AND issues persist. Formats issues by file."
      code_snippet: |
        export async function handlePostToolLint(
          hookData: string,
          storage: Storage,
          linter: Linter
        ): Promise<ValidationResult> {
          const validatedHookData = parseAndValidateHookData(hookData)
          if (!validatedHookData) return DEFAULT_RESULT

          const filePaths = extractFilePaths(validatedHookData)
          if (filePaths.length === 0) return DEFAULT_RESULT

          const storedLintData = await getStoredLintData(storage)
          const lintResults = await linter.lint(filePaths)

          const lintData = createLintData(lintResults, storedLintData)
          await storage.saveLint(JSON.stringify(lintData))

          const hasIssues = lintResults.errorCount > 0 || lintResults.warningCount > 0

          // Block only if PreToolUse notified AND issues persist
          if (storedLintData?.hasNotifiedAboutLintIssues && hasIssues) {
            return createBlockResult(lintData)
          }

          return DEFAULT_RESULT
        }

        function extractFilePaths(hookData: HookData): string[] {
          const paths: string[] = []
          if ('file_path' in toolInput) paths.push(toolInput.file_path)
          if ('edits' in toolInput && Array.isArray(toolInput.edits)) {
            for (const edit of toolInput.edits) {
              if ('file_path' in edit) paths.push(edit.file_path)
            }
          }
          return [...new Set(paths)]
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Formatted lint issues with file paths, line numbers, and summary"
    use_case:
      category: "Quality"
      when_to_use: "When hook needs to enforce code quality via external tools after modifications"

  - pattern_name: "Storage Abstraction with Transient Data Management"
    hook_event: "All"
    source_file: "src/storage/Storage.ts"
    description: "Interface-driven storage abstraction separating transient data (test, todo, modifications, lint) from persistent config."
    implementation:
      matcher: "N/A"
      decision_type: "none"
      exit_code: "N/A"
    technique:
      summary: "Defines storage interface with save/get methods for each data type. Transient data is cleared on session start. Supports both file-based and in-memory implementations for testing."
      code_snippet: |
        export const TRANSIENT_DATA = ['test', 'todo', 'modifications', 'lint'] as const

        export interface Storage {
          saveTest(content: string): Promise<void>
          saveTodo(content: string): Promise<void>
          saveModifications(content: string): Promise<void>
          saveLint(content: string): Promise<void>
          saveConfig(content: string): Promise<void>
          saveInstructions(content: string): Promise<void>
          getTest(): Promise<string | null>
          getTodo(): Promise<string | null>
          getModifications(): Promise<string | null>
          getLint(): Promise<string | null>
          getConfig(): Promise<string | null>
          getInstructions(): Promise<string | null>
          clearTransientData(): Promise<void>
        }
    context_loading:
      mechanism: "none"
      what_loaded: "Provides persistence layer for all hook state"
    use_case:
      category: "Context"
      when_to_use: "When hook needs to persist state across tool calls within a session"

  - pattern_name: "Context Builder for AI Validation"
    hook_event: "PreToolUse"
    source_file: "src/cli/buildContext.ts"
    description: "Aggregates all stored context (modifications, test results, todos, lint) into a structured Context object for AI validation."
    implementation:
      matcher: "N/A"
      decision_type: "none"
      exit_code: "N/A"
    technique:
      summary: "Parallel async loading of all context sources, processes lint data for formatting, handles missing data gracefully. Returns typed Context object."
      code_snippet: |
        export async function buildContext(storage: Storage): Promise<Context> {
          const [modifications, rawTest, todo, lint, instructions] = await Promise.all([
            storage.getModifications(),
            storage.getTest(),
            storage.getTodo(),
            storage.getLint(),
            storage.getInstructions(),
          ])

          let processedLintData
          try {
            if (lint) {
              const rawLintData = LintDataSchema.parse(JSON.parse(lint))
              processedLintData = processLintData(rawLintData)
            } else {
              processedLintData = processLintData()
            }
          } catch {
            processedLintData = processLintData()
          }

          return {
            modifications: formatModifications(modifications ?? ''),
            test: rawTest ?? '',
            todo: todo ?? '',
            lint: processedLintData,
            instructions: instructions ?? undefined,
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "Aggregates context for downstream AI validation"
    use_case:
      category: "Context"
      when_to_use: "When hook needs to build comprehensive context from multiple storage sources"

  - pattern_name: "AI-Powered Validation with Response Parsing"
    hook_event: "PreToolUse"
    source_file: "src/validation/validator.ts"
    description: "Sends context to AI model for TDD compliance validation, robustly parses JSON response from various formats."
    implementation:
      matcher: "Edit|MultiEdit|Write"
      decision_type: "block|allow"
      exit_code: "0"
    technique:
      summary: "Generates dynamic prompt from context, calls model client, parses response from JSON code blocks or plain JSON. Handles errors by blocking with explanation."
      code_snippet: |
        export async function validator(
          context: Context,
          modelClient: IModelClient = new ClaudeCli()
        ): Promise<ValidationResult> {
          try {
            const prompt = generateDynamicContext(context)
            const response = await modelClient.ask(prompt)
            return parseModelResponse(response)
          } catch (error) {
            const errorMessage =
              error instanceof Error ? error.message : 'Unknown error'
            const reason =
              errorMessage === 'No response from model'
                ? 'No response from model, try again'
                : `Error during validation: ${errorMessage}`

            return { decision: 'block', reason }
          }
        }

        function extractJsonString(response: string): string {
          if (!response) throw new Error('No response from model')

          const jsonFromCodeBlock = extractFromJsonCodeBlock(response)
          if (jsonFromCodeBlock) return jsonFromCodeBlock

          const jsonFromGenericBlock = extractFromGenericCodeBlock(response)
          if (jsonFromGenericBlock) return jsonFromGenericBlock

          const plainJson = extractPlainJson(response)
          if (plainJson) return plainJson

          return response
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "AI decision and reasoning for TDD compliance"
    use_case:
      category: "Quality"
      when_to_use: "When hook needs AI judgment for complex validation that cannot be rule-based"

  - pattern_name: "Dynamic Prompt Generation with Operation-Specific Context"
    hook_event: "PreToolUse"
    source_file: "src/validation/context/context.ts"
    description: "Generates AI prompts dynamically based on operation type (Edit/MultiEdit/Write), including relevant context sections."
    implementation:
      matcher: "Edit|MultiEdit|Write"
      decision_type: "none"
      exit_code: "N/A"
    technique:
      summary: "Assembles prompt from modular sections: system prompt (CLI only), rules, file types, operation-specific format, test output, todos, lint results, and response format."
      code_snippet: |
        export function generateDynamicContext(
          context: Context,
          config?: Config
        ): string {
          const operation: ToolOperation = JSON.parse(context.modifications)
          const effectiveConfig = config ?? new Config()

          const sections: string[] = [
            getSystemPrompt(effectiveConfig),
            context.instructions ?? RULES,
            FILE_TYPES,
            formatOperation(operation),
            formatTestSection(context.test),
            formatTodoSection(context.todo),
            formatLintSection(context.lint),
            RESPONSE,
          ]

          return sections.filter(Boolean).join('\n')
        }

        function formatOperation(operation: ToolOperation): string {
          if (isEditOperation(operation)) {
            return EDIT + formatEditOperation(operation)
          }
          if (isMultiEditOperation(operation)) {
            return MULTI_EDIT + formatMultiEditOperation(operation)
          }
          if (isWriteOperation(operation)) {
            return WRITE + formatWriteOperation(operation)
          }
          return ''
        }
    context_loading:
      mechanism: "none"
      what_loaded: "Generates prompt for AI validation"
    use_case:
      category: "Quality"
      when_to_use: "When hook needs to generate structured prompts for AI validation with operation-specific context"

  - pattern_name: "HookEvents State Persistence"
    hook_event: "PreToolUse|PostToolUse"
    source_file: "src/hooks/HookEvents.ts"
    description: "Persists tool operations to storage for later validation, distinguishing between TodoWrite and file modifications."
    implementation:
      matcher: "Edit|MultiEdit|Write|TodoWrite"
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Parses hook data with Zod schemas, extracts tool operation, routes to appropriate storage method based on operation type."
      code_snippet: |
        export class HookEvents {
          constructor(private readonly storage: Storage) {}

          async processEvent(event: unknown): Promise<void> {
            const hookResult = HookDataSchema.safeParse(event)
            if (!hookResult.success) return

            const operation = this.extractToolOperation(hookResult.data)
            if (!operation) return

            await this.persistOperation(operation)
          }

          private extractToolOperation(hook: HookData): ToolOperation | null {
            const result = ToolOperationSchema.safeParse(hook)
            return result.success ? result.data : null
          }

          private async persistOperation(operation: ToolOperation): Promise<void> {
            const content = JSON.stringify(operation, null, 2)

            if (isTodoWriteOperation(operation)) {
              await this.storage.saveTodo(content)
            } else {
              await this.storage.saveModifications(content)
            }
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "Persists operations for later validation context"
    use_case:
      category: "Context"
      when_to_use: "When hook needs to track tool operations across multiple hook events"
