# Entity Definitions

**Source**: Project 16 Ontologies Research v3

**Type**: Synthesis Analysis (UDWO-Primed)

**Field**: entity_definitions

**Aggregated**: 2026-01-01T16:22:19.758677

**Batches Merged**: 11

---

## Table of Contents

- [Patterns](#patterns)

## Patterns

**Total Patterns**: 402

### 1. Endurant Definition - Time-Persistence

UFO defines endurants as entities that exist wholly at any moment they exist, possessing both essential and accidental properties. This allows endurants to undergo qualitative change while preserving numerical identity. The identity persistence is governed by the unique Kind the endurant instantiates.

**Sources**:

- **01-UFO (Chunk 1:283-288)**
  > Endurants are individuals that exist in time with all their parts. They have essential and accidental properties and, hence, they can qualitatively change while maintaining their numerical identity

---

### 2. Perdurant Definition - Temporal Unfolding

Perdurants (events) are defined as entities that accumulate temporal parts as they unfold in time. They are manifestations of dispositions and exist only in the past. Being modally fragile means there is no cross-world identity between perdurants - they cannot be different than what they are.

**Sources**:

- **01-UFO (Chunk 1:289-296)**
  > Perdurants are individuals that unfold in time accumulating temporal parts. They are manifestations of dispositions and only exist in the past. As such, perdurants are modally fragile

---

### 3. Substantial Definition - Independent Entity

Substantials are defined as independent entities that do not existentially depend on other entities for their existence. Examples include persons and organizations. Substantials contrast with moments (existentially dependent entities).

**Sources**:

- **01-UFO (Chunk 1:298-301)**
  > accounting for both substantial individuals (or Substantials), i.e., independent entities (e.g., Mick Jagger, the Free University of Bozen-Bolzano)

---

### 4. Moment Definition - Existentially Dependent Entity

Moments are defined as particularized properties that are existentially dependent on other entities. They are parasitic entities that can only exist by inhering in other entities. Also known as aspects, abstract particulars, or variable tropes in philosophical literature.

**Sources**:

- **01-UFO (Chunk 1:299-301)**
  > particularized properties, i.e., existentially dependent entities or moments, these last ones termed aspects, abstract particulars, or variable tropes

---

### 5. Quality Definition - Projectable Property

Qualities are intrinsic moments that can be directly projected into certain value spaces. They are reifications of categorical properties (color, height, weight, electrical charge). Qualities map to quality structures which delimit the space of possible values (qualia).

**Sources**:

- **01-UFO (Chunk 1:302-306)**
  > Intrinsic moments are existentially dependent on a single individual. These include qualities, i.e., reifications of categorical properties such as color, height, weight, electrical charge

---

### 6. Quality Structure Definition - Value Space

Quality structures are abstract entities that define the space of possible values (qualia) for qualities of a given quality type. They can be one-dimensional (quality dimensions like height, weight) or composed of multiple co-dependent dimensions (quality domains like color spindle, taste tetrahedron).

**Sources**:

- **01-UFO (Chunk 1:303-306)**
  > The latter, termed quality structures, are abstract entities delimiting the space of possible values (qualia, singular quale) for qualities of a given quality type

---

### 7. Mode Definition - Non-Projectable Intrinsic Moment

Modes are intrinsic moments that cannot be projected into a value space (unlike qualities). They include dispositions (functions, capabilities, capacities, vulnerabilities) and externally dependent entities. Modes can bear their own moments, including qualities that vary independently.

**Sources**:

- **01-UFO (Chunk 1:321-323)**
  > Intrinsic moments also include modes. Modes can bear their own moments, including their own qualities, which can vary in independent ways

---

### 8. Disposition Definition - Modal Capacity

Dispositions are a type of mode that represents capacities, functions, capabilities, and vulnerabilities of entities. They are intrinsic moments that connect to events through manifestation - a perdurant manifests a disposition inhering in an endurant.

**Sources**:

- **01-UFO (Chunk 1:321-323)**
  > The category of modes include dispositions (e.g., functions, capabilities, capacities, vulnerabilities)

---

### 9. Externally Dependent Mode Definition

Externally dependent modes are modes that inhere in one entity while being existentially dependent on another entity that is mereologically disjoint from the bearer. Example: John's love for Mary inheres in John but depends on Mary's existence.

**Sources**:

- **01-UFO (Chunk 1:323-327)**
  > Externally dependent modes inhere in an entity while being externally dependent on another entity

---

### 10. Qua Individual Definition

A qua individual is a complex mode composed of externally dependent modes that share: (1) the same bearer, (2) the same source of external dependence, and (3) the same foundational event. Example: John-qua-husband-of-Mary represents all commitments and claims John has towards Mary founded in their wedding.

**Sources**:

- **01-UFO (Chunk 1:325-329)**
  > a qua individual, which is a mode composed of other externally dependent modes that share the same bearer, the same source of external dependence, and the same foundational event

---

### 11. Relator Definition - Aggregated Qua Individuals

A relator is a moment that aggregates qua individuals, thereby being existentially dependent on multiple individuals (the bearers of its constituting qua individuals). Examples include marriages, enrollments, employments, contracts, and presidential mandates. Relators serve as truthmarkers of material relations.

**Sources**:

- **01-UFO (Chunk 1:329-334)**
  > a relator is a moment (i.e., an existentially dependent entity) that is an aggregation of qua individuals

---

### 12. Object Definition - Functional Complex

Objects (functional complexes) are substantials whose parts play differentiated functional roles with respect to the whole. Examples include human bodies, organizations, computers, and cars. This distinguishes objects from quantities and collectives which have different unity conditions.

**Sources**:

- **01-UFO (Chunk 1:360-361)**
  > Objects (aka functional complexes) are entities whose parts play differentiated functional roles with respect to the whole

---

### 13. Collective Definition - Uniform Parts

Collectives are substantials whose parts play the same role with respect to the whole. Examples include the Black Forest (as a collective of trees), a deck of cards, and the Dutch-speaking group in a crowd. This uniform part-role distinguishes collectives from objects.

**Sources**:

- **01-UFO (Chunk 1:356-358)**
  > Collectives are entities whose parts play the same role with respect to the whole

---

### 14. Quantity Definition - Homeomerous Matter

Quantities are substantials that are maximally topologically self-connected portions of homeomerous (uniform) amounts of matter. Examples include 'that puddle of water' and 'this particular pile of sand'. This topological connectivity defines their unity conditions.

**Sources**:

- **01-UFO (Chunk 1:353-355)**
  > Quantities are maximally-topologically-self-connected (e.g., pieces) of homeomerous amounts of matter

---

### 15. Kind Definition - Identity Principle Provider

A Kind is a fundamental sort of endurant type that provides uniform principles of individuation, identity, and persistence to its instances. Examples: person, dog, computer, car, headache, organization, marriage. Kinds apply necessarily to their instances in all possible situations (rigid types).

**Sources**:

- **01-UFO (Chunk 1:368-369)**
  > a kind, which provides uniform principles of individuation, identity, and persistence to its instances

---

### 16. Sortal Definition - Kind Specialization

A sortal is either a kind or a specialization of exactly one kind. Sortals provide identity conditions for their instances. Every endurant necessarily instantiates exactly one kind, ensuring identity principle uniqueness.

**Sources**:

- **01-UFO (Chunk 1:369-370)**
  > A sortal is either a kind or a specialization of a kind, and every sortal that is not a kind specializes exactly one kind

---

### 17. Subkind Definition - Rigid Specialization

Subkinds are rigid specializations of kinds that apply necessarily to their instances. Examples include hatchback car (subkind of car) and financial organization (subkind of organization). Subkinds inherit the identity principle from their parent kind.

**Sources**:

- **01-UFO (Chunk 1:371-372)**
  > These specializations can be either themselves rigid, in which case they are termed subkinds

---

### 18. Phase Definition - Intrinsic Contingent Classification

Phases are anti-rigid sortals whose contingent classification conditions are intrinsic (internal to the entity). Examples: teenager as a phase of person, tenured employment as a phase of employment. Phases represent states or stages in an entity's lifecycle.

**Sources**:

- **01-UFO (Chunk 1:373-375)**
  > sortals whose contingent classification conditions are intrinsic, termed Phases (e.g., teenager as a phase of person, hemorrhagic dengue fever as a phase of dengue fever)

---

### 19. Role Definition - Relational Contingent Classification

Roles are anti-rigid sortals whose contingent classification conditions are relational (depend on relationships with other entities). Examples: employee (role of person in employment relator scope), husband (role of person in marriage relator scope). Roles emerge from relator mediation.

**Sources**:

- **01-UFO (Chunk 1:375-377)**
  > sortals whose contingent classification conditions are relational, termed roles (e.g., employee as a role of a person in the scope of an employment relator)

---

### 20. Category Definition - Rigid Non-Sortal

Categories are rigid non-sortals that define essential properties for instances of multiple kinds. Example: 'physical object' describes properties (mass, spatial extension) common to kinds like car, person, bridge, cow. Categories abstract over different identity principles.

**Sources**:

- **01-UFO (Chunk 1:381-383)**
  > categories: rigid types that define essential properties for their instances, e.g., the category 'physical object' describing the properties of having a mass and a spatial extension

---

### 21. Phase Mixin Definition - Intrinsic Anti-Rigid Non-Sortal

Phase mixins are anti-rigid non-sortals whose instantiation depends on intrinsic contingent conditions. Examples: 'living animal' (applies to instances of person, dog, horse), 'functional device' (applies to instances of computer, watch, espresso machine). Phase mixins cross kind boundaries.

**Sources**:

- **01-UFO (Chunk 1:385-388)**
  > phase mixins: anti-rigid types that define contingent properties for their instances. Their instantiation is characterized by intrinsic contingent conditions

---

### 22. Role Mixin Definition - Relational Anti-Rigid Non-Sortal

Role mixins are anti-rigid non-sortals whose instantiation depends on relational contingent conditions. Examples: 'customer' for kinds person and organization, 'insured legal relator' for kinds employment and enrollment. Role mixins abstract role patterns across different kinds.

**Sources**:

- **01-UFO (Chunk 1:390-392)**
  > role mixins: anti-rigid types that define contingent properties for their instances. Their instantiation is characterized by relational contingent conditions

---

### 23. Mixin Definition - Semi-Rigid Non-Sortal

Mixins are semi-rigid non-sortals whose properties are essential to some instances but accidental to others. Example: being a 'music artist' is essential to bands but accidental to people. Mixins represent properties that cross the essential/accidental boundary.

**Sources**:

- **01-UFO (Chunk 1:394-395)**
  > mixins: semi-rigid types that define properties that are essential to some of their instances but accidental to some other instances

---

### 24. Type Definition - Possibly Instantiated

Types are formally defined as entities that are possibly instantiated (there exists some possible world where something instantiates them). This distinguishes types from individuals, which are entities that are necessarily not instantiated by anything.

**Sources**:

- **01-UFO (Chunk 1:454-455)**
  > types are implicitly defined as those entities that are possibly instantiated

---

### 25. Individual Definition - Not Instantiable

Individuals are formally defined as entities that are necessarily not instantiated - nothing can be an instance of an individual. The domain is partitioned into types and individuals, with individuals further classified into concrete (endurants, perdurants) and abstract individuals.

**Sources**:

- **01-UFO (Chunk 1:454-458)**
  > while individuals are those necessarily not instantiated

---

### 26. Concrete Individual Definition

Merged from 2 sources. Concrete individuals are the primary partition of individuals, opposed to abstract individuals. Concrete individuals are exhaustively partitioned into endurants (entities wholly present at any time they exist) and perdurants (entities that unfold in time accumulating temporal parts).

**Sources**:

- **01-UFO (Chunk 1:507-509)**
  > Among the individuals, there are concrete individuals (a7) and abstract individuals (a8)-(a10). Concrete individuals are further differentiated into endurants (a11) and perdurants (a12)

- **01-UFO (Chunk 1:507-509)**
  > concrete individuals (a7) and abstract individuals (a8)-(a10)

---

### 27. Rigid Type Definition

Rigid types are endurant types where if an entity possibly instantiates the type, it necessarily instantiates it in all possible worlds where it exists. Rigid types include kinds, subkinds, and categories. A rigid type cannot specialize an anti-rigid one.

**Sources**:

- **01-UFO (Chunk 1:557-562)**
  > We implicitly define rigidity of endurant types as rigid (a18), anti-rigid (a19) and semi-rigid (a20)

---

### 28. Anti-Rigid Type Definition

Anti-rigid types are endurant types where if an entity possibly instantiates the type, it can possibly not instantiate it. Anti-rigid types include phases, roles, phase mixins, and role mixins. These represent contingent classifications.

**Sources**:

- **01-UFO (Chunk 1:557-564)**
  > anti-rigid (a19) and semi-rigid (a20), concluding that every endurant type is either one of the three

---

### 29. Inherence Definition - Moment-Bearer Relation

Inherence is the relation connecting moments to their bearers. It is a type of existential dependence (the moment depends on the bearer for existence). Inherence is non-reflexive, asymmetric, and anti-transitive. A moment cannot inhere in two separate individuals (non-migration principle).

**Sources**:

- **01-UFO (Chunk 2:129-139)**
  > The relation that connects moments to the object that they are about is the relation of inherence. Inherence is a type of existential dependence relation

---

### 30. Ultimate Bearer Definition

The ultimate bearer is the unique entity at the end of inherence chains that does not itself inhere in anything else. Every moment has exactly one ultimate bearer. This grounds moment hierarchies (moments of moments) in non-moment entities.

**Sources**:

- **01-UFO (Chunk 2:156-158)**
  > Moments can also be involved in chains of inherence relations, which are ultimately grounded on a unique entity that does not inhere in anything else. This entity that we will call here the Ultimate Bearer

---

### 31. External Dependence Definition

External dependence is a relation where a mode is existentially dependent on an entity that is existentially independent of the mode's bearer. This captures truly relational qualities. Example: John's commitment towards Mary depends on Mary, who is independent of John (the bearer).

**Sources**:

- **01-UFO (Chunk 2:189-196)**
  > a mode x that is existentially dependent on an entity that is independent of the bearer of x

---

### 32. Externally Dependent Mode Formal Definition

An externally dependent mode is formally defined as a mode that has at least one entity on which it is externally dependent. Example: John's commitment towards Mary is externally dependent on Mary. This excludes modes that only depend on entities too close to the bearer.

**Sources**:

- **01-UFO (Chunk 2:196-206)**
  > ExternallyDependentMode(x) means Mode(x) and there exists y such that externallyDependent(x, y)

---

### 33. Foundation Definition - Event Grounding

Foundation is the relation between externally dependent modes/relators and the unique event that grounds them. Example: John's conjugal commitments towards Mary are founded on the wedding event. Every externally dependent mode has exactly one foundational event.

**Sources**:

- **01-UFO (Chunk 2:207-219)**
  > Externally dependent modes (as well as relators, as we discuss later) are founded by means of a unique event

---

### 34. Qua Individual Formal Definition

A qua individual of entity y is formally the mereological sum of all externally dependent modes of y that share the same foundational event. Example: John-qua-husband-of-Mary sums all conjugal commitments of John founded on the wedding. Qua individuals are complex externally dependent modes.

**Sources**:

- **01-UFO (Chunk 2:222-230)**
  > the relation quaIndividualOf holds between x and y iff x is the sum of all externally dependent modes of y that share the same foundational event

---

### 35. Relator Formal Definition

A relator is formally defined as the sum of qua individuals that share the same foundation and are mutually existentially dependent. Relators have at least two distinct qua individuals as proper parts. Example: Marriage relator contains John-qua-husband and Mary-qua-wife.

**Sources**:

- **01-UFO (Chunk 2:247-264)**
  > Relator(x) means there exists y such that PP(y, x) and for all y, z: if PP(y, x) and PP(z, x) then QuaIndividual(y) and QuaIndividual(z)

---

### 36. Mediation Definition

Mediation is the relation between a relator and the individuals it connects. A relator mediates an endurant when a qua individual of that endurant is part of the relator. Every relator mediates at least two distinct individuals (theorem t33).

**Sources**:

- **01-UFO (Chunk 2:279-283)**
  > We introduce the relation of mediation, mediates(x, y), between a relator x and an individual y that the relator connects in a relational statement

---

### 37. Characterization Definition

Characterization is the relation between an endurant type and moment types that necessarily inhere in its instances. If type t is characterized by moment type m, then every instance of t has exactly one moment of type m inhering in it, and every moment of type m inheres in exactly one instance of t.

**Sources**:

- **01-UFO (Chunk 2:302-306)**
  > a type is characterized by moment types that inhere in its instances

---

### 38. Quale Definition

Merged from 2 sources. A quale (plural: qualia) is a member of exactly one quality structure. Quales are abstract individuals serving as values that qualities can take. Each quality has exactly one quale value at any given time, determined by the hasValue relation.

**Sources**:

- **01-UFO (Chunk 2:350-351)**
  > The members of quality structures are quales, where an entity is a quale iff it is a member of a unique quality structure

- **12-Foundations_of_Process_Event_Data (Chunk 1:169-170)**
  > IEEE XES specifies the concept of a log, a trace, and an attribute component. Event and/or trace classifiers are used to assign an identity to traces and events

---

### 39. Quality Domain vs Quality Dimension

Quality structures partition into quality dimensions (one-dimensional, associated with simple quality types) and quality domains (multi-dimensional Cartesian products, associated with complex quality types). Simple qualities bear nothing; complex qualities bear simple qualities corresponding to domain dimensions.

**Sources**:

- **01-UFO (Chunk 2:351-357)**
  > A quality structure is partitioned into quality dimension and quality domain

---

### 40. Simple Quality Definition

A simple quality is formally defined as a quality that has no moments inhering in it. Simple qualities are associated with quality dimensions (one-dimensional value spaces). Examples include individual height or weight qualities.

**Sources**:

- **01-UFO (Chunk 2:399-401)**
  > A simple quality is a quality that bears nothing

---

### 41. Complex Quality Definition

A complex quality is a quality that bears other qualities (moments inhere in it). Complex qualities are associated with quality domains (multi-dimensional value spaces). Complex qualities can only bear simple qualities. Example: color quality bearing hue, saturation, and brightness.

**Sources**:

- **01-UFO (Chunk 2:400-401)**
  > A complex quality is a quality but not a simple quality

---

### 42. Manifestation Definition - Endurant-Perdurant Link

Manifestation is the relation connecting endurants to perdurants. The life of an endurant is the mereological sum of all events that manifest it. Events manifest dispositions inhering in endurants. This provides the ontological bridge between enduring entities and temporal occurrences.

**Sources**:

- **01-UFO (Chunk 2:505-510)**
  > Any endurant is connected to a perdurant by the manifestation relation

---

### 43. AI Agent Component Definition - LLM Core

Merged from 4 sources. Defines the LLM component of an AI agent as the primary reasoning engine with explicit role and task definitions. The LLM serves as dialogue interface, interprets queries, generates responses, and maintains coherence - establishing Role and Task as fundamental properties of agents.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 1:487-489)**
  > LLM (with defined Role and Task): Serves as the agent's primary reasoning engine and dialogue interface. It interprets user queries, generates responses, and maintains coherence.

- **20-Agentic_RAG_Survey (Chunk 1:491-493)**
  > Memory (Short-Term and Long-Term): Captures context and relevant data across interactions. Short-term memory tracks immediate conversation state, while long-term memory stores accumulated knowledge and agent experiences.

- **20-Agentic_RAG_Survey (Chunk 1:496-497)**
  > Planning (Reflection & Self-Critique): Guides the agent's iterative reasoning process through reflection, query routing, or self-critique, ensuring that complex tasks are broken down effectively.

- **20-Agentic_RAG_Survey (Chunk 1:500-501)**
  > Tools (Vector Search, Web Search, APIs, etc.): Expands the agent's capabilities beyond text generation, enabling access to external resources, real-time data, or specialized computations.

---

### 44. Agentic Pattern Definition - Reflection

Merged from 4 sources. Defines Reflection as a foundational agentic pattern for iterative self-evaluation and output refinement. Establishes self-feedback as mechanism for error identification and quality improvement, representing a Rule-based approach to agent behavior.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 1:515-518)**
  > Reflection is a foundational design pattern in agentic workflows, enabling agents to iteratively evaluate and refine their outputs. By incorporating self-feedback mechanisms, agents can identify and address errors, inconsistencies, and areas for improvement.

- **20-Agentic_RAG_Survey (Chunk 1:540-541)**
  > Planning is a key design pattern in agentic workflows that enables agents to autonomously decompose complex tasks into smaller, manageable subtasks. This capability is essential for multi-hop reasoning and iterative problem-solving.

- **20-Agentic_RAG_Survey (Chunk 1:555-558)**
  > Tool Use enables agents to extend their capabilities by interacting with external tools, APIs, or computational resources. This pattern allows agents to gather information, perform computations, and manipulate data beyond their pre-trained knowledge.

- **20-Agentic_RAG_Survey (Chunk 1:575-578)**
  > Multi-agent collaboration is a key design pattern in agentic workflows that enables task specialization and parallel processing. Agents communicate and share intermediate results, ensuring the overall workflow remains efficient and coherent.

---

### 45. RAG Component Definition - Retriever

Merged from 2 sources. Defines Retrieval as RAG component responsible for querying external Data sources (knowledge bases, APIs, vector databases). Retrieval is a specialized Activity that finds and returns relevant information Resources.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 1:161-163)**
  > Retrieval: Responsible for querying external data sources such as knowledge bases, APIs, or vector databases. Advanced retrievers leverage dense vector search and transformer-based models to improve retrieval precision and semantic relevance.

- **20-Agentic_RAG_Survey (Chunk 1:168-169)**
  > Generation: Combines retrieved information with the LLM's pre-trained knowledge to generate coherent, contextually appropriate responses.

---

### 46. RAG Component Definition - Augmentation

Defines Augmentation as RAG component that processes retrieved Data through extraction and summarization. Represents a transformation Activity that aligns Data with query context.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 1:165-166)**
  > Augmentation: Processes retrieved data, extracting and summarizing the most relevant information to align with the query context.

---

### 47. Agentic RAG Definition - Autonomous Decision-Making

Defines autonomous decision-making as key Agentic RAG capability where Agents independently evaluate query complexity and manage retrieval strategies. Establishes agent autonomy as foundational Entity property.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 1:357-358)**
  > Autonomous Decision-Making: Agents independently evaluate and manage retrieval strategies based on query complexity.

---

### 48. Single-Agent Router Definition

Defines Single-Agent RAG as centralized decision-making architecture with one Agent managing retrieval, routing, and integration. Establishes Role of central coordinator in simplified agent systems.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 1:755-757)**
  > A Single-Agent Agentic RAG serves as a centralized decision-making system where a single agent manages the retrieval, routing, and integration of information.

---

### 49. Multi-Agent RAG Definition

Defines Multi-Agent RAG as modular, scalable architecture using specialized Agents for complex workflows. Establishes Agent specialization and modularity as key architectural patterns for handling diverse Tasks.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 1:877-880)**
  > Multi-Agent RAG represents a modular and scalable evolution of single-agent architectures, designed to handle complex workflows and diverse query types by leveraging multiple specialized agents.

---

### 50. Hierarchical Agent Definition - Top-Tier Agent

Defines Hierarchical Agentic RAG with multi-tiered Agent structure where higher-level Agents oversee and direct lower-level Agents. Establishes Role-based hierarchy as organizational pattern.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 2:103-106)**
  > Hierarchical Agentic RAG systems employ a structured, multi-tiered approach to information retrieval and processing. Agents are organized in a hierarchy, with higher-level agents overseeing and directing lower-level agents.

---

### 51. Corrective RAG Agent Definition - Relevance Evaluator

Defines Relevance Evaluation Agent Role as assessor of document relevance with threshold-based triggering of corrective actions. Establishes quality-gating as Agent function with Rule-based decision criteria.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 2:204-205)**
  > Document Relevance Evaluation: Retrieved documents are assessed for relevance by the Relevance Evaluation Agent. Documents below the relevance threshold trigger corrective steps.

---

### 52. Corrective RAG Agent Definition - Query Refinement

Defines Query Refinement Agent Role with responsibility for query optimization using semantic understanding. Establishes query transformation as specialized Agent Activity for improving retrieval quality.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 2:208-209)**
  > Query Refinement and Augmentation: Queries are refined by the Query Refinement Agent, which leverages semantic understanding to optimize retrieval for better results.

---

### 53. Adaptive RAG Definition - Classifier Role

Defines Classifier as a specialized Role using smaller language model to predict query complexity. Establishes complexity classification as basis for dynamic strategy selection - a Rule-based routing mechanism.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 2:350-357)**
  > Classifier Role: A smaller language model analyzes the query to predict its complexity. The classifier is trained using automatically labeled datasets, derived from past model outcomes and query patterns.

---

### 54. Graph-Based Agent Definition - Retriever Bank

Defines Retriever Bank as modular set of specialized retrieval Agents that dynamically select Data sources based on query requirements. Establishes Agent-Resource relationship with dynamic selection Rules.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 2:484-490)**
  > Retriever Bank: A modular set of agents specializes in retrieving graph-based or unstructured data. Agents dynamically select relevant sources based on the query's requirements.

---

### 55. Critic Module Definition

Merged from 2 sources. Defines Critic Module as quality validation Role that assesses relevance and flags low-confidence results. Establishes quality assurance as distinct Agent function with confidence-based Rules for triggering refinement.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 2:493-499)**
  > Critic Module: Validates retrieved data for relevance and quality. Flags low-confidence results for re-retrieval or refinement.

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:405-410)**
  > Parser extracts information from LLM thoughts. For each such thought, the Parser constructs the thought state, which contains this extracted information

---

### 56. Agentic Document Workflow Definition

Defines Agentic Document Workflows as end-to-end automation of document-centric processes. Integrates parsing, retrieval, reasoning, and structured outputs - establishing workflow as coordinated sequence of Activities on Data entities.

**Sources**:

- **20-Agentic_RAG_Survey (Chunk 2:704-708)**
  > Agentic Document Workflows (ADW) extend traditional RAG paradigms by enabling end-to-end knowledge work automation. These workflows orchestrate complex document-centric processes, integrating document parsing, retrieval, reasoning, and structured outputs.

---

### 57. LLM Definition - Transformer Foundation

Defines LLMs as transformer-based neural networks classified as Foundation Models. Trained on extensive Data for general-purpose application, establishing LLM as versatile Agent type not purpose-specific.

**Sources**:

- **21-LLM_Smart_Contracts_from_BPMN (Chunk 1:130-133)**
  > Large Language Models (LLMs) are transformer-based neural network systems. LLMs are a specific class of Foundation Models, a class of machine learning models trained on extensive data sets, not for one specific purpose but as a basis for many possible applications.

---

### 58. Token Definition

Defines Tokens as the fundamental units of LLM input/output. Tokens are Data entities representing words, subwords, characters, or special characters that determine computational load of model operations.

**Sources**:

- **21-LLM_Smart_Contracts_from_BPMN (Chunk 1:148-150)**
  > Tokens are the units of input and output for LLMs. Tokens can be whole words, subwords (parts of words), individual characters, punctuation, or special characters.

---

### 59. Reasoning Model Definition

Defines Reasoning Models as LLMs that generate plans, execute steps, and verify work. Establishes Goal-Plan-Execute-Verify as reasoning pattern, with planning as explicit Activity type.

**Sources**:

- **21-LLM_Smart_Contracts_from_BPMN (Chunk 1:156-158)**
  > Models that perform complex reasoning (so called reasoning models) typically generate a plan to answer a query, execute the steps in the plan, and possibly check their work.

---

### 60. Temperature Setting Definition

Defines Temperature as LLM configuration parameter controlling output randomness. Low values yield predictable outputs; high values encourage creativity. Establishes configuration as Rule governing Agent behavior.

**Sources**:

- **21-LLM_Smart_Contracts_from_BPMN (Chunk 1:171-174)**
  > Temperature is a setting for LLMs that controls the randomness of generated text; lower temperatures make outputs more predictable and focused, while higher temperatures encourage more creative and varied responses.

---

### 61. Zero-Shot Prompting Definition

Defines Zero-Shot Prompting as task completion using only instructions without examples. Establishes instruction-only execution as Agent capability mode, with instructions as Rules guiding behavior.

**Sources**:

- **21-LLM_Smart_Contracts_from_BPMN (Chunk 1:145-146)**
  > In zero-shot prompting, models complete tasks based solely on instructions without prior examples.

---

### 62. Few-Shot Prompting Definition

Defines Few-Shot Prompting as providing examples within input for task guidance. Examples serve as Data-based learning patterns that modify Agent behavior without explicit training.

**Sources**:

- **21-LLM_Smart_Contracts_from_BPMN (Chunk 1:146-147)**
  > Few-shot prompting involves providing a handful of illustrative examples directly within the input.

---

### 63. Trace Definition - Process Mining

Defines Trace as ordered sequence of Events/Activities for a specific case. Establishes Event as atomic occurrence within process, with Trace as temporal ordering of Events representing process execution.

**Sources**:

- **21-LLM_Smart_Contracts_from_BPMN (Chunk 1:247-251)**
  > We loosely denote an event log as a set of events, where each event is associated with a case identifier that groups it into a case. A trace is the ordered sequence of events (activities) that occurred for a specific case.

---

### 64. Conformance Definition

Defines Conformance as alignment between Trace and process model where trace represents valid execution path. Establishes Rule-based validation relationship between actual Events and prescribed process.

**Sources**:

- **21-LLM_Smart_Contracts_from_BPMN (Chunk 1:250-251)**
  > A trace can be said to be in conformance with a process model if it represents a valid execution path through that model.

---

### 65. RPA Definition

Defines RPA as automation technology operating on presentation layer, user-configurable, centrally managed. Establishes RPA as Agent type with specific operational constraints (UI layer, low-code setup, central orchestration).

**Sources**:

- **22-RPA_Framework_BPM_Activities (Chunk 1:107-109)**
  > In this work, we define RPA as an automation technology which performs work on the presentation layer, can be set up by a business user, and is managed on a centralized platform.

---

### 66. Software Robot Definition

Defines Software Robots/Bots as software algorithms imitating human execution flow on UI. Establishes Agent-Activity relationship where robot replicates human Task execution patterns.

**Sources**:

- **22-RPA_Framework_BPM_Activities (Chunk 1:88-91)**
  > This is achieved by the application of software algorithms known as software robots or bots, which are imitating the execution flow of humans on the front-end.

---

### 67. Process Activity Definition

Defines Process Activity as the unit of analysis for RPA viability. Activities are Tasks with specific characteristics determining automation suitability. Core Entity in RPA selection framework.

**Sources**:

- **22-RPA_Framework_BPM_Activities (Chunk 1:62-64)**
  > What are the characteristics of a process activity, or a set of process activities, that facilitate viable robotic process automation?

---

### 68. Standardization Criterion Definition

Defines Standardization as degree of process structure where elements are unambiguous and execution order consistent. Establishes Rule-based criteria for Activity predictability.

**Sources**:

- **22-RPA_Framework_BPM_Activities (Chunk 1:326-328)**
  > First, standardization refers to a process's degree of structure. In standardized processes, every process element is unambiguous, and the execution order remains the same in each process instance.

---

### 69. Maturity Criterion Definition

Defines Maturity as stability of process flow over time with specification and predictability. Establishes temporal consistency as property of mature processes suitable for automation.

**Sources**:

- **22-RPA_Framework_BPM_Activities (Chunk 1:332-334)**
  > Maturity indicates that no frequent changes to the process flow are observable. Therefore, processes need to be specified and predictable over a period in time.

---

### 70. Determinism Criterion Definition

Defines Determinism as Activity property consisting of logical steps without cognitive assessment. Rule-based execution is fundamental requirement distinguishing automatable from human-judgment Tasks.

**Sources**:

- **22-RPA_Framework_BPM_Activities (Chunk 1:335-340)**
  > Determinism is one of the most distinctive criteria to assess the viability of RPA. Deterministic activities consist of logical execution steps without any form of cognitive assessment.

---

### 71. Framework Perspective Definitions

Defines five evaluation perspectives: Task, Time, Data, System, and Human. Establishes multi-dimensional framework for Activity assessment, aligning with entity categories (Activity, Resource, Agent).

**Sources**:

- **22-RPA_Framework_BPM_Activities (Chunk 1:235-236)**
  > We present five perspectives - task, time, data, system, and human - that contain several characteristics that analysts can use to evaluate a process accordingly.

---

### 72. Foundational Ontology UFO Definition

Defines UFO (Unified Foundational Ontology) as theoretical foundation for conceptual modeling providing theories, methodologies, and engineering tools. UFO is meta-level framework grounding Entity definitions.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:22-27)**
  > This program, organized around the theoretical background of the foundational ontology UFO (Unified Foundational Ontology), aims at developing theories, methodologies and engineering tools with the goal of advancing conceptual modeling as a theoretically sound discipline.

---

### 73. UFO-A Definition - Endurants

Defines UFO-A as ontology of Endurants (things wholly present at any time they exist) for structural modeling. Covers Types, Taxonomic Structures, Part-Whole Relations, Properties, Attributes, Datatypes, Relations, and Roles.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:173-181)**
  > UFO-A: An Ontology of Endurants dealing with aspects of structural conceptual modeling. It is organized as a Four-Category ontology comprising theories of Types and Taxonomic Structures connected to a theory of object identifiers.

---

### 74. UFO-B Definition - Perdurants

Defines UFO-B as ontology of Perdurants (Events, Processes that unfold in time). Covers mereology, temporal ordering, object participation, causation, and change. Establishes Event as fundamental temporal Entity.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:183-185)**
  > UFO-B: An Ontology of Perdurants (Events, Processes) dealing with aspects such as Perdurant Mereology, Temporal Ordering of Perdurants, Object Participation in Perdurants, Causation, Change.

---

### 75. UFO-C Definition - Intentional/Social Entities

Defines UFO-C as ontology of Intentional and Social Entities building on UFO-A/B. Covers Beliefs, Desires, Intentions, Goals, Actions, Commitments, Claims, Social Roles - establishing Agent intentionality.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:191-193)**
  > UFO-C: An Ontology of Intentional and Social Entities, which is constructed on top of UFO-A and UFO-B, and which addresses notions such as Beliefs, Desires, Intentions, Goals, Actions, Commitments and Claims, Social Roles.

---

### 76. Four-Category Ontology Definition

Defines Four-Category Ontology distinguishing individuals/universals and substantials/accidents. Establishes ontological categories: substantial individuals, substantial universals, accidents (particularized properties), accident universals.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:126-129)**
  > It was clear to us from the outset that we needed an ontological theory that would countenance both individuals and universals and one that would include not only substantial individuals and universals but also accidents (particularized properties, moments, qualities, modes, tropes).

---

### 77. Endurant Definition

Defines Endurant as entity wholly present at any moment of its existence (from extraction guide context). Endurants are objects, things, substances that persist through time while maintaining identity.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:173)**
  > UFO-A: An Ontology of Endurants dealing with aspects of structural conceptual modeling.

---

### 78. Perdurant Definition

Defines Perdurant as entity that unfolds in time having temporal parts (Events, Processes). Perdurants are occurrents - happenings that occur over intervals, contrasted with enduring Endurants.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:183)**
  > UFO-B: An Ontology of Perdurants (Events, Processes)

---

### 79. OntoUML Definition

Defines OntoUML as ontologically well-founded UML variant for structural conceptual modeling. Language primitives isomorphic to UFO-A distinctions with formal constraints ensuring valid models represent intended states.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:213-216)**
  > OntoUML was conceived as an ontologically well-founded version of the UML 2.0 fragment of class diagrams. The idea was to employ the ontology-based language engineering method to design a language for structural conceptual modeling.

---

### 80. Ontological Pattern Definition

Defines Ontological Patterns as higher-granularity modeling primitives appearing in fixed configurations. Patterns reflect ontological micro-theories, establishing Rule-based constraints on valid Entity combinations.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:257-262)**
  > OntoUML is actually a Pattern-Based Language in the sense that its modeling primitives are patterns, i.e., higher-granularity clusters of modeling elements that can appear in a model only in particular fixed configurations.

---

### 81. Anti-Pattern Definition

Defines Anti-Patterns as recurrent structures causing deviation between formally valid and intended model instances. Anti-patterns represent Rule violations detectable and rectifiable through solution patterns.

**Sources**:

- **23-UFO_Story_Ontological_Foundations (Chunk 1:323-326)**
  > Once these anti-patterns are catalogued, they were able to devise solution patterns, i.e., solution proposals that eliminate the deviation between valid instances and intended instances.

---

### 82. Process Entity Definition

Merged from 5 sources. Formal definition of Process as a procedure involving steps/operations that produces outputs. This is from ISO 1998 standard. In BBO, Process is a subclass of FlowElementsContainer and represents the key concept around which business process representation is organized.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:60-62)**
  > a process is a particular procedure for doing something involving one or more steps or operations. The process may produce a product, a property of a product, or an aspect of a product

- **31-BBO_BPMN_Ontology (Chunk 1:241)**
  > Gateway is used to control how SequenceFlows interact as they converge or diverge within a Process

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:893-898)**
  > We reify the relation between two entity types ent1 and ent2 into a new derived entity type (ent1, ent2). That is, we make each pair (n1, n2) an entity node with (n1, n2).type = (ent1, ent2).

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:3-5)**
  > we can treat any derived entity (n1, n2) just like any other entity and infer the df-relationships for (n1, n2), which results in a new path

- **15-SciAgents (Chunk 10:129-138)**
  > Chemical Vapor Deposition (CVD): High-quality graphene sheets will be synthesized... Amyloid Fibril Formation... Composite Formation

---

### 83. Activity Entity Definition

Merged from 3 sources. Emerging entities are formally defined as new candidate nodes extracted from text that do not yet exist in the knowledge graph. This distinguishes between established entities (with existing nodes) and emerging entities (newly discovered candidates).

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:229)**
  > Activity is the work to be performed. Activity class has three sub-classes: Task (an atomic task), Sub-Process (complex task that contains several Tasks), CallActivity

- **31-BBO_BPMN_Ontology (Chunk 1:416)**
  > End Event ends the flow of the Process, and thus, will not have any outgoing Sequence Flows

- **02-Knowledge_Graphs (Chunk 6:226-230)**
  > The named entities identified by NER may be used to generate new candidate nodes for the knowledge graph (known as emerging entities, shown dashed in Figure 31)

---

### 84. Task Entity Definition

Merged from 3 sources. Role is distinct from Job to enable flexible authorization modeling. Role defines permissions and responsibilities for activity execution. Activities can be assigned to Roles (indirect assignment) making all agents playing that role potential performers.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:230-231)**
  > Task: an atomic task

- **31-BBO_BPMN_Ontology (Chunk 1:350-353)**
  > we differentiated Job from Role to offer more flexibility. Indeed, two persons that have the same Job, may have different authorization levels to execute Activities

- **15-SciAgents (Chunk 4:92)**
  > Silk: A natural protein fiber produced by certain insects, most notably silkworms, used in textiles and biomedical applications due to its strength and biocompatibility

---

### 85. Sub-Process Entity Definition

Merged from 3 sources. Sub-Process is a composite activity that contains multiple Tasks. Unlike atomic Tasks, Sub-Processes may require several manufacturing facilities since they encompass multiple work units.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:231)**
  > Sub-Process: complex task that contains several Tasks

- **31-BBO_BPMN_Ontology (Chunk 1:415)**
  > A Start Event MUST be a source for a Sequence Flow

- **31-BBO_BPMN_Ontology (Chunk 1:444)**
  > A Timer Event is an Event that has exactly one TimerEventDefinition

---

### 86. Event Entity Definition

Merged from 2 sources. Agent is the actor responsible for performing activities. An Agent may be HumanResource or SoftwareResource. Agents can be assigned directly to activities or indirectly via Roles. Multiple agents with the same Role are potential performers.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:236-239)**
  > Event is something that happens during the course of a process. Events affect the flow of the process and usually have a cause or an impact and may require or allow for a reaction

- **31-BBO_BPMN_Ontology (Chunk 1:191-192)**
  > Agent: the actor that performs a given process activity. Indeed, it is important to specify who is responsible for the accomplishment of a given activity

---

### 87. ConvergingGateway Entity Definition

ConvergingGateway is formally defined via cardinality restrictions: it must have 2+ incoming SequenceFlows and exactly 1 outgoing SequenceFlow. This definition is formalized in OWL as equivalence class with min/exactly restrictions.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:248-249)**
  > A Gateway with a gatewayDirection of converging MUST have multiple incoming Sequence Flows, but MUST NOT have multiple outgoing Sequence Flows

---

### 88. Agent Taxonomy Definition

Agent class is taxonomized into HumanResource and SoftwareResource subclasses. This reuses the Agent sub-ontology from Ruiz et al. 2004.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:346-347)**
  > An Agent may be a HumanResource or a SoftwareResource

---

### 89. Resource Entity Definition

Merged from 3 sources. Resource in BBO encompasses all resource types (broader than BPMN's agent-limited definition). BBO adopts the comprehensive definition where Resource includes any input/output of activities, enabling a resource taxonomy. Resource is the result of a process per ISO definition.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:290-293)**
  > The Resource concept exists in the BPMN meta-model. However, its semantics and definition are ambiguous... we adopt the first definition of Resource, that englobes all resource types

- **31-BBO_BPMN_Ontology (Chunk 1:223)**
  > FlowNode class groups the activities that compose a process

- **12-Foundations_of_Process_Event_Data (Chunk 1:148-152)**
  > the availability of additional data attributes, especially information on resources, costs, etc. opens up possibilities for the application of process mining techniques that go beyond process discovery... organizational mining techniques were developed to focus on resources

---

### 90. WorkProduct Entity Definition

WorkProduct is defined as something produced by a process (from ISO 2005). WorkProduct is a subtype of MaterialResource because once produced, a product can be used as input for other activities. WorkProduct has is_composedOf relation to Resource.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:326-328)**
  > Product is defined as follows: Thing or substance produced by a natural or artificial process. We adopt this definition for the WorkProduct concept... we consider WorkProduct as a particular type of MaterialResource

---

### 91. Job Entity Definition

Job represents organizational position with hierarchical relations (subordinated/superior). Job is differentiated from Role - same Job holders may have different Role-based authorizations. Extends BPMN to model organizational structure.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:346-350)**
  > The concept Job with the two relations subordinated and superior represent the organizational model of the company, which is not supported by BPMN meta-model

---

### 92. SequenceFlow Entity Definition

SequenceFlow is a transition connecting FlowNodes with optional condition expressions. Subtypes include ConditionalSequenceFlow, DefaultSequenceFlow, and NormalSequenceFlow based on condition specifications.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:221-223)**
  > SequenceFlow represents transitions that ensure the move from the source FlowNode to the target one. A SequenceFlow may depend on a given condition, which is represented as an instance of Expression class

---

### 93. ConditionalSequenceFlow Entity Definition

ConditionalSequenceFlow is formally defined as SequenceFlow with has_conditionExpression some Expression. This OWL equivalence class definition enables automatic classification of instances.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:443)**
  > Conditional SequenceFlow is a SequenceFlow that has a specified condition Expression

---

### 94. FlowElementsContainer Entity Definition

FlowElementsContainer is the superclass of Process, containing FlowElements (SequenceFlow and FlowNode). This structural pattern enables process decomposition and composition.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:220-221)**
  > Process is a sub-class of FlowElementsContainer. Describing a process consists in defining the FlowElements that compose it

---

### 95. InputOutputSpecification Entity Definition

InputOutputSpecification captures activity inputs and outputs. Extended beyond BPMN's data-only model with has_resourceInput and has_resourceOutput relations to Resource class, enabling specification of material resources, software, tools, etc.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:282-286)**
  > an activity may have at most one InputOutputSpecification that is related to the required Input/Output Data. However, we need to specify Input/Output of various types, not only those of data type

---

### 96. ManufacturingFacility Entity Definition

ManufacturingFacility is the place where activities occur, with taxonomy: Station (workstation for particular job), Cell (groups related operations), Shop (production area), Factory (contains production areas). Task limited to one ManufacturingFacility; Process may have several.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:195,309-313)**
  > Manufacturing facility: the place where the process activities should be performed... A workstation, Station, is where a particular job is performed. Cell is the place that groups a set of related operations

---

### 97. Parameter Entity Definition

Parameter represents value specifications for activities, with QualitativeParameter and QuantitativeParameter subtypes. Related to ParameterValue and ParameterExpectedValue for binding, and UnitOfMeasure for quantitative parameters.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:287-288)**
  > we have added the concepts: ParameterValueBinding, Parameter and its subclasses QualitativeParameter and QuantitativeParameter, ParameterValue, ParameterExpectedValue, and UnitOfMeasure

---

### 98. Expression Entity Definition

Expression represents conditions controlling SequenceFlow transitions. Includes UnderspecifiedExpression subtype for incomplete condition specifications.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:222-223)**
  > A SequenceFlow may depend on a given condition, which is represented as an instance of Expression class

---

### 99. CallActivity Entity Definition

CallActivity is an Activity that invokes reusable elements (CallableElement). Can call GlobalTask for reusable atomic work or Sub-Process for reusable composite work.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:232-233)**
  > CallActivity: an activity that calls a CallableElement that may be a GlobalTask (i.e., a reusable task) or Sub-Process

---

### 100. DataResource Entity Definition

DataResource is a type in the Resource taxonomy representing data/information inputs and outputs of activities. Part of the extended Resource classification beyond BPMN's original data-only input/output model.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:282-284)**
  > In BPMN meta-model, an activity may have at most one InputOutputSpecification that is related to the required Input/Output Data

---

### 101. MaterialResource Entity Definition

Merged from 2 sources. MaterialResource is a Resource type representing physical/material items. WorkProduct is a subtype of MaterialResource. Part of the resource taxonomy inspired by Falbo/Bertollo and Karray et al.

**Sources**:

- **31-BBO_BPMN_Ontology (Chunk 1:327-329)**
  > we consider WorkProduct as a particular type of MaterialResource, as states the ISO definition: Resource is the result of a process

- **31-BBO_BPMN_Ontology (Chunk 1:346)**
  > An Agent may be a HumanResource or a SoftwareResource

---

### 102. Quality as Variable Trope

UFO defines Quality as a type of moment (dependent entity) that inheres in a bearer and takes values from a quality structure. Unlike tropes in the classical sense, qualities are 'variable tropes' - they can change their values while maintaining identity. This relates to the 8-entity hypothesis by grounding how Data/attributes attach to entities.

**Sources**:

- **01-UFO (Chunk 3:6-8)**
  > As for any quality, a Flower Color quality inheres in its bearer (the characterization relation). A perceivable quality takes its value in a color domain

---

### 103. Inherence as Existential Dependence

Inherence in UFO is defined as existential dependence - a quality cannot exist without its bearer, and this connection is immutable. However, the hasValue relation between a quality and its value (qualia) is generic dependence, allowing change. This pattern is fundamental for understanding how properties attach to entities.

**Sources**:

- **01-UFO (Chunk 3:82-85)**
  > inherence is an existential dependence relation and, hence, the connection between a particular quality and its bearer is immutable

---

### 104. Event as Modally Fragile Entity

UFO defines Events as modally fragile entities that cannot genuinely change - they are fixed once they occur. Events are polygenic manifestations of dispositions. This formal definition distinguishes Events from Endurants (which can change) in the 8-entity framework.

**Sources**:

- **01-UFO (Chunk 3:103-107)**
  > In UFO, we follow a classical view of events in which events are modally fragile entities. So, events cannot bear modal properties, they cannot genuinely change

---

### 105. Role as Externally Dependent Mode

UFO defines Role as a pattern where an entity (like Person) plays a Role (like Jogger) by bearing a Mode that comprises intentional states and capacities. This grounds the Role entity type in the 8-entity hypothesis through the mode-bearing relationship.

**Sources**:

- **01-UFO (Chunk 3:129-131)**
  > Jogger is a role played by a Person when bearing a Jog mode (an endurant comprising an intention as well as the capacities of the person as a Jogger)

---

### 106. Process as Life of Endurant

UFO defines Process as the 'life' of an endurant - constituted by all Events that manifest the endurant's dispositions. This recursive definition connects Events to ongoing Processes through constitution and manifestation relations.

**Sources**:

- **01-UFO (Chunk 3:161-165)**
  > At each situation, we have a particular type of maximal Jogging Process...that is constituted by (exactly) the sum of Jogging Events that are manifestations of that Jog

---

### 107. Event Partition into States and Locomotions

UFO partitions Events into stative (homeomerous) and dynamic types. Stative events maintain uniform properties throughout; dynamic events involve sequences of changes. Events are characterized by tropes (immutable properties) rather than variable qualities.

**Sources**:

- **01-UFO (Chunk 3:186-191)**
  > Jogging Events can be stative/homeomerous and some are dynamic/sequences of changes. In the former's case, we have Jog State, while in the latter we have Jogging Locomotion

---

### 108. Walk Mode with External Dependence

UFO defines complex Modes that have both inherence (to their bearer) and external dependence (on other entities like destinations). This pattern captures intentional actions with Goals - relating to Goal entity in the 8-entity hypothesis.

**Sources**:

- **01-UFO (Chunk 3:264-266)**
  > a Walk is modeled as an externally dependent mode that inheres in the Walker and that is externally dependent on Place (that plays the role of an originally intended destination)

---

### 109. Relator as Social Entity

UFO defines Relator as a social entity that mediates between other entities. Relators can have types that evolve over time while maintaining core identity. This grounds social/organizational relationships in the ontology.

**Sources**:

- **01-UFO (Chunk 3:412-416)**
  > We observe that what remains stable here is a general kind of relator we call Conjugal Relationship between Spouses. Varying constraints established in the social process in time lead to specific types

---

### 110. Higher-Order Type (Powertype)

UFO supports higher-order types (metatypes) where instances are themselves types. This powertype pattern enables modeling concept evolution and type hierarchies, supporting flexible metamodeling for the UDWO framework.

**Sources**:

- **01-UFO (Chunk 3:419-424)**
  > UFO captures this scenario by accounting not only for the individuals in the domain of inquiry but types as well. This leads to higher-order types, i.e., types whose instances are themselves types

---

### 111. OntoUML Stereotype Taxonomy

UFO uses OntoUML stereotypes (SubKind, Role, RelatorKind, ModeKind, etc.) to classify entity types. Each stereotype has specific ontological commitments about identity, rigidity, and dependence that constrain valid modeling patterns.

**Sources**:

- **01-UFO (Chunk 3:487-489)**
  > SubKind(MonogamousHeterosexualMarriage) MonogamousHeterosexualMarriage < ConjugalRelationship

---

### 112. Knowledge Graph Definition (Inclusive)

Formal definition of knowledge graph as a graph where nodes represent entities and edges represent relations. The graph conforms to a data model (directed edge-labelled, property graph, etc.) and aims to capture real-world knowledge. This is the foundational entity definition for KG-based systems.

**Sources**:

- **02-KG (Chunk 1:138-142)**
  > we view a knowledge graph as a graph of data intended to accumulate and convey knowledge of the real world, whose nodes represent entities of interest and whose edges represent relations between these entities

---

### 113. Entity Definition in KG Context

In knowledge graphs, Entity is defined as a node representing a real-world thing (person, place, concept). Entities are connected by Relations (edges) that can be cyclical. This basic Entity-Relation pattern underlies all KG representations.

**Sources**:

- **02-KG (Chunk 1:77-81)**
  > Graphs provide a concise and intuitive abstraction for a variety of domains, where edges capture the (potentially cyclical) relations between the entities inherent in social data, biological interactions

---

### 114. Directed Edge-Labelled Graph Model

Formal definition of directed edge-labelled graph: nodes represent entities, directed labelled edges represent binary relations. This is the foundational data model for RDF and many knowledge graphs, defining how Entity and Relation are technically represented.

**Sources**:

- **02-KG (Chunk 1:404-408)**
  > A directed edge-labelled graph (also known as a multi-relational graph) is defined as a set of nodes...and a set of directed labelled edges between those nodes

---

### 115. Heterogeneous Graph with Node Types

Heterogeneous graphs extend the basic model by assigning explicit types to nodes and edges. This supports Entity typing (homogeneous vs heterogeneous edges) and enables type-based partitioning for machine learning. Directly relates to entity_types field.

**Sources**:

- **02-KG (Chunk 1:483-490)**
  > A heterogeneous graph (or heterogeneous information network) is a graph where each node and edge is assigned one type

---

### 116. Property Graph Model

Property graphs allow property-value pairs on nodes AND edges, with labels for typing. This extends Entity definition to include attributes, and allows Relations (edges) to carry metadata. Used in Neo4j and commercial graph databases.

**Sources**:

- **02-KG (Chunk 1:548-551)**
  > The property graph model was thus proposed to offer additional flexibility when modelling data as a graph. A property graph allows a set of property-value pairs and a label to be associated with both nodes and edges

---

### 117. Graph Dataset with Named Graphs

Graph datasets organize multiple graphs with identifiers. Named graphs enable provenance tracking, source management, and context scoping. This pattern is essential for multi-source knowledge graph integration.

**Sources**:

- **02-KG (Chunk 1:583-598)**
  > A graph dataset then consists of a set of named graphs and a default graph. Each named graph is a pair of a graph ID and a graph

---

### 118. Class Definition in Semantic Schema

Semantic schema defines Classes as groupings of entities sharing common characteristics. Classes form hierarchies (subclass relations) and are used to type entities. This grounds the abstract entity taxonomy in concrete schema definitions.

**Sources**:

- **02-KG (Chunk 1:1000-1001)**
  > A semantic schema allows for defining the meaning of high-level terms (aka vocabulary or terminology) used in the graph

---

### 119. Class Hierarchy with Subclass

Classes are organized in hierarchies where subclass relations enable inference. If X is instance of subclass, X is also instance of superclass. This taxonomic pattern is fundamental for entity classification and type reasoning.

**Sources**:

- **02-KG (Chunk 2:113-118)**
  > In Figure 11, we present a class hierarchy for events where children are defined to be subclasses of their parents such that if we find an edge EID15 type Food Festival...we may also infer that EID15 type Festival

---

### 120. Property with Domain and Range

Properties (relations) have domain and range constraints defining valid entity types for subject and object positions. Domain specifies source entity type; range specifies target entity type. This constrains valid Entity-Relation-Entity patterns.

**Sources**:

- **02-KG (Chunk 2:127-131)**
  > We may further define the domain of properties, indicating the class(es) of entities for nodes from which edges with that property extend

---

### 121. Open World Assumption (OWA)

Under OWA, absence of an edge does not mean the relation is false - only that it is unknown. This assumption affects entity and relation definitions: entities may have unknown properties. Contrasts with CWA where unknown = false.

**Sources**:

- **02-KG (Chunk 2:192-210)**
  > A consequence of CWA is that the addition of an edge to the data graph may contradict what was previously assumed to be false, whereas with OWA, a statement that is proven false continues to be false

---

### 122. Shape as Validation Constraint

Shapes define constraints on entities (nodes). A shape targets entities (by class, property, query) and specifies required/optional properties, cardinalities, and value types. This validates whether entities conform to expected definitions.

**Sources**:

- **02-KG (Chunk 2:251-260)**
  > A shape targets a set of nodes in a data graph and specifies constraints on those nodes. The shape's target can be defined in many ways

---

### 123. Quotient Graph as Schema Summary

Quotient graphs partition entities into equivalence classes based on structural similarity. The quotient graph summarizes entity types and their relationships, providing an emergent schema from data. This connects bottom-up entity discovery to schema definition.

**Sources**:

- **02-KG (Chunk 2:439-448)**
  > A framework often used for defining emergent schema is that of quotient graphs, which partition groups of nodes in the data graph according to some equivalence relation

---

### 124. Persistent Identifier (PID) for Entity

Entities require unique persistent identifiers to avoid naming clashes across knowledge graphs. PIDs (DOIs, IRIs, ORCIDs) provide global identity. This is fundamental for entity disambiguation and cross-graph integration.

**Sources**:

- **02-KG (Chunk 2:562-567)**
  > To avoid such clashes, long-lasting persistent identifiers (PIDs) can be created in order to uniquely identify an entity. Prominent examples of PID schemes include Digital Object Identifiers (DOIs)

---

### 125. IRI as Entity Identifier

IRIs (Internationalized Resource Identifiers) identify real-world entities distinctly from URLs (which identify documents about entities). This separation prevents confusion between entity and description, essential for precise entity definition.

**Sources**:

- **02-KG (Chunk 2:585-594)**
  > RDF 1.1 proposes to use Internationalised Resource Identifiers (IRIs) to identify non-information resources such as cities or events

---

### 126. Identity Link (owl:sameAs)

Identity links (owl:sameAs) assert that two nodes refer to the same real-world entity. This enables entity resolution across knowledge graphs and is essential for data integration where the same Entity has different identifiers.

**Sources**:

- **02-KG (Chunk 2:687-694)**
  > identity links to state that a local entity has the same identity as another coreferent entity found in an external source; an instantiation of this concept can be found in the OWL standard, which defines the owl:sameAs property

---

### 127. Datatype Value as Entity Property

Entities can have datatype values (strings, integers, dates) as property values. These are distinct from entity nodes - they represent Data/values rather than real-world things. Datatype nodes cannot have outgoing edges in RDF.

**Sources**:

- **02-KG (Chunk 2:712-721)**
  > Most practical data models for graphs allow for defining nodes that are datatype values. RDF utilises XML Schema Datatypes (XSD)

---

### 128. Lexicalized Entity with Labels

Entities have human-readable labels (rdfs:label) separate from their identifiers. Labels may be multilingual. Lexicalized knowledge graphs support entity grounding through natural language labels for human interpretation and NLP integration.

**Sources**:

- **02-KG (Chunk 2:748-753)**
  > Since identifiers can be arbitrary, it is common to add edges that provide a human-interpretable label for nodes, such as wd:Q2887 rdfs:label 'Santiago'

---

### 129. Existential Node (Blank Node)

Existential nodes (blank nodes in RDF) represent entities known to exist but without assigned identifiers. They assert existence without identity, useful for modeling incomplete knowledge about entities.

**Sources**:

- **02-KG (Chunk 2:779-798)**
  > some graph models permit the use of existential nodes...These edges denote that there exists a common venue for chile:EID42 and chile:EID42 without identifying it

---

### 130. Context as Scope of Truth

Context defines the scope in which entity properties/relations hold true. Context includes temporal (when), geographic (where), and provenance (source) dimensions. Entities and their relations may be context-dependent.

**Sources**:

- **02-KG (Chunk 2:833-837)**
  > By context we herein refer to the scope of truth, and thus talk about the context in which some data are held to be true

---

### 131. Temporal Context Annotation

Temporal annotations specify when relations between entities hold. Time intervals constrain validity of edges. Similarly, fuzzy annotations provide confidence degrees. This extends Entity-Relation model with context/confidence metadata.

**Sources**:

- **02-KG (Chunk 3:111-117)**
  > Temporal RDF allows for annotating edges with time intervals, such as Chile [2006,2010] M. Bachelet, while Fuzzy RDF allows for annotating edges with a degree of truth

---

### 132. Annotated RDF with Semi-rings

Annotated RDF uses algebraic semi-ring structures to model contextual domains. Meet combines conjunctive context (intersection); join combines disjunctive context (union). This formal framework supports reasoning about entity properties in context.

**Sources**:

- **02-KG (Chunk 3:120-126)**
  > Annotated RDF allows for representing various forms of context modelled as semi-rings: algebraic structures consisting of domain values...and two main operators to combine domain values: meet and join

---

### 133. Ontology as Formal Representation

Ontology provides formal definitions of entity types, their properties, and relationships. It defines what terms (entity names, relation names) mean in a specific domain. This is the meta-level definition that grounds all entity definitions.

**Sources**:

- **02-KG (Chunk 3:311-313)**
  > In the context of computing, an ontology is then a concrete, formal representation of what terms mean within the scope in which they are used

---

### 134. Interpretation Mapping Terms to Domain

Interpretation maps graph terms (nodes, edge labels) to domain entities and relations. This formal semantics defines how syntactic entities in the graph correspond to real-world things. Essential for understanding entity semantics.

**Sources**:

- **02-KG (Chunk 3:374-377)**
  > we can abstractly define an interpretation of a data graph as being composed of two elements: a domain graph, and a mapping from the terms (nodes and edge-labels) of the data graph to those of the domain graph

---

### 135. Individual (OWL Entity Instance)

Individuals in OWL are specific entity instances (as opposed to classes/types). Individuals can have assertions (property values), same-as relations, and different-from relations. They instantiate Entity types defined by classes.

**Sources**:

- **02-KG (Chunk 3:473-475)**
  > In Table 3, we list the main features supported by OWL for describing individuals (e.g., Santiago, EID16), sometimes distinguished from classes and properties

---

### 136. Property Axioms in OWL

OWL property axioms define relation characteristics: transitivity, symmetry, reflexivity, etc. These constrain how Relations between Entities behave. Functional/inverse-functional properties affect entity identity inference.

**Sources**:

- **02-KG (Chunk 3:492-500)**
  > We may define a pair of properties to be equivalent, inverses, or disjoint. We can further define a particular property to denote a transitive, symmetric, asymmetric, reflexive, or irreflexive relation

---

### 137. Class Axioms in OWL

OWL class axioms define relationships between entity types: subclass, equivalence, disjointness. Set operators (complement, union, intersection, enumeration) create complex class definitions. This enables sophisticated entity type hierarchies.

**Sources**:

- **02-KG (Chunk 3:651-664)**
  > OWL supports sub-classes, and many additional features, for defining and making claims about classes...OWL allows for defining that they are equivalent, or disjoint

---

### 138. Property Restriction Class

Property restrictions define entity types by their relationships. 'Some value from' (existential), 'all values from' (universal), 'has value' (specific value), cardinality restrictions constrain entity membership based on their relational patterns.

**Sources**:

- **02-KG (Chunk 3:665-675)**
  > by placing restrictions on a particular property p, one can define classes whose instances are all of the entities that have: some value from a given class on p; all values from a given class on p

---

### 139. Rule as Inference Pattern

Rules define entity inference patterns: if body pattern matches, head pattern is entailed. Rules enable deriving new entity relationships from existing ones. This corresponds to Datalog/Horn clauses and enables automated reasoning about entities.

**Sources**:

- **02-KG (Chunk 4:21-35)**
  > A rule is composed of a body (if) and a head (then). Both the body and head are given as graph patterns. A rule indicates that if we can replace the variables of the body with terms from the data graph...will yield a valid entailment

---

### 140. Description Logic Terminology

Description Logics formalize three core element types: Individuals (entity instances), Classes/Concepts (entity types), and Properties/Roles (relations). This tripartite structure grounds the fundamental entity ontology in formal logic.

**Sources**:

- **02-KG (Chunk 4:149-155)**
  > Description Logics are based on three types of elements: individuals, such as Santiago; classes (aka concepts) such as City; and properties (aka roles) such as flight

---

### 141. A-Box Assertional Axioms

A-Box contains facts about individual entities: type assertions (entity-is-a-class) and relation assertions (entity-relates-to-entity). This separates entity instance data from schema definitions (T-Box).

**Sources**:

- **02-KG (Chunk 4:152-156)**
  > Assertional axioms can be either unary class relations on individuals, such as City(Santiago), or binary property relations on individuals, such as flight(Santiago,Arica). Such axioms form the Assertional Box (A-Box)

---

### 142. T-Box Class Axioms

T-Box contains entity type definitions: class hierarchies, equivalences, and constraints. R-Box contains relation (property/role) definitions. This separation of concerns enables modular entity schema design.

**Sources**:

- **02-KG (Chunk 4:157-162)**
  > DLs further introduce logical symbols to allow for defining class axioms (forming the Terminology Box, or T-Box for short), and property axioms (forming the Role Box, R-Box)

---

### 143. Constructed Class Definition

Classes can be constructed using logical operators: existential quantification (exists_p.C = entities with some p-value in C), universal quantification, and connectives. This enables defining entity types by their relational properties.

**Sources**:

- **02-KG (Chunk 4:166-171)**
  > we can define a class exists_nearby.Airport as the class of individuals that have some airport nearby. Noting that the symbol T is used in DLs to denote the class of all individuals

---

### 144. Graph Embedding as Entity Representation

Entity embeddings are dense vector representations learned from graph structure. Each entity gets a fixed-dimensional vector capturing latent features. This numeric representation enables machine learning over entities while preserving relational structure.

**Sources**:

- **02-KG (Chunk 4:795-803)**
  > Typically the graph embedding is composed of an entity embedding for each node: a vector with d dimensions that we denote by e; and a relation embedding for each edge label

---

### 145. Plausibility Score for Entity Relations

Scoring functions evaluate plausibility of entity-relation-entity triples using embeddings. Higher scores indicate more likely relations. This probabilistic view of entity relations enables link prediction and confidence scoring.

**Sources**:

- **02-KG (Chunk 4:807-811)**
  > given an edge s p o, a specific embedding approach defines a scoring function that accepts es...rp...and eo...and computes the plausibility of the edge: how likely it is to be true

---

### 146. Entity Embedding as Vector Representation

Entity definition through vector representation. In translational embedding models like TransE, entities are defined as vectors in a learned embedding space where edge labels represent transformations. Subject nodes are sources/heads, object nodes are targets/tails. This provides a formal mathematical definition of entities as dense numeric representations.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:7-24)**
  > Translational models interpret edge labels as transformations from subject nodes (aka the source or head) to object nodes (aka the target or tail)

---

### 147. Tensor as Entity Container

Formal definition of tensors as containers for entity representations. Tensors generalize the concept of numeric data structures from scalars through vectors to matrices and beyond. In knowledge graphs, 3-order tensors can encode entity-relation-entity triples, providing a formal mathematical structure for entity representation.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:63-79)**
  > A tensor is a multidimensional numeric field that generalises scalars (0-order tensors), vectors (1-order tensors) and matrices (2-order tensors)

---

### 148. Graph as One-Hot Tensor Encoding

Formal definition of how entities in a knowledge graph can be encoded as tensor elements. Each entity position in the tensor is defined by its index, with binary values indicating relationship presence. This provides a mathematical foundation for entity representation in tensor decomposition approaches.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:178-184)**
  > a graph can be encoded as a one-hot 3-order tensor G with |V| x |L| x |V| elements, where the element (G)ijk is set to one if the ith node links to the kth node

---

### 149. Entity vs Relation Embeddings in DistMult

Distinction between entity embeddings and relation embeddings. DistMult defines entities and relations as separate vector types of the same dimensionality, with a plausibility scoring function that combines them. This formal separation establishes entities as first-class objects distinct from the relations connecting them.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:194-205)**
  > DistMult is a seminal method for computing knowledge graph embeddings based on rank decompositions, where each entity and relation is associated with a vector of dimension d

---

### 150. Feature Vector Definition for Nodes

In Graph Neural Networks, entities (nodes) are formally defined by two vector types: feature vectors (fixed input characteristics) and state vectors (dynamically updated representations). This dual-vector definition captures both intrinsic entity properties and learned contextual representations.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:465-474)**
  > Each node in the graph is also associated with a state vector, which is recursively updated based on information from the node's neighbours

---

### 151. Node Feature vs State Vector Distinction

Formal distinction between fixed feature vectors defining entity attributes and dynamic state vectors encoding learned representations. Feature vectors capture labels and weights while state vectors evolve through neighborhood aggregation, providing a formal separation of static vs dynamic entity definitions.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:468-476)**
  > feature vectors that can capture node and edge labels, weights, etc. These feature vectors remain fixed throughout the process

---

### 152. Transition and Output Functions for Entities

Entities in GNNs are formally processed through transition functions (updating state based on neighbors) and output functions (computing final entity representations). These parametric functions define how entities are transformed and characterized within the neural network architecture.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:476-486)**
  > using a parametric function, called the transition function. A second parametric function, called the output function, is used to compute the final output for a node

---

### 153. Supervised Nodes as Labeled Entities

Definition of supervised nodes as entities with known output labels used for training. This distinguishes between labeled entities (with ground truth) and unlabeled entities (to be classified), establishing a formal entity categorization based on annotation status.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:482-486)**
  > given a partial set of supervised nodes in the graph - i.e., nodes labelled with their desired output - parameters for the transition and output functions can be learnt

---

### 154. Symbolic Learning Hypothesis Definition

Entities in symbolic learning are defined through logical hypotheses that explain their relationships. Positive and negative edges define entity connections, with learned rules providing interpretable models of entity behavior. This contrasts with numeric embedding definitions.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:667-674)**
  > adopt symbolic learning in order to learn hypotheses in a symbolic (logical) language that explain a given set of positive and negative edges

---

### 155. Rule-Based Entity Characterization

Entities can be characterized through learned rules capturing their behavioral patterns. Rules define entity relationships (e.g., symmetric flight connections) providing interpretable, quantified definitions that apply to unseen entity instances.

**Sources**:

- **02-Knowledge_Graphs (Chunk 5:676-689)**
  > we may learn the rule [?x] flight ?y => [?y] flight ?x from observing that flight routes tend to be return routes

---

### 156. Disjointness Axiom Entity Classification

Formal definition of entity classification through disjointness axioms. Entities are defined by which classes they cannot simultaneously belong to. The disjointness constraint provides a formal logical definition stating that entity types are mutually exclusive.

**Sources**:

- **02-Knowledge_Graphs (Chunk 6:19-25)**
  > the disjointness axiom DomesticAirport intersection InternationalAirport = bottom states that the intersection of the two classes is equivalent to the empty class

---

### 157. Class Learning Entity Definition

Entities are defined through learned class descriptions that separate positive from negative examples. Class learning algorithms discover logical descriptions (using DL syntax) that formally characterize entity types based on their distinguishing properties.

**Sources**:

- **02-Knowledge_Graphs (Chunk 6:59-69)**
  > DL Learner is based on algorithms for class learning (aka concept learning), whereby given a set of positive nodes and negative nodes, the goal is to find a logical class description

---

### 158. Named Entity Recognition Definition

Named entities are formally defined as mentions in text belonging to predefined categories: people, organizations, locations, etc. NER provides the operational definition for extracting entity instances from unstructured sources.

**Sources**:

- **02-Knowledge_Graphs (Chunk 6:205-215)**
  > The NER task identifies mentions of named entities in a text, typically targetting mentions of people, organisations, locations, and potentially other types

---

### 159. Entity Linking Target Definition

Entity linking formally defines the mapping between textual entity mentions and existing graph nodes. Entities are characterized by their aliases, multilingual labels, and disambiguation context, establishing a formal correspondence between surface forms and canonical entity representations.

**Sources**:

- **02-Knowledge_Graphs (Chunk 6:233-248)**
  > The EL task associates mentions of entities in a text with the existing nodes of a target knowledge graph

---

### 160. N-ary Relation Entity Representation

Complex entity relationships are defined through n-ary relations using anonymous nodes. When binary relations are insufficient, anonymous nodes formally represent the higher-arity relationship context, extending entity definition to capture temporal and other contextual attributes.

**Sources**:

- **02-Knowledge_Graphs (Chunk 6:298-306)**
  > an n-ary relation captures additional temporal context, denoting when Rapa Nui was named a World Heritage site; in this case, an anonymous node is created

---

### 161. Frame Semantics Entity Role Definition

Entities are defined through their roles in semantic frames. FrameNet provides formal definitions of entity participation (speaker, entity, name) with optional elements (explanation, purpose, place, time) establishing a structured vocabulary for entity role characterization.

**Sources**:

- **02-Knowledge_Graphs (Chunk 6:306-315)**
  > frame semantics, which, for a given verb (e.g., named), captures the entities involved and how they may be interrelated. Resources such as FrameNet then define frames

---

### 162. Direct Mapping Entity Generation

Entities in knowledge graphs can be formally generated through direct mapping from tabular data. Each row becomes an entity node, columns become edge labels, and cells become connected values, providing a systematic definition of entity generation from structured sources.

**Sources**:

- **02-Knowledge_Graphs (Chunk 6:597-604)**
  > A direct mapping automatically generates a graph from a table. creates an edge [x] y z for each (non-header, non-empty, non-null) cell of the table

---

### 163. Accuracy as Entity Correctness

Entity quality is formally defined through accuracy: the degree to which graph nodes correctly represent real-world entities. This establishes a formal quality dimension for evaluating entity definitions against ground truth.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:20-24)**
  > Accuracy refers to the extent to which entities and relations - encoded by nodes and edges in the graph - correctly represent real-life phenomena

---

### 164. Semantic Accuracy Entity Definition

Entity semantic accuracy formally measures how well entity attributes reflect actual real-world states. This distinguishes between syntactically valid entity representations and semantically correct ones that faithfully capture reality.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:50-57)**
  > Semantic accuracy is the degree to which data values correctly represent real world phenomena, which may be affected by imprecise extraction results

---

### 165. Entity Completeness Definition

Entity completeness is formally defined across three dimensions: schema completeness (class/property coverage), property completeness (attribute value coverage), and population completeness (real-world entity coverage). This multi-dimensional definition establishes formal metrics for entity representation quality.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:97-108)**
  > Completeness refers to the degree to which all required information is present in a particular dataset. Completeness comprises: schema completeness, property completeness, population completeness

---

### 166. Ideal Knowledge Graph Entity Reference

The ideal knowledge graph provides a formal reference definition for entity completeness. Entities are measured against what an ideal representation would contain, establishing completeness as deviation from this theoretical maximum.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:110-116)**
  > Measuring completeness directly is non-trivial as it requires knowledge of a hypothetical ideal knowledge graph that contains all the elements

---

### 167. Consistency as Entity Coherence

Entity consistency is formally defined as freedom from logical contradictions. Entities must satisfy all applicable logical constraints without generating inconsistencies, providing a formal coherence criterion for entity definitions.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:168-176)**
  > Consistency means that a knowledge graph is free of (logical/formal) contradictions with respect to the particular logical entailment considered

---

### 168. Validity as Constraint Satisfaction

Entity validity is formally defined as satisfaction of shape constraints. Unlike consistency (logical coherence), validity ensures entities conform to explicitly stated structural requirements (cardinality, type constraints, etc.).

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:179-191)**
  > Validity means that the knowledge graph is free of constraint violations, such as captured by shape expressions

---

### 169. Conciseness as Entity Relevance

Entity conciseness formally distinguishes between schema-level relevance (intensional) and instance-level relevance (extensional). Entities should only include domain-relevant attributes and instances, avoiding information overload.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:202-218)**
  > Conciseness refers to avoiding the inclusion of schema and data elements that are irrelevant to the domain. distinguish intensional conciseness (schema level) and extensional conciseness (data level)

---

### 170. Understandability as Entity Interpretability

Entity understandability formally requires human-readable labels and descriptions, preferably multilingual, to enable unambiguous interpretation. This defines entities not just by their structural properties but by their interpretability.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:243-259)**
  > Understandability refers to the ease with which data can be interpreted without ambiguity by human users, which involves the provision of human-readable labels and descriptions

---

### 171. Missing Link Entity Definition

Missing links formally define gaps in entity relationships - connections that should exist but are neither stated nor inferable. This establishes a formal notion of entity relationship incompleteness.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:295-309)**
  > knowledge graph completion aims at filling in the missing edges (aka missing links) of a knowledge graph, i.e., edges that are deemed correct but are neither given nor entailed

---

### 172. Type Link Entity Classification

Type links formally define entity classification through edges with label 'type'. These links have special semantics distinguishing them from general relationships, enabling dedicated classification techniques for entity type prediction.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:337-355)**
  > Type links are of particular importance to a knowledge graph, where dedicated techniques can be leveraged taking into account the specific semantics of such links

---

### 173. Identity Link Entity Equivalence

Identity links formally define entity equivalence through 'same as' relationships. Entity matching uses value matchers (comparing attribute similarity) and context matchers (comparing neighborhood similarity) to establish that distinct nodes refer to the same real-world entity.

**Sources**:

- **02-Knowledge_Graphs (Chunk 7:358-379)**
  > Predicting identity links involves searching for nodes that refer to the same entity; this is analogous to the task of entity matching (aka record linkage, deduplication)

---

### 174. Node Lookup Entity Description

Entity definition through node lookup protocols. An entity is formally described by the sub-graph of all its incident edges (outgoing and/or incoming), establishing a graph-centric definition where entities are characterized by their relationship neighborhood.

**Sources**:

- **02-Knowledge_Graphs (Chunk 8:27-40)**
  > Protocols for performing node lookups accept a node (id) request and return a (sub-)graph describing that node. a common convention is to return a sub-graph containing either all outgoing edges

---

### 175. Edge Pattern Entity Definition

Entities can be formally defined and queried through edge patterns. Triple patterns ([subject] predicate object) provide atomic units for entity characterization, where any term can be variable or constant to match entity instances.

**Sources**:

- **02-Knowledge_Graphs (Chunk 8:65-78)**
  > Edge patterns - also known as triple patterns in the case of directed, edge labelled graphs - are singleton graph patterns, i.e., graph patterns with a single edge

---

### 176. Licensing Entity Metadata

Entity usage is formally defined through licensing metadata using ODRL. Entities carry permissions, duties, and prohibitions that formally constrain how they can be accessed, modified, and distributed, extending entity definition to include usage rights.

**Sources**:

- **02-Knowledge_Graphs (Chunk 8:186-198)**
  > W3C Open Digital Rights Language (ODRL) provides an information model and related vocabularies that can be used to specify permissions, duties, and prohibitions

---

### 177. Usage Policy Entity Constraints

Entities are formally constrained by usage policies specifying permitted processing operations, authorized actors, and legitimate purposes. This extends entity definition to include behavioral constraints on entity access and manipulation.

**Sources**:

- **02-Knowledge_Graphs (Chunk 8:257-269)**
  > usage policies specify how data can be used: what kinds of processing can be applied, by whom, for what purpose

---

### 178. Encrypted Entity Representation

Entities can be formally defined with encrypted attributes, where different clients have access to different entity information based on encryption keys. This establishes a formal security dimension to entity definition.

**Sources**:

- **02-Knowledge_Graphs (Chunk 8:278-290)**
  > more fine-grained encryption can be performed for individual nodes or edge-labels in a graph, potentially providing different clients access to different information

---

### 179. K-Anonymity Entity Privacy

Entity privacy is formally defined through k-anonymity: entities must be indistinguishable from at least k-1 other entities to prevent identification. Quasi-identifiers are formally identified and suppressed to achieve this anonymization level.

**Sources**:

- **02-Knowledge_Graphs (Chunk 8:322-334)**
  > Approaches to apply k-anonymity on graphs identify and suppress quasi-identifiers that would allow a given individual to be distinguished from fewer than k-1 other individuals

---

### 180. Knowledge Graph as Entity-Relation Structure

Formal definition of knowledge graph entities: nodes represent entities of interest from the real world, while edges represent relations between these entities. This establishes the foundational definition of entities as real-world referents encoded as graph nodes.

**Sources**:

- **02-Knowledge_Graphs (Chunk 12:855-860)**
  > a knowledge graph as a graph of data intended to accumulate and convey knowledge of the real world, whose nodes represent entities of interest and whose edges represent relations

---

### 181. Category I Entity Definition

Category I entity definition: entities are simply nodes in a directed edge-labelled graph with relationships as edges. This minimalist definition focuses on structural aspects without requiring additional semantic machinery.

**Sources**:

- **02-Knowledge_Graphs (Chunk 13:127-140)**
  > simply defines the knowledge graph as a graph where nodes represent entities, and edges represent relationships between those entities. Often a directed edge labelled graph is assumed

---

### 182. Category II Knowledge Base Entity

Category II entity definition ties entities to knowledge base concepts from expert systems and ontology traditions. Entities inherit formal semantics from logical formalisms, distinguishing them from simple graph nodes.

**Sources**:

- **02-Knowledge_Graphs (Chunk 13:144-164)**
  > a knowledge graph is a graph-structured knowledge base, where the phrase knowledge base was popularised in the 70's in the context of rule-based expert systems

---

### 183. Category III Technical Entity Criteria

Category III formally defines entities through four criteria: (1) represent real-world entities in a graph, (2) have defined classes and relations in schema, (3) allow arbitrary entity interrelation, (4) cover multiple domains. This establishes rigorous entity characterization requirements.

**Sources**:

- **02-Knowledge_Graphs (Chunk 13:170-192)**
  > a knowledge graph mainly describes real world entities and their interrelations, organized in a graph; defines possible classes and relations of entities in a schema

---

### 184. Intensional Component Entity Definition

Formal entity definition through three components: ground extensional (explicit entity facts), intensional (inference rules over entities), and derived extensional (inferred entity facts). This establishes entities as participating in both stated and derived knowledge.

**Sources**:

- **02-Knowledge_Graphs (Chunk 13:213-226)**
  > a ground extensional component, that is, a set of relational constructs for schema and data; an intensional component, that is, a set of inference rules; a derived extensional component

---

### 185. Formal Graph Definition of Entity

Formal mathematical definition of entities as elements of set V in directed edge-labelled graph. Entities are nodes belonging to a defined set, with edges E connecting pairs of entities through labeled relations L.

**Sources**:

- **02-Knowledge_Graphs (Chunk 13:319-326)**
  > A directed edge-labelled graph is a tuple G = (V, E, L), where V is a set of nodes, L is a set of edge labels, and E subset of V x L x V is a set of edges

---

### 186. Heterogeneous Graph Entity with Type

Formal definition of typed entities in heterogeneous graphs. Each entity (node) is mapped to a type label through function l, establishing formal entity classification. Types are distinguished from relationship labels.

**Sources**:

- **02-Knowledge_Graphs (Chunk 13:352-360)**
  > A heterogeneous graph is a tuple G = (V, E, L, l), where l: V -> L maps each node to a label. In heterogeneous graphs, edge and node labels are most commonly called types

---

### 187. Property Graph Entity with Attributes

Formal definition of attributed entities in property graphs. Entities (V) have unique identifiers, labels (l), and property-value pairs (p), extending basic node definition to include rich attribute structures.

**Sources**:

- **02-Knowledge_Graphs (Chunk 13:375-385)**
  > A property graph is a tuple G = (V, E, L, P, U, e, l, p), where p: V union E -> 2^(P x U) maps a node or edge id to a set of property-value pairs

---

### 188. Valid Graph Definition

Formal definition of a valid graph as one where there exists a shapes map such that for all shapes and vertices, the shapes map evaluates correctly and target constraints are satisfied. This defines the entity 'valid graph' in terms of satisfaction conditions.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:5-7)**
  > Given a shapes schema, a graph G = (V, E, L), and a shapes target T, we say that G is valid under Sigma and T if and only if...

---

### 189. Quotient Graph Definition

Defines quotient graph as a structural abstraction where multiple nodes can be merged into one node while preserving edge relationships. Critical for understanding graph abstraction and schema derivation.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:45-52)**
  > a graph G = (V, E, L) is a quotient graph of G if and only if: V is a partition of V without the empty set...

---

### 190. Simulation Relation Definition

Defines simulation as a relation between graphs where one graph can mimic the edge structure of another. Fundamental for graph comparison and behavioral equivalence.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:77-85)**
  > let R be a relation between the nodes of G and G'. We call R a simulation on G and G' if, for all (v, v') in R...

---

### 191. Bisimulation Definition

Defines bisimulation as a symmetric simulation relation where both graphs can mutually mimic each other's structure. Establishes equivalence class for graphs.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:88-92)**
  > If R is a simulation on G and G', we call it a bisimulation if, for all (v, v') in R, the following condition holds...

---

### 192. Annotation Domain Definition

Formal definition of annotation domain as an algebraic structure for attaching contextual information to graph elements. Enables reasoning over annotated graphs.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:116-118)**
  > Let A be a set of annotation values. An annotation domain is defined as an idempotent, commutative semi-ring D = (A, +, *, bottom, top)

---

### 193. Graph Interpretation Definition

Defines graph interpretation as a mapping from constants to terms in a domain graph, enabling semantic reasoning over graph structures.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:193-196)**
  > A (graph) interpretation I is defined as a pair I := (Gamma, *I) where Gamma = (V, E, L) is a graph called the domain graph...

---

### 194. Graph Model Definition

Formal definition of when an interpretation satisfies (is a model of) a graph, establishing the semantic foundation for graph entailment.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:206-217)**
  > An interpretation I satisfies G if and only if the following hold: V union L is subset of domain; for all v in V, v^I is in V_Gamma...

---

### 195. Rule Definition for Graphs

Defines rule as a body-head pair of graph patterns where head variables must appear in body. Foundational for deductive reasoning over graphs.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:274-276)**
  > A rule is a pair R = (B, H) such that B and H are graph patterns and Var(H) subset of B. We call B the body and H the head.

---

### 196. DL Knowledge Base Definition

Defines Description Logic knowledge base as tripartite structure with assertions, terminological axioms, and role axioms. Core structure for ontological knowledge representation.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:342-344)**
  > A DL knowledge base K is defined as a tuple (A, T, R), where A is the A-Box: assertional axioms; T is the T-Box: class axioms; R is the R-Box: relation axioms

---

### 197. DL Interpretation Definition

Formal definition of DL interpretation with domain of individuals and interpretation function mapping individuals, classes, and relations to their semantic counterparts.

**Sources**:

- **02-Knowledge_Graphs (Chunk 14:354-360)**
  > A DL interpretation I is defined as a pair (Delta^I, *^I), where Delta^I is the interpretation domain, and *^I is the interpretation function...

---

### 198. Knowledge Graph Embedding Definition

Defines knowledge graph embedding as pair of mappings from nodes and edge labels to tensors. Enables numeric representation of graph structure for machine learning.

**Sources**:

- **02-Knowledge_Graphs (Chunk 15:785-786)**
  > Given a directed edge-labelled graph G = (V, E, L), a knowledge graph embedding of G is a pair of mappings (epsilon, rho) such that epsilon: V -> T and rho: L -> T

---

### 199. Plausibility Scoring Function Definition

Defines plausibility as a function scoring the likelihood of edges based on embeddings. Core mechanism for link prediction in knowledge graphs.

**Sources**:

- **02-Knowledge_Graphs (Chunk 15:796-798)**
  > A plausibility scoring function is a partial function phi: T x T x T -> R. Given a graph and an edge (s, p, o), the plausibility is given as phi(epsilon(s), rho(p), epsilon(o))

---

### 200. Recursive Graph Neural Network Definition

Defines RecGNN as aggregation and output function pair that iteratively computes node feature vectors until fixpoint. Foundational for graph-based learning.

**Sources**:

- **02-Knowledge_Graphs (Chunk 15:388-396)**
  > A recursive graph neural network (RecGNN) is a pair of functions (Agg, Out), such that Agg: R^a x multiset -> R^a and Out: R^a -> R^c

---

### 201. Non-recursive Graph Neural Network Definition

Defines NRecGNN as sequence of layer-specific aggregation functions applied for fixed number of steps. Basis for modern GNN architectures like GCN and GAT.

**Sources**:

- **02-Knowledge_Graphs (Chunk 15:478-481)**
  > A non-recursive graph neural network (NRecGNN) with l layers is an l-tuple of functions (Agg^1, ..., Agg^l)...

---

### 202. Hypothesis Induction Definition

Formal definition of hypothesis induction as finding axioms that explain positive examples without entailing negative ones. Foundation for rule and axiom mining.

**Sources**:

- **02-Knowledge_Graphs (Chunk 15:537-564)**
  > The task of hypothesis induction assumes a graph entailment relation. Given background knowledge G, positive edges E+, negative edges E-, find hypotheses Psi such that...

---

### 203. Hypothesis Support and Confidence Definition

Defines scoring metrics for hypothesis quality in terms of edges explained (support) and precision (confidence). Essential for evaluating mined rules.

**Sources**:

- **02-Knowledge_Graphs (Chunk 15:598-615)**
  > Given a knowledge graph G and a hypothesis psi, the positive support is defined as the count of edges entailed by adding psi. The confidence is the ratio of positive to total support.

---

### 204. AI Agent Definition in Agentic Workflows

Defines AI Agent as an autonomous entity powered by foundation models that plans, interacts, and makes decisions in dynamic workflows. Extends traditional agent concept with LLM capabilities.

**Sources**:

- **03-PROV-AGENT (Chunk 1:17-24)**
  > Large Language Models (LLMs) and other foundation models are increasingly used as the core of AI agents. In agentic workflows, these agents plan tasks, interact with humans and peers...

---

### 205. Agentic Workflow Definition

Defines agentic workflow as a workflow paradigm where AI agents autonomously make decisions, plan, and coordinate across distributed computing environments.

**Sources**:

- **03-PROV-AGENT (Chunk 1:51-54)**
  > agentic workflows, where autonomous agents make decisions, plan tasks, and coordinate with humans and other agents. These agents operate in dynamic environments across heterogeneous computing platforms

---

### 206. PROV-AGENT Entity Definitions

Identifies the three core PROV entities: Agent (responsible actor), Entity (data), and Activity (process). Forms the foundational triad for provenance modeling.

**Sources**:

- **03-PROV-AGENT (Chunk 1:200-204)**
  > W3C PROV standard already defines Agent, the central abstraction in this work, as one of its three core classes, alongside Entity (data) and Activity (process)

---

### 207. AIAgent as PROV Agent Subclass

Defines AIAgent as a specialization of PROV Agent specifically for AI/LLM-based autonomous agents, enabling provenance tracking of AI decisions.

**Sources**:

- **03-PROV-AGENT (Chunk 1:278-284)**
  > We extend the abstract W3C PROV Agent by modeling AIAgent as its subclass, enabling a natural integration of agent actions and interactions into the broader workflow provenance graph

---

### 208. AgentTool Definition

Defines AgentTool as an activity representing the execution of an agent's tool, which may depend on multiple AI model invocations.

**Sources**:

- **03-PROV-AGENT (Chunk 1:285-288)**
  > Following the MCP terminology, an AI agent can be associated with one or many tool executions (AgentTool) and each tool may be informed by one or many AIModelInvocations

---

### 209. AIModelInvocation Definition

Defines AIModelInvocation as an activity capturing a single call to an AI model, with input prompt and output response, attributed to an agent.

**Sources**:

- **03-PROV-AGENT (Chunk 1:287-292)**
  > Each AIModelInvocation uses a Prompt and a specific AIModel, which holds model metadata, including its name, type, provider, temperature, and generates a ResponseData object

---

### 210. DataObject Entity Hierarchy

Defines DataObject as a PROV Entity superclass with subclasses for domain data, scheduling metadata, and telemetry metrics that agents can use or produce.

**Sources**:

- **03-PROV-AGENT (Chunk 1:297-303)**
  > The data used or generated by agents, including prompts, responses, are represented as subclasses of the DataObject Entity. This allows agents to consume and produce DomainData, SchedulingData, TelemetryData

---

### 211. PROV Entity Definition with BFO Mapping

Formal definition of PROV Entity as anything with fixed aspects that persists identity over time, mapped to BFO continuant excluding spatial regions.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 1:633-645)**
  > PROV Entity is defined as 'a physical, digital, conceptual, or other kind of thing with some fixed aspects; entities may be real or imaginary'. We map PROV Entity as a subclass of BFO continuant

---

### 212. PROV Agent Definition with BFO Mapping

Defines PROV Agent as a material entity with matter that persists in time, bearing responsibility through role realization in activities.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 1:654-662)**
  > PROV Agent is mapped as a subclass of BFO material entities that both participate in some PROV Activity and bear some BFO role that is realized in a PROV Activity

---

### 213. PROV Activity Equivalence to BFO Process

Establishes equivalence between PROV Activity and BFO process as temporal occurrences that unfold over time and involve entities.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 1:682-691)**
  > PROV Activity is mapped as equivalent to the class BFO process. The definition includes 'something that occurs over a period of time and acts upon or with entities'

---

### 214. PROV Location Equivalence to BFO Site

Defines PROV Location as a spatial entity equivalent to BFO site, including non-geographic places like directories or table rows.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 1:808-816)**
  > PROV Location is mapped as equivalent to BFO site, which is defined as 'a three-dimensional immaterial entity whose boundaries either coincide with material entities or have locations determined in relation to some material entity'

---

### 215. PROV Bundle Definition

Defines PROV Bundle as a container for provenance metadata, represented as information content entity that generically depends on some bearer.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 1:798-801)**
  > PROV Bundle is defined as 'a named set of provenance descriptions' that 'constitute islands of provenance information'. Mapped as subclass of CCO Information Content Entity

---

### 216. PROV Role Definition vs BFO Role

Defines PROV Role as an externally determined function in activity context, mapped to BFO role rather than BFO function due to its relational nature.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 2:103-113)**
  > PROV Role is defined as 'the function of an entity or agent with respect to an activity'. BFO distinguishes between roles and functions. A BFO role could be completely externally determined and can be gained or lost

---

### 217. PROV Plan Definition vs CCO Plan

Defines PROV Plan as a generically dependent continuant representing intended actions, broader than CCO Plan which requires intentional acts.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 2:116-143)**
  > PROV Plan 'represents a set of actions or steps intended by one or more agents to achieve some goals'. Mapped to CCO Information Content Entity, not CCO Plan, since PROV Plan is not limited to intentional acts

---

### 218. PROV Influence Definition

Defines PROV Influence as the capacity for one element to affect another through various provenance relationships. Mapped to BFO process or process boundary.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 2:32-34)**
  > Influence is the capacity of an entity, activity, or agent to have an effect on the character, development, or behavior of another by means of usage, start, end, generation...

---

### 219. PROV InstantaneousEvent to BFO Process Boundary

Defines PROV InstantaneousEvent as temporal boundaries that exist at an instant, mapped to BFO process boundary as occurrents without temporal extension.

**Sources**:

- **04-PROV-O_to_BFO (Chunk 2:17-25)**
  > PROV InstantaneousEvent is equivalently mapped to BFO process boundary since instances are indivisible boundaries of some PROV Activity that is equivalent to a BFO process

---

### 220. Endurant (Continuant) Definition

Formal definition of endurant as an entity wholly present at any time it exists, contrasted with perdurants that unfold over time. Examples: table, person, cat, planet.

**Sources**:

- **05-DOLCE (Chunk 1:128-133)**
  > endurants are wholly present (i.e., with all their parts) at any time in which they are present; differently, perdurants can be partially present, so that at any time in which they unfold only a part of them is present

---

### 221. Perdurant (Occurrent) Definition

Formal definition of perdurant as an entity that exists by having temporal parts, where only a portion is present at any given time.

**Sources**:

- **05-DOLCE (Chunk 1:129-133)**
  > perdurants can be partially present, so that at any time in which they unfold only a part of them is present. Examples of perdurants are a tennis match, a conference talk or a manufacturing process

---

### 222. Quality Definition in DOLCE

Defines quality as a perceivable/measurable particular that inheres in a bearer, with each quality being specific to its bearer (individual qualities).

**Sources**:

- **05-DOLCE (Chunk 1:166-181)**
  > Qualities are, roughly speaking, what can be perceived and measured; they are particulars inhering in endurants or perdurants. When we talk about the red of a rose, we are talking about a particular quality

---

### 223. Quale Definition in DOLCE

Defines quale as the position of an individual quality within a quality space, enabling comparison of qualities across different bearers.

**Sources**:

- **05-DOLCE (Chunk 1:177-181)**
  > A quale is the position occupied by an individual quality within a quality space. If the rose and book cover exhibit the same shade of red, their individual colors occupy the same position (quale)

---

### 224. Participation Relation Definition

Defines participation as the fundamental relation connecting endurants (continuants) to perdurants (occurrents), establishing temporal presence.

**Sources**:

- **05-DOLCE (Chunk 1:134-137)**
  > The relation connecting endurants and perdurants is called participation. An endurant can be in time by participating in a perdurant, and perdurants happen in time by having endurants as participants

---

### 225. Role Definition in DOLCE

Defines role as a concept with anti-rigidity (can be gained/lost) and foundation (dependent on external entities/contexts). Distinct from essential properties.

**Sources**:

- **05-DOLCE (Chunk 1:184-189)**
  > Roles are concepts that are anti-rigid and founded, meaning that (i) they have dynamic properties and (ii) they have a relational nature, i.e. they depend on other roles and on contexts

---

### 226. Constitution Relation Definition

Defines constitution as a relation between co-located entities with different essential properties, e.g., statue and its matter.

**Sources**:

- **05-DOLCE (Chunk 1:206-213)**
  > Constitution is a temporalized relation holding between either endurants or perdurants. Often used to single out entities that are spatio-temporally co-located but distinguishable for their histories, persistence conditions

---

### 227. Process vs Event Definition in DOLCE

Distinguishes processes (cumulative, non-homeomeric) from events (non-cumulative), with further distinction into achievements (atomic) and accomplishments.

**Sources**:

- **05-DOLCE (Chunk 1:156-163)**
  > a perdurant-type is stative or eventive according to whether it holds of the mereological sum of two instances, i.e. if it is cumulative or not. Processes are cumulative but not homeomeric

---

### 228. Concept and Classification Definition

Defines concept as an entity that classifies other entities at times, with classification being asymmetric and time-indexed. Roles are special concepts.

**Sources**:

- **05-DOLCE (Chunk 1:405-430)**
  > The classification relationship CF applies to an endurant, a concept and a time, requires the endurant to be present when classified, and is not symmetrical. Roles are defined as concepts that are anti-rigid and founded

---

### 229. Abstract Entity Definition in DOLCE

Defines abstract as an entity lacking spatiotemporal qualities, including mathematical and logical objects like sets and quality spaces.

**Sources**:

- **05-DOLCE (Chunk 1:216-218)**
  > abstracts are entities that have neither spatial nor temporal qualities and are not qualities themselves. Examples: quality regions, quality spaces, sets, and facts

---

### 230. Continuant Definition (BFO)

BFO defines continuants as entities that persist through time. This includes objects, qualities, and functions. The distinction between continuants (endurants) and occurrents (perdurants) is foundational to BFO's ontological framework.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:54-57)**
  > BFO adopts a view of reality as comprising (1) continuants, entities that continue or persist through time, such as objects, qualities, and functions...

---

### 231. Occurrent Definition (BFO)

Occurrents in BFO are events or happenings that have temporal extension. They are distinguished from continuants in that continuants persist through time while occurrents unfold in time as processes or events.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:54-57)**
  > ...and (2) occurrents, the events or happenings in which continuants participate.

---

### 232. Independent Continuant Definition

BFO divides continuants into independent and dependent categories. Independent continuants are the objects we encounter in everyday experience and serve as bearers of dependent continuants.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:175-177)**
  > In BFO, all entities are divided into continuants and occurrents. Continuants can be either independent or dependent.

---

### 233. Dependent Continuant via Inherence

Dependent continuants (qualities, roles, dispositions, functions) exist only by inhering in independent continuants. The inherence relation is specifically dependent, meaning a quality cannot migrate from one bearer to another.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:187-192)**
  > Dependent continuants are related to their bearers by inherence. Inherence is defined as a one-sided, existential dependence relation.

---

### 234. Realizable Entity Definition

Realizable entities are a subtype of dependent continuants that can be manifested in processes. Functions, roles, dispositions, and capabilities are all realizable entities that require processes for their actualization.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:241-243)**
  > A realizable entity is defined as a specifically dependent continuant that has an independent continuant entity as its bearer, and whose instances can be realized in associated processes.

---

### 235. Role Definition (Externally-Grounded)

Roles are externally-grounded realizable entities. Unlike dispositions, roles depend on external circumstances rather than the bearer's physical makeup. Roles are optional and can be lost without physical change to the bearer.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:269-271)**
  > A role is a realizable entity which exists because the bearer is in some special physical, social, or institutional set of circumstances in which the bearer does not have to be...

---

### 236. Disposition Definition (Internally-Grounded)

Dispositions are internally-grounded realizable entities. They reflect the in-built physical makeup of the bearer. If a disposition ceases, the bearer is physically changed. Dispositions exist along a strength continuum from weaker forms to sure-fire dispositions.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:333-335)**
  > A disposition is a realizable entity which is such that, if it ceases to exist, then its bearer is physically changed, and whose realization occurs in virtue of the bearer's physical make-up.

---

### 237. Function Definition (via Evolution/Design)

Functions are dispositions whose bearer's physical makeup came into existence through evolution (biological functions) or intentional design (artifactual functions) to realize processes of a certain sort.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:385-388)**
  > A function is a disposition that exists in virtue of the bearer's physical make-up, and this physical make-up is something the bearer possesses because it came into being, either through evolution or through intentional design.

---

### 238. Artifactual Function Definition

Artifactual functions are functions of human-designed artifacts. The bearer's physical makeup was intentionally created to realize certain processes, such as a hammer's function to drive nails.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:434-436)**
  > An artifactual function is a function whose bearer's physical make-up has been designed and made intentionally (typically by one or more human beings) to function in a certain way.

---

### 239. Biological Function Definition

Biological functions are functions of organism parts that evolved to contribute to the organism's life plan. They are attributed to parts of organisms, not whole organisms - the whole organism has roles, not functions.

**Sources**:

- **06-BFO_Function_Role_Disposition (Chunk 1:449-451)**
  > A biological function is a function whose bearer is part of an organism, and exists and has the physical make-up it has because it has evolved that way and contributes to the organism's realization of a life plan.

---

### 240. Continuant vs Occurrent Temporal Distinction

BFO reconciles four-dimensionalist (occurrent) and three-dimensionalist (continuant) perspectives in a bicategorial framework. Continuants can have spatial parts but not temporal parts; occurrents can have both spatial and temporal parts.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 1:296-300)**
  > Four-dimensionalists see reality as consisting exclusively of four-dimensional entities (variously referred to as processes, events, occurrents, perdurants, spacetime-worms).

---

### 241. Thing Definition (Continuant/Endurant)

Continuants (things) can only be sliced spatially, not temporally. Your arms and legs are parts of you, but your childhood is not a part of you - it is part of your life (an occurrent).

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 1:351-354)**
  > The former [continuants], for Zemach, are defined by the fact that they can be sliced to yield parts only along the spatial dimension - for example those parts of your table which we call its legs, top, nails.

---

### 242. Event Definition (Occurrent/Perdurant)

Events (occurrents) exist in spatiotemporal regions and can be carved along any spatial and temporal dimensions. Multiple processes can occupy the same spatiotemporal region, unlike Zemach's events.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 1:376-381)**
  > An event is an entity that exists, in its entirety, in the area defined by its spatiotemporal boundaries, and each part of this area contains a part of the whole event.

---

### 243. Quality Definition (Dependent Continuant)

Qualities are dependent continuants that do not require a process of realization. Unlike realizable entities, qualities exist without needing to be manifested in processes.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 1:405-409)**
  > BFO generalizes Zemach's idea of a continuant entity by allowing not only things but also entities that are dependent on things, such as qualities and dispositions such as solubility and fragility.

---

### 244. Process Definition (Change in Continuants)

Processes are changes in independent continuant entities. Processes themselves cannot change - they ARE changes. When we 'speed up a process', we ensure a quicker process occurs than would have otherwise.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 1:689-692)**
  > Processes, in particular, cannot change on the four-dimensionalist view, because processes are changes (they are changes in those independent continuant entities which are their participants).

---

### 245. Temporal Part Definition

Temporal parts are occurrent parts that exactly restrict a larger occurrent to a proper temporal region. The first quarter of a football game is a temporal part of the whole game.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 1:577-583)**
  > a temporal_part_of b =Def. a occurrent_part_of b & for some temporal region r (a spans r & for all occurrents c, r' if (c spans r' & r' occurrent_part_of r) then (c occurrent_part_of a iff c occurrent_part_of b))

---

### 246. Determinable vs Determinate Quality Universals

Quality universals are divided into determinable (e.g., temperature) and determinate (e.g., 37.0C temperature). Determinable universals are rigid - if exemplified at any time, they are exemplified at all times the bearer exists.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 1:500-510)**
  > Qualities instantiate quality universals, which are divided into determinable (such as temperature, length and mass) and determinate (such as 37.0C temperature, 1.6 meter length).

---

### 247. Process Profile Definition

Process profiles are structural dimensions along which processes can be compared. They are what two processes share in common when they have the same rate, series of moves, or other comparable characteristics.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 2:119-126)**
  > When comparing two heart beating processes as being for example of the same rate, or when comparing two games of chess as consisting of the same series of moves, then there is something in each of the two processes which is qualitatively 'the same'. This something we call a process profile.

---

### 248. Quality Process Profile Definition

Quality process profiles are the simplest type of process profiles, focusing on a sequence of determinate qualities over time. They can be represented by graphs plotting quality measures against time.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 2:152-157)**
  > The simplest example of a process profile is that part of a process which serves as the target of selective abstraction focused on a sequence of instances of determinate qualities such as temperature or height.

---

### 249. Rate Process Profile Definition

Rate process profiles focus on ratios between magnitudes and time intervals, such as speed (distance per unit time). They form hierarchies including constant speed, acceleration, and variable acceleration profiles.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 2:174-179)**
  > Rate process profiles are the targets of selective abstraction focused not on determinate quality magnitudes plotted over successive instants of time, but rather on certain ratios between these magnitudes and associated intervals of elapsed time.

---

### 250. Cyclical Process Profile Definition

Cyclical process profiles are rate profiles where the ratio is cycles per unit time. They include regular cyclical profiles (like heartbeats at 60 bpm) and irregular cyclical profiles with diagnostic significance.

**Sources**:

- **07-Classifying_Processes_Barry_Smith (Chunk 2:238-243)**
  > Cyclical process profiles are a subtype of rate process profiles in which the salient ratio is not distance covered but rather number of cycles per unit of time.

---

### 251. Event Definition (OCEL)

Events in OCEL are discrete, atomic occurrences representing actions/activities in a process. Each event is unique, has a timestamp, may have attributes, and is typed. Events are instantaneous and do not take time.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:149-154)**
  > Events: Object-centric process mining works on discrete events. They represent the various actions or activities that occur within a system or process... Every event is unique and corresponds to a specific action at a specific point in time.

---

### 252. Event Type Definition (Activity)

Event types categorize events by their nature or function. Each event belongs to exactly one type. The term 'activity' is sometimes used interchangeably with event type.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:157-161)**
  > Event Types: Events are categorized into different types based on their nature or function. For example, a procurement process might have event types such as Order Created, Order Approved, or Invoice Sent.

---

### 253. Object Definition (OCEL)

Objects in OCEL are entities involved in events - either physical (products, machines, workers) or abstract/information entities (orders, invoices, contracts). Objects have typed attributes whose values may change over time.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:164-167)**
  > Objects: In object-centric process mining, objects represent the entities that are involved in events. These might be physical items like products in a supply chain, or abstract/information entities like orders, invoices, or contracts.

---

### 254. Object Type Definition

Merged from 2 sources. Entity is defined as a uniquely identifiable object in a knowledge graph, characterized by a unique ID and membership in an entity type (e.g., Country, Person). This provides the foundation for typed entity modeling.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:170-171)**
  > Object Types: Each object is of one type. The object is an instantiation of its type. Object types might include categories like Product, Order, Invoice, or Supplier.

- **16-KG-Agent (Chunk 1:182-183)**
  > Each entity e is assigned a unique entity ID (or string value), and belongs to one entity type t such as Country and Person

---

### 255. Event-to-Object (E2O) Relationship

E2O relationships link events to objects, describing how objects affect events or events affect objects. Unlike traditional logs, events can relate to multiple objects. Relationships can be qualified to describe the object's role.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:178-186)**
  > Event-to-Object (E2O) Relationships: Events are associated with objects. This relationship describes that an object affects an event or that an event affects an object. Events can be related to multiple objects.

---

### 256. Object-to-Object (O2O) Relationship

O2O relationships link objects to other objects independent of events. They can be qualified (e.g., part-of, reports-to, belongs-to) and exist outside specific event contexts.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:191-194)**
  > Object-to-Object (O2O) Relationships: Objects can also be related to other objects outside the context of an event. For example, an employee may be part of an organizational unit.

---

### 257. Dynamic Object Attribute Values

OCEL 2.0 supports dynamic object attributes that change over time due to events and process progression. This provides a more realistic view of process instances than static attributes.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:293-297)**
  > Dynamic Object Attribute Values: OCEL 2.0 adopts a dynamic approach where attribute values can change over time. Instead of having a single, fixed value, an object attribute may have a value that changes during the process.

---

### 258. Relationship Qualifiers

OCEL 2.0 supports qualifiers for both E2O and O2O relationships. E2O qualifiers describe the role an object plays in an event; O2O qualifiers characterize associations between objects.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:306-308)**
  > Relationship Qualifiers: OCEL 2.0 offers capabilities to express qualifiers for relationships, both for Object-to-Object (O2O) and Event-to-Object (E2O) relationships.

---

### 259. OCEL Formal Definition

Formal OCEL definition includes: events E, objects O, event/object attributes (EA/OA), type functions for events/objects, timestamp function, attribute value functions, and E2O/O2O relationships.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:395-396)**
  > An Object-Centric Event Log (OCEL) is a tuple L = (E, O, EA, OA, evtype, time, objtype, eatype, oatype, eaval, oaval, E2O, O2O)

---

### 260. Universe Definitions (OCEL Formal)

OCEL defines pairwise disjoint universes for events, event types, objects, object types, attribute names, attribute values, timestamps, and qualifiers. These form the foundation for formal OCEL definitions.

**Sources**:

- **09-OCEL_20_Specification (Chunk 1:346-373)**
  > Let U_ev be the universe of events, U_etype be the universe of event types, U_obj be the universe of objects, U_otype be the universe of object types...

---

### 261. Object-Centric Event Log Definition

Object-centric event logs resolve convergence and divergence problems by allowing events to relate to multiple objects of different types, rather than forcing mutually exclusive case groupings.

**Sources**:

- **10-OC-PM_Object-Centric_Process_Mining (Chunk 1:79-82)**
  > Object-centric event logs are a novel representation of the event data in the information systems, where each event is related to different objects of different types.

---

### 262. Case Definition (Traditional)

In traditional process mining, a case is a collection of events for a particular process execution. This leads to convergence (same event in different cases) and divergence (different instances of same activity) problems.

**Sources**:

- **10-OC-PM_Object-Centric_Process_Mining (Chunk 1:48-52)**
  > In such event logs, a case is a collection of events related to a particular process execution. For example, in a sales order management system, a case may refer to all the events related to the creation and confirmation of the order.

---

### 263. Convergence Problem Definition

Convergence occurs when the same event belongs to multiple cases, requiring event replication in traditional logs. This falsifies frequencies and introduces false behavioral information.

**Sources**:

- **10-OC-PM_Object-Centric_Process_Mining (Chunk 1:69-71)**
  > We have a convergence problem when the same event is related to different cases. In event log formats such as XES, this leads to replicating the same event.

---

### 264. Divergence Problem Definition

Divergence occurs when a case contains multiple instances of the same activity (e.g., multiple item pickings in an order), causing issues with process mining that assumes single activity instances per case.

**Sources**:

- **10-OC-PM_Object-Centric_Process_Mining (Chunk 1:72-74)**
  > We have a divergence problem when a case contains different instances of the same activity.

---

### 265. Lifecycle Definition (Object)

An object's lifecycle is the sequence of events the object is related to, obtained by flattening the object-centric event log on the object's type. This represents the complete history of an object.

**Sources**:

- **10-OC-PM_Object-Centric_Process_Mining (Chunk 1:609-612)**
  > The lifecycle of an object o in O as the sequence of events to which the object is related: lif(o) = case_FL(L,type(o))(o)

---

### 266. Trace Definition (Object)

An object's trace is the sequence of activities from events in its lifecycle. This provides the activity-level view of an object's progression through the process.

**Sources**:

- **10-OC-PM_Object-Centric_Process_Mining (Chunk 1:613-615)**
  > The trace of an object o in O as the sequence of activities of the events belonging to its lifecycle: trace(o) = trace_FL(L,type(o))(o)

---

### 267. Object-Centric Directly-Follows Multigraph Definition

OC-DFG is a process model with typed arcs representing directly-follows relationships per object type. It includes start/end nodes per object type and can be annotated with various frequency metrics.

**Sources**:

- **10-OC-PM_Object-Centric_Process_Mining (Chunk 1:764-786)**
  > An object-centric directly-follows multigraph (OC-DFG) is a tuple (A, OT, N, F, freq_n, freq_e) where A is a set of activities, OT is a set of object types, N includes activities plus start/end nodes per object type...

---

### 268. Flattening Operation Definition

Flattening projects an object-centric event log to a traditional event log by selecting one object type as case notion. It enables use of traditional process mining techniques on object-centric data.

**Sources**:

- **10-OC-PM_Object-Centric_Process_Mining (Chunk 1:555-559)**
  > A flattening operation transforms the object-centric event log into a traditional event log given the choice of an object type. This is useful because many process mining approaches are only available for traditional event logs.

---

### 269. Entity Definition (Multi-Dimensional)

Entities in event knowledge graphs include both objects handled by the process (Orders, Items, Invoices) and organizational entities that execute it (Actors, Machines). The process emerges from their interplay.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:31-34)**
  > The actual processes are rather complex and emerge from the interplay of multiple inter-related entities: the various objects handled by the process as well as the organizational entities that execute the process.

---

### 270. Event Table Definition

Event tables are the basic data structure with events as rows, attributes as columns. Each event must have activity and timestamp attributes. This is the foundation for event knowledge graph construction.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:201-206)**
  > An event table T = (E, Attr, #) is a set E of events, a set Attr of attribute names with act, time in Attr. Partial function # : E x Attr -> Val assigns an event e and an attribute name a to a value.

---

### 271. Event Table with Entity Types Definition

Event tables with entity types extend basic event tables by designating certain attributes as entity type identifiers. This enables multi-entity process mining without a single case identifier.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:218-220)**
  > An event table with entities types T = (E, Attr, #, ENT) additionally designates one or more attributes ENT as names of entity types.

---

### 272. Entities Definition (from Event Table)

Entities are extracted from event tables by collecting all unique values in entity type columns. Each value represents a specific entity of that type.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:252-254)**
  > Let ent be an entity type. The set of entities in T of type ent is Entities(ent, T) = {n | exists e in E : n in e.ent}.

---

### 273. Correlation Definition

Correlation links events to entities based on entity identifier attributes. An event can be correlated to multiple entities of different types, enabling multi-dimensional process analysis.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:265-269)**
  > Event e is correlated to entity n, written (e, n) in corr_ent,T iff n = e.ent or n in e.ent. We write corr(n, ent, T) = {e in E | (e, n) in corr_ent,T} for the set of events correlated to entity n.

---

### 274. Relation Between Entities Definition

Relations between entity types are implicitly defined when events contain identifiers of both types. These relations have cardinalities (1-to-1, n-to-1, n-to-m) that can be inferred from the data.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:300-302)**
  > Let ent1, ent2 be two entity types. The relation between ent1 and ent2 in T is R(ent1, ent2) = {(e.ent1, ent2) | e.ent1 != null, e.ent2 != null}.

---

### 275. Directly-Follows (per Entity) Definition

Local directly-follows relation is defined per entity, avoiding false behavioral information from global case-based ordering. Events follow each other only from the perspective of shared entities.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:519-529)**
  > Let e1, e2 in E be two events; e2 directly follows e1 from the perspective of n, written e1 <_n,T e2 iff (1) both are correlated to n, (2) e1 occurred before e2, (3) no other event correlated to n occurs in between.

---

### 276. Event Knowledge Graph Definition

Event knowledge graphs are labeled property graphs with Event and Entity nodes, connected by df (directly-follows) and corr (correlation) relationships. DF relationships are entity-specific and preserve local behavioral semantics.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:624-643)**
  > An event knowledge graph is an LPG G = (N, R, lambda, #) with node labels {Event, Entity} and relationship labels {df, corr} indicating 'directly-follows' and 'correlation'...

---

### 277. DF-Path Definition

DF-paths are sequences of directly-follows relationships for the same entity, analogous to traces in classical event logs. They can meet at events correlated to multiple entities.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:667-672)**
  > A path r = <r1, ..., rk> of df-relationships is a directly-follows path (df-path) iff all relationships are defined for the same entity. r is maximal iff there is no other df-relationship extending it.

---

### 278. Labeled Property Graph Definition

Labeled property graphs are the data model for event knowledge graphs, with typed nodes and relationships that can carry attribute-value properties. This enables modeling events, entities, and their relationships.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:574-584)**
  > A labeled property graph (LPG) G = (N, R, lambda, #) is a graph with nodes N, and relationships R where each node n carries a label, each relationship r carries a label and defines a directed edge...

---

### 279. Df-Relationship Providing New Information

A directly-follows relationship in a derived entity is considered to provide new information only if it describes an actual interaction from one entity to another that was not captured in the original entities' df-paths.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:15-18)**
  > a df-relationship (e1, e2) provides new information if there is not already an existing df-relationship (e1, e2) in one of the original entities

---

### 280. Event Node Definition

Events are defined relative to entities. An event can be starting/ending globally (no df-relationships at all) or for a specific entity (no df-relationships for that entity). Events can serve multiple roles for different entities simultaneously.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:86-91)**
  > Event e is starting or ending event if it has no incoming or outgoing df-relationship at all... Event e is starting or ending event for entity n if it has no incoming or outgoing df-relationship for n

---

### 281. Intermediate Event Definition

An intermediate event is positioned within an entity's directly-follows path, having both incoming and outgoing df-relationships for that entity. This contrasts with starting events (no incoming) and ending events (no outgoing).

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:106-107)**
  > We call an event intermediate in a df-path of an entity n if it is not a starting or ending event in the df-path of n

---

### 282. Local Event vs Shared Event Definition

Events are classified as local (only one entity's df-path goes through it) or shared (multiple entities' df-paths synchronize at the event). Shared events represent synchronization points between entities.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:156-158)**
  > An event e is local to an entity n if there is only one df-path of entity n that goes through e... Two or more entities n1,...,nk synchronize in a shared event e

---

### 283. Intermediate Synchronization Definition

Intermediate synchronization occurs when an event is intermediate for multiple entities, representing updates or state changes that require involvement of all synchronized entities.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:163-165)**
  > Event e intermediately synchronizes entities n1,...,nk when e is an intermediate event for n1,...,nk. We can interpret an intermediate synchronization as an update or state change

---

### 284. Entity Creation/Initiation Pattern

Entity creation is identified when an event is intermediate for one entity but marks the start of df-paths for other entities. This pattern indicates one entity spawning or initiating other entities.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:170-172)**
  > An event e that is intermediate for one entity n but a starting event for entities n1,...,nk can be interpreted as entity n 'created' or 'initiated' entities n1,...,nk

---

### 285. Entity Completion Pattern

Entity completion is identified when an event is intermediate for one entity but marks the end of df-paths for other entities. This represents entities being finished or closed by another entity's action.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:172-173)**
  > an event e that is intermediate for entity n and ending event for n1,...,nk is 'closing' or 'completing' entities n1,...,nk

---

### 286. Batching Event Definition

A batching event occurs when multiple entities of the same type synchronize in a single event. This represents batch processing where multiple similar items are handled together.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:174-176)**
  > An event e where multiple entities n1,...,nk of the same type synchronize is a batching event for n1,...,nk

---

### 287. Synchronous vs Asynchronous Interaction

Entity interactions are classified as synchronous (df-paths meet at same event) or asynchronous (mediated through another entity's df-path across different events). Asynchronous interactions require an intermediary entity.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:196-200)**
  > An event e where the df-paths of n1 and n2 synchronize is a synchronous interaction. A df-path for entity n describes an asynchronous interaction between n1 and n2 if n synchronizes both with n1 and n2 in different events

---

### 288. Entity as Message Pattern

An entity with a two-event df-path functions as a message between two other entities. A handover is identified when an event simultaneously ends one entity and starts another, representing transfer of control or work.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:200-202)**
  > If the df-path for n has only 2 events <e1, e2> then we can interpret entity n as message from n1 to n2. We can interpret an event e that is the ending event of entity n1 and the starting event of entity n2 as a handover

---

### 289. Indirect Entity Interaction

Indirect interaction occurs when two entities are connected only through df-paths that traverse multiple other entities. This contrasts with direct synchronous interaction at shared events.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:212-215)**
  > n1 and n2 interact indirectly if for any two events e1 of n1 and e2 of n2 the shortest df-path from e1 to e2 involves df-relationships from multiple other entities

---

### 290. Resource/Actor Entity Definition

Resources or Actors are organizational entities representing the workers and systems that execute process activities. They are distinct from the entities being processed (objects/items) and are responsible for performing the actual work.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:416-418)**
  > the organizational entities that actually make the process happen: the workers and supporting systems often called resources, and the work itself that is being carried out

---

### 291. Activity as Entity Type

Activities can be treated as entities by using the Activity property as an identifier. This creates abstract work stations that other entities 'pass through', enabling analysis of queues and workflow patterns.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:485-487)**
  > if we pick the Activity property as 'entity identifier', we infer entities such as Receive SO, Unpack, Scan, Store, Retrieve, Pack Shipment. These are not entities handled by the process. No, these entities are the actual building blocks of the process

---

### 292. Queue Definition via Activity Entities

A queue is defined as the space between two activity entities (work stations) where items wait. This emerges from treating activities as entities and analyzing how other entities traverse between them.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:513-514)**
  > The space between two work stations A and B is a queue A:B, i.e., the space where Items after being worked on at A wait until being worked on at B

---

### 293. Task Instance Definition

A task instance is a formal subgraph pattern representing a unit of work: an actor's df-path meets an entity's df-path at a start event, they synchronize through consecutive events, and diverge at an end event. This captures the actor performing related activities on an entity.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:621-625)**
  > A task instance of an actor R working on an entity X materializes in an event knowledge graph as a specific subgraph over event nodes e1,...,ek: (1) the df-paths of R and X both meet in e1, (2) diverge in ek, (3) synchronize in each event node

---

### 294. Entity Node vs Event Node Distinction

Entities are represented as distinct nodes from events in event knowledge graphs. Entities can represent concrete objects, people/actors, or abstract concepts. This dual-node structure separates what exists from what happens.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:820-823)**
  > Explicitly represent every entity that an event is correlated to as a node. An entity thereby can be anything: a specific object, a person or actor, or even an abstract concept such as an activity

---

### 295. Class Node vs Entity Node Distinction

Class nodes aggregate df-relationships between events of other entities into relationships between classes (for process discovery). Entity nodes of type Activity derive new df-relationships describing how entities pass through activities. Same identifier, different semantic purposes.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:496-500)**
  > Entity nodes identified by the activity property are semantically different from the Class nodes identified by the activity property... Class nodes semantically aggregate the existing df relationships between events

---

### 296. TaskInstance Node Type

TaskInstance is a node type that aggregates event nodes into units of work. It has a contains relationship to constituent events and inherits a Task property derived from the sequence of activity values in its events.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:702-715)**
  > For each task instances... we extend the graph with a new node with label TaskInstance... We add a new contains relationship (ti, e) from each TaskInstance node ti to each Event node e that is part of the task instance

---

### 297. Proclet Definition for Entity Types

In object-centric Petri nets, each entity type gets its own Petri net model describing its behavior. These are composed by connecting transitions representing the same activity across entity types, enabling modeling of entity interactions.

**Sources**:

- **11-Process_Mining_Event_Knowledge_Graphs (Chunk 3:17-23)**
  > Object-centric Petri nets also first discover one Petri net per entity type, then annotate the places and arcs with entity identifiers, and then compose all entity nets along transitions for the same activity

---

### 298. Event Definition in Event Logs

Events are the fundamental observation units in process mining. Unlike independent observations in classical data science, events are temporally ordered and grouped by case, requiring specialized analysis techniques that account for these relationships.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:32-34)**
  > events in an event log, which can be considered as the observations (rows) in our dataset, are related to each other in terms of time and by means of an overarching case dimension

---

### 299. Case/Process Instance Definition

A case (or process instance) is the grouping unit for events, representing one complete execution of a business process. Each case has a unique Case ID that links all events belonging to that execution together.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:68-74)**
  > each event should be linked to a case or process instance, typically by using a Case ID. This is 'Requirement 1'. In the simple example, each case or process instance will refer to one procurement

---

### 300. Activity Definition (Requirement 2)

An Activity is a labeled step in a business process that each event maps to. Activities come from a restricted vocabulary of process steps that are typically understandable to business experts. This is the second essential requirement for event logs.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:92-101)**
  > each event should correspond to an activity executed within the process. More specifically, an assumption is made that there exists a restricted set of labels, reflecting the activities in the business process

---

### 301. Event Ordering via Timestamp (Requirement 3)

Events within a case form a sequence determined by temporal ordering. While timestamps are the typical mechanism for ordering, any consistent ordering method is acceptable. This sequencing is the third essential requirement for event logs.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:110-116)**
  > each case logically consists of a sequence of events. Most often, this ordering will be derived from a timestamp attribute. However, this is not strictly mandatory

---

### 302. Event Types/Lifecycle Transitions

Events can represent different lifecycle states of activities (e.g., started, completed, suspended). A transactional lifecycle model describes the valid states and transitions an activity may undergo during execution.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:181-186)**
  > the concept of event types or lifecycle transitions of activities. When sourcing events from many process-aware information systems, events oftentimes relate to the transactional lifecycle that activities undergo

---

### 303. Event vs Activity Distinction

Events are atomic occurrences while activities may span durations. When lifecycle transitions are unavailable, each event represents activity completion. For performance analysis, start and completion events are needed to distinguish waiting time from execution time.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:219-224)**
  > In case there are no defined event types, one typically assumes that an event pertaining to the execution of an activity reflects the completion of the activity. In this case, every activity execution is represented by a single event

---

### 304. Event Log Data Source Types

Event logs can be sourced from various system types including BPMS, case management systems, ERP/CRM, operational databases, project management software, data warehouses/lakes, web data, and IoT systems. Each has different levels of process-awareness and data readiness.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:262-322)**
  > At system level, we identify the following categorization of most common and important sources for event data: BPMS, Case management and ticketing systems, ERP/CRM, Operational databases, Project management software...

---

### 305. Object/Artifact Entity in Event Logs

Objects or artifacts are entities that events can relate to in object-centric process mining. Unlike traditional case-based views, object-centric event logs allow events to correlate with multiple objects of different types, captured in the OCEL standard.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:424-433)**
  > Many source systems, including popular ERP systems, store data at the logical level of objects instead of providing a true process perspective... The recently introduced OCEL standard is another relevant piece of work, putting forward a general standard to interchange object-centric event data

---

### 306. Event Correlation Definition

Merged from 2 sources. Event abstraction transforms fine-grained events into coarser-grained events at the business activity level. This involves aggregating multiple low-level events (e.g., sensor readings) into meaningful process activities that business experts can interpret.

**Sources**:

- **12-Foundations_of_Process_Event_Data (Chunk 1:453-459)**
  > Mapping event data extracted from source systems and databases to cases (instances of the business process under investigation) is denoted as correlation

- **12-Foundations_of_Process_Event_Data (Chunk 1:476-481)**
  > abstraction techniques can be considered as mapping techniques that can translate one or more lower-level events into higher-level events pertaining to business process activities

---

### 307. Agent Definition in Multi-Agent AI Systems

In AI systems, an Agent is a specialized LLM-based entity with a distinct role optimized through prompting strategies. Agents collaborate in teams to handle complex tasks that exceed single-agent capabilities, pooling specialized expertise through collaboration.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:116-120)**
  > To overcome these limitations and fully leverage AI in automating scientific discovery, it's essential to employ a team of specialized agents. Multi-agent AI systems are known for their ability to tackle complex problems across different domains by pooling their capabilities

---

### 308. Knowledge Graph Node and Edge Definitions

In knowledge graphs, Nodes represent concepts or entities while Edges represent relationships between them. The graph structure provides both mechanistic breakdown of information and an ontological framework showing how concepts interconnect.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:108-110)**
  > knowledge graphs not only provide a mechanistic breakdown of information but also offer an ontological framework that elucidates the interconnectedness of different concepts, delineated as nodes and edges within the graph

---

### 309. Ontologist Agent Role Definition

The Ontologist agent is responsible for defining concepts and relationships extracted from knowledge graphs. It provides definitions and explanations that enable dynamic knowledge generation, identifying gaps and proposing new angles of inquiry.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:225-226)**
  > The Ontologist defines key concepts and relationships, Scientist 1 crafts a detailed research proposal, Scientist 2 expands and refines the proposal, and the Critic agent conducts a thorough review

---

### 310. Scientist Agent Role Definitions

Scientist agents synthesize knowledge graph data into research proposals. Scientist_1 creates initial hypotheses addressing hypothesis, outcome, mechanisms, design principles, unexpected properties, comparison, and novelty. Scientist_2 expands with quantitative details and simulation/experiment methods.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:356-365)**
  > The scientist agent harnesses the extensive knowledge parsed from the knowledge graph... The designated agent, Scientist_1, is configured to deliver a detailed hypothesis that is both innovative and logically grounded

---

### 311. Critic Agent Role Definition

The Critic agent conducts thorough review of research proposals, identifying strengths, weaknesses, and areas for improvement. It also identifies impactful scientific questions addressable through molecular modeling or experimentation.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:511-516)**
  > the Critic agent, responsible for thoroughly reviewing the research proposal, summarizing its key points, and recommending improvements. This agent delivers a comprehensive scientific critique, highlighting both the strengths and weaknesses

---

### 312. Planner Agent Role Definition

The Planner agent develops detailed step-by-step plans for accomplishing tasks. In automated multi-agent systems, it coordinates the workflow by defining what actions each specialized agent should take and in what sequence.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:722-723)**
  > Planner: suggests a detailed plan to solve the task

---

### 313. Assistant Agent with Tool Access

The Assistant agent has access to external tools and APIs (like Semantic Scholar). It executes functions such as knowledge path generation and novelty/feasibility assessment, extending the multi-agent system's capabilities beyond pure LLM reasoning.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:733-735)**
  > Assistant: has access to external tools including a function to generate a knowledge path from two keywords and a function to assess the novelty and feasibility of the research idea

---

### 314. Group Chat Manager Agent

The Group Chat Manager coordinates multi-agent conversations by selecting which agent should speak next based on context and agent profiles. It manages turn-taking and message broadcasting in autonomous agentic systems.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:737-738)**
  > Group chat manager: chooses the next speaker based on the context and agent profiles and broadcasts the message to the whole group

---

### 315. Human Agent in Multi-Agent Systems

The Human agent represents user input in multi-agent AI systems, posing tasks and providing guidance. Human-in-the-loop interactions enable expert feedback, hypothesis refinement, and strategic guidance at various stages of automated research development.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:720)**
  > Human: human user that poses the task and can intervene at various stages of the problem solving process

---

### 316. Concept and Relationship in Knowledge Graphs

Concepts in knowledge graphs are represented as nodes connected by relationships (edges). Paths through the graph reveal interconnections between previously unrelated concepts, enabling the discovery of novel associations and generation of innovative ideas.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:282-286)**
  > The generated path provides an analytical representation of various concepts and their interconnections, which were previously unrelated. By delineating these relationships, the model gains the ability to perceive and analyze connections between concepts

---

### 317. Path as Subgraph for Graph Reasoning

A path in graph reasoning is a sequence of connected nodes extracted from a larger knowledge graph. The path plus its second-hop neighbors forms a subgraph that provides context for reasoning, forming the substrate for hypothesis generation by agents.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 2:258-260)**
  > After the path is found, a subgraph consisting of the path nodes and their second-hop neighbors is generated, providing a broader context for the discovered route. The resulting paths are then used as substrate for graph reasoning

---

### 318. Novelty Assistant Agent

The Novelty Assistant is a specialized agent that assesses research idea novelty by comparing against existing literature via the Semantic Scholar API. It uses multiple keyword combinations to search for related publications and provides novelty ratings.

**Sources**:

- **15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 2:505-510)**
  > We use the Semantic Scholar API... we have implemented a tool featuring an AI agent named the 'novelty assistant', which calls the Semantic Scholar API three times using different combinations of keywords selected based on the research hypothesis

---

### 319. Ontologist Agent Definition

Merged from 2 sources. The ontologist is defined as an agent role responsible for defining terms and discussing their relationships. This maps to a Role entity that has a specific function within the multi-agent system - providing semantic grounding for other agents.

**Sources**:

- **15-SciAgents (Chunk 3:899-900)**
  > ontologist: An ontologist who defines each of the terms and discusses the relationships in the path

- **15-SciAgents (Chunk 7:519-520)**
  > The ontologist will define each term and discuss the relationships in the generated path

---

### 320. Scientist Agent Definition

Merged from 5 sources. The scientist agent is defined as an entity that synthesizes ontological definitions and relationships into structured research proposals. It operates downstream of the ontologist agent, demonstrating a clear agent dependency chain.

**Sources**:

- **15-SciAgents (Chunk 3:899-900)**
  > scientist: A scientist who can craft the research proposal with key aspects based on the definitions and relationships acquired by the ontologist

- **15-SciAgents (Chunk 3:901-902)**
  > mechanism_agent: mechanism_agent who can expand the 'mechanism' aspect of the research proposal crafted by the 'scientist'

- **15-SciAgents (Chunk 3:894-895)**
  > assistant: An assistant who calls the appropriate tools and functions and returns the results

- **15-SciAgents (Chunk 7:526-529)**
  > The scientist will use the definitions and relationships provided by the ontologist to craft the research proposal

- **15-SciAgents (Chunk 8:701)**
  > assistant: An assistant who calls the appropriate tools and functions as needed and returns the results

---

### 321. Hypothesis Agent Definition

A specialized agent role defined by its function to expand a specific aspect (hypothesis) of a structured output. Shows how agent roles can be defined by their task specialization.

**Sources**:

- **15-SciAgents (Chunk 3:901-902)**
  > hypothesis_agent: hypothesis_agent who can expand the 'hypothesis' aspect of the research proposal crafted by the 'scientist'

---

### 322. Outcome Agent Definition

Merged from 3 sources. Planner is defined as an agent that decomposes complex tasks into simpler sub-tasks. This role handles strategic planning and workflow orchestration in multi-agent systems.

**Sources**:

- **15-SciAgents (Chunk 3:901-902)**
  > outcome_agent: outcome_agent who can expand the 'outcome' aspect of the research proposal crafted by the 'scientist'

- **15-SciAgents (Chunk 3:894-895)**
  > planner: A planner who can suggest a plan to solve the task by breaking down the task into simpler sub-tasks

- **15-SciAgents (Chunk 8:701-702)**
  > planner: I can suggest a plan to solve the task by breaking down the task into simpler sub-tasks

---

### 323. Critic Agent Definition

Merged from 3 sources. Critic agent is defined as an entity that performs three functions: summarization (synthesis of proposal content), critique (identification of weaknesses), and improvement suggestion (actionable recommendations). It operates after all aspect agents have completed their expansions.

**Sources**:

- **15-SciAgents (Chunk 3:905-906)**
  > critic_agent: Summarizes, critiques, and suggests improvements after all seven aspects of the proposal have been expanded by the agents

- **15-SciAgents (Chunk 8:703-704)**
  > caller: I am responsible for selecting the next role to speak. Call this agent immediately after each output

- **15-SciAgents (Chunk 9:491-492)**
  > critic_agent to summarize, critique, and suggest improvements to the research proposal

---

### 324. User Agent Definition

Human participant defined as an agent role with specific capabilities (answering questions, executing code). Shows human-in-the-loop as an agent type.

**Sources**:

- **15-SciAgents (Chunk 3:893-894)**
  > user: An attentive HUMAN user who can answer questions about the task, and can perform tasks such as running Python code

---

### 325. Biological Materials Entity Definition

Merged from 2 sources. Entity type defined by design intent (imitation of natural systems). Shows purpose-driven entity classification.

**Sources**:

- **15-SciAgents (Chunk 4:93)**
  > Biological Materials: Substances that are produced by or derived from living organisms, including proteins, polysaccharides, and other biopolymers

- **15-SciAgents (Chunk 5:245)**
  > Biomimetic Materials: Materials designed to imitate the structure and function of natural biological systems

---

### 326. Novel Functionalities Entity Definition

Abstract concept defined as emergent properties. Maps to Goal entity - novel functionalities represent desired outcomes.

**Sources**:

- **15-SciAgents (Chunk 4:94)**
  > Novel Functionalities: New or unique capabilities or properties that are not typically associated with a material or system

---

### 327. Low-Temperature Processing Entity Definition

Process entity defined by its constraints and purpose. Maps to Rule entity - specifies constraints on how activities are performed.

**Sources**:

- **15-SciAgents (Chunk 4:95)**
  > Low-Temperature Processing: Techniques for fabricating or manipulating materials at temperatures that do not cause thermal degradation, often below 100C

---

### 328. Multi-Scale Organization Entity Definition

Structural pattern entity spanning multiple levels of abstraction. Demonstrates cross-scale entity definitions.

**Sources**:

- **15-SciAgents (Chunk 4:96)**
  > Multi-Scale Organization: The arrangement of structures at various scales, from the molecular to the macroscopic level, within a material or system

---

### 329. Energy-Intensive Entity Definition

Property/constraint entity definition. Characterizes processes by resource consumption - maps to Resource entity relationships.

**Sources**:

- **15-SciAgents (Chunk 4:100)**
  > Energy-Intensive: Processes or activities that require a large amount of energy to perform

---

### 330. Heat Transfer Performance Entity Definition

Performance metric entity defined as a measurable property. Shows how entities can represent quantifiable characteristics.

**Sources**:

- **15-SciAgents (Chunk 5:236-237)**
  > Heat Transfer Performance: The efficiency with which heat is transferred from one medium to another

---

### 331. Biocompatibility Entity Definition

Capability entity defined in terms of interaction with environment. Shows context-dependent entity definitions.

**Sources**:

- **15-SciAgents (Chunk 5:242)**
  > Biocompatibility: The ability of a material to perform with an appropriate host response in a specific application

---

### 332. Biocompatible Materials Entity Definition

Entity subtype defined by negative constraint (absence of adverse response). Shows constraint-based entity specialization.

**Sources**:

- **15-SciAgents (Chunk 5:243)**
  > Biocompatible Materials: Materials that are compatible with living tissue and do not produce an immunological response

---

### 333. Biomaterials Entity Definition

Broad category entity defined by interaction relationship rather than intrinsic properties.

**Sources**:

- **15-SciAgents (Chunk 5:246)**
  > Biomaterials: Any matter, surface, or construct that interacts with biological systems

---

### 334. Cyclic Loading Conditions Entity Definition

Process/condition entity defined as temporal pattern of force application. Maps to Event entity - describes recurring events.

**Sources**:

- **15-SciAgents (Chunk 5:247)**
  > Cyclic Loading Conditions: Repeated application of load or force on a material over time

---

### 335. Microfluidic Chips Entity Definition

Artifact entity defined by function and scale parameters. Shows how Resources can be defined with quantitative specifications.

**Sources**:

- **15-SciAgents (Chunk 5:248)**
  > Microfluidic Chips: Devices that manipulate small volumes of fluids using channels with dimensions of tens to hundreds of micrometers

---

### 336. Lamellar Structure Entity Definition

Structural pattern entity with associated functional properties. Links structure to function.

**Sources**:

- **15-SciAgents (Chunk 5:249)**
  > Lamellar Structure: A layered structure often found in biological materials, providing strength and flexibility

---

### 337. Stiffness Memory Entity Definition

Dynamic property entity defined as reversible behavior. Shows how entities can represent temporal/dynamic characteristics.

**Sources**:

- **15-SciAgents (Chunk 6:302)**
  > Stiffness memory: The ability of a material to return to its original stiffness after being deformed

---

### 338. Dynamic 3D Structures Entity Definition

Entity type defined by responsiveness to stimuli. Maps to Event-triggered behavior patterns.

**Sources**:

- **15-SciAgents (Chunk 6:303)**
  > Dynamic 3D structures: Three-dimensional structures that can change or move in response to external stimuli

---

### 339. Cell Signaling Entity Definition

Process entity defined as communication mechanism. Parallels Agent-to-Agent communication patterns.

**Sources**:

- **15-SciAgents (Chunk 6:305)**
  > Cell signaling: The process by which cells communicate with each other through chemical signals

---

### 340. Hierarchical Structure Entity Definition

Organizational pattern entity with recursive composition. Fundamental pattern for agent systems and organizational design.

**Sources**:

- **15-SciAgents (Chunk 6:308)**
  > Hierarchical structure: A structure that is organized in a multi-level manner, where each level is composed of smaller units

---

### 341. Crashworthiness Entity Definition

Goal-oriented property entity defined by protective function. Maps to Goal entity - represents a desired outcome/capability.

**Sources**:

- **15-SciAgents (Chunk 6:309)**
  > Crashworthiness: The ability of a structure to protect its occupants during an impact

---

### 342. Multi-Agent Role Specialization

Defines specialized agent roles in a multi-agent research system: user (human interface), planner (task decomposition), assistant (tool invocation), ontologist (term/relationship definition), scientist (proposal crafting), and seven specialized agents for expanding research aspects (hypothesis, outcome, mechanism, design_principles, unexpected_properties, comparison, novelty, critic). Each role has distinct responsibilities and constraints on when they can act.

**Sources**:

- **15-SciAgents (Chunk 7:474-486)**
  > user: An attentive HUMAN user... planner: A planner who can suggest a plan... ontologist: An ontologist who defines each of the terms...

---

### 343. Hierarchical Structure Definition

Formal definition of hierarchical structure as an organized arrangement of components at multiple levels (molecular, cellular, macroscale), each level composed of smaller sub-units. The definition emphasizes multi-scale organization contributing to emergent properties.

**Sources**:

- **15-SciAgents (Chunk 9:51-55)**
  > Hierarchical Structure and Mechanical Properties: Nacre's Structure: Nacre... composed of aragonite platelets arranged in a brick-and-mortar structure

---

### 344. Amyloid Fibrils Entity Definition

Amyloid fibrils are defined as protein aggregates that form fibrous structures, characterized by high strength and stability. They can be incorporated into composite materials to provide mechanical reinforcement and influence surface properties.

**Sources**:

- **15-SciAgents (Chunk 8:106-107)**
  > The incorporation of nanocomposites like graphene oxide (GO) or carbon nanotubes (CNTs) can introduce self-healing properties

---

### 345. Research Proposal Aspect Agents

Seven specialized agents defined to expand specific aspects of research proposals: hypothesis (core claims), outcome (expected results), mechanism (causal processes), design_principles (architectural guidelines), unexpected_properties (emergent behaviors), comparison (benchmarking), novelty (innovation claims). Critic_agent provides summarization and improvement suggestions.

**Sources**:

- **15-SciAgents (Chunk 7:481-486)**
  > hypothesis_agent... outcome_agent... mechanism_agent... design_principles_agent... unexpected_properties_agent... comparison_agent... novelty_agent... critic_agent

---

### 346. Gene Circuit Entity Definition

Gene circuits are defined as engineered networks of genes that control protein expression, secretion, and assembly in a regulated manner. They enable precise control over biological material production through synthetic biology approaches.

**Sources**:

- **15-SciAgents (Chunk 10:44-47)**
  > Gene Circuit Regulation: The hypothesis extends to the use of synthetic biology to control the production of amyloid-forming proteins

---

### 347. Knowledge Path Definition

Knowledge path is defined as a structured representation connecting concepts through relationships, generated to provide foundational context for research proposal development. It serves as the semantic backbone for multi-agent reasoning.

**Sources**:

- **15-SciAgents (Chunk 8:719)**
  > Generate Knowledge Path: Identify the key concepts and relationships between graphene and proteins

---

### 348. Composite Material Entity Definition

Composite material is defined as an entity resulting from the combination of two or more distinct materials (e.g., graphene and amyloid fibrils), exhibiting properties superior to individual components. The definition emphasizes emergent properties from material integration.

**Sources**:

- **15-SciAgents (Chunk 10:5-7)**
  > the binding of graphene to amyloid fibrils will result in a composite material with superior electrical conductivity and stability

---

### 349. Bioelectronic Device Entity

Bioelectronic device is defined as a fabricated artifact incorporating biological and electronic components, characterized by performance metrics including sensitivity (picomolar range), response time (milliseconds), and power consumption (50% reduction vs conventional).

**Sources**:

- **15-SciAgents (Chunk 10:50-56)**
  > Device Efficiency: bioelectronic devices fabricated from the graphene-amyloid fibril composite will exhibit superior performance metrics

---

### 350. Knowledge Graph Formal Definition

Formal definition of Knowledge Graph as a set of fact triples where each triple <e, r, e'> describes a relation r between head entity e and tail entity e'. Entities belong to entity set E and are assigned unique IDs. Relations belong to relation set R.

**Sources**:

- **16-KG-Agent (Chunk 1:176-182)**
  > A knowledge graph typically consists of a large number of fact triples, expressed as G = {<e, r, e'>|e, e' in E, r in R}

---

### 351. Neighboring Relations Definition

Neighboring relations is defined as the union of incoming and outgoing relations for an entity set. Formally: R{e} = {r|<e,r,e'> in G} union {r|<e',r,e> in G}. This enables bidirectional graph traversal.

**Sources**:

- **16-KG-Agent (Chunk 1:183-190)**
  > we introduce neighboring relations to denote both the incoming and outgoing relations for a set of entities {e}

---

### 352. Autonomous Agent Framework Definition

KG-Agent is defined as an autonomous agent framework that integrates: (1) LLM-based planner for decision making, (2) multifunctional toolbox, (3) KG-based executor, and (4) knowledge memory. It enables small LLMs to autonomously reason over knowledge graphs.

**Sources**:

- **16-KG-Agent (Chunk 1:23-29)**
  > we propose an autonomous LLM-based agent framework, called KG-Agent, which enables a small LLM to actively make decisions until finishing the reasoning process

---

### 353. Extraction Tools Definition

Extraction tools are defined as a category of tools that facilitate access to KG information. Includes five tools: get_relation (retrieve relations), get_head_entity/get_tail_entity (retrieve connected entities), get_entity_by_type/get_entity_by_constraint (retrieve entities with specific type or constraint).

**Sources**:

- **16-KG-Agent (Chunk 1:241-249)**
  > Extraction tools aim to facilitate the access to information from KG... get_relation, get_head_entity/get_tail_entity, get_entity_by_type/get_entity_by_constraint

---

### 354. Logic Tools Definition

Logic tools are defined as operations for manipulating extracted KG information. Includes: count (entity counting), intersect (set intersection), union (set union), judge (condition verification), end (terminate reasoning with answer). These enable computational operations on intermediate results.

**Sources**:

- **16-KG-Agent (Chunk 1:251-255)**
  > Logic tools aim to support basic manipulation operations on the extracted KG information, including entity counting (count), entity set intersection (intersect) and union (union)

---

### 355. Semantic Tools Definition

Semantic tools are defined as neural network-based functions that extend basic KG operations. Includes: retrieve_relation (semantic relation retrieval) and disambiguate_entity (entity disambiguation). These leverage pre-trained models for intelligent KG interaction.

**Sources**:

- **16-KG-Agent (Chunk 1:256-259)**
  > Semantic tools are developed by utilizing pre-trained models to implement specific functions, including relation retrieval (retrieve_relation) and entity disambiguation (disambiguate_entity)

---

### 356. Knowledge Memory Definition

Knowledge memory is defined as a stateful component containing: (1) natural language question, (2) toolbox definition, (3) current KG information, (4) history reasoning program. The first two remain constant while the latter two update during reasoning.

**Sources**:

- **16-KG-Agent (Chunk 1:545-551)**
  > The knowledge memory preserves the currently useful information to support the LLM-based planner for making decisions. It mainly contains four parts of information

---

### 357. LLM-based Planner Definition

LLM-based planner is defined as the decision-making component that selects tools based on current knowledge memory. It addresses four task requirements: entity linking, KG information access, intermediate result processing, and answer return.

**Sources**:

- **16-KG-Agent (Chunk 1:554-565)**
  > Based on the current knowledge memory, the LLM-based planner selects a tool to interact with KG at each step

---

### 358. KG-based Executor Definition

KG-based executor is defined as the component that executes function calls generated by the planner. It caches/operates on intermediate variables and extracts new entities/relations from KG. After execution, it updates the knowledge memory.

**Sources**:

- **16-KG-Agent (Chunk 1:567-571)**
  > After the planner generates the function call, the KG-based executor will execute it using a program compiler

---

### 359. Retrieval-Augmented Method Definition

Retrieval-augmented method is defined as an approach that retrieves task-related triples from KG, serializes them as part of the prompt for LLMs. Distinguished from synergy-augmented methods by not preserving structured KG format.

**Sources**:

- **16-KG-Agent (Chunk 1:125-131)**
  > The retrieval-augmented method is to retrieve and serialize the triples from the KG, and then feed it to the LLM

---

### 360. Synergy-Augmented Method Definition

Synergy-augmented method is defined as an approach enabling iterative LLM-KG interaction through multiple query rounds. Can be pre-defined (full plan first, then ground on KG) or step-by-step (plan progressively based on KG feedback).

**Sources**:

- **16-KG-Agent (Chunk 1:133-140)**
  > the synergy-augmented methods design an information interaction mechanism between LLMs and KGs to enable LLMs to query KGs multiple times

---

### 361. Instruction Tuning Data Definition

Instruction tuning data is defined as input-output pairs derived from KG reasoning programs. Input includes: question, toolbox definition, current KG information, history reasoning program. Output is the function call for the current step. Multiple pairs form complete reasoning trajectories.

**Sources**:

- **16-KG-Agent (Chunk 1:470-475)**
  > The input contains the question, toolbox definition, current KG information... and the output is the function call at the current step

---

### 362. Knowledge Graph Triple Structure

Defines Knowledge Graph as a data structure representing facts as triples with vocabulary defined by an ontological schema. This establishes KG as a simple yet efficient knowledge representation form.

**Sources**:

- **17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:35-39)**
  > Knowledge graph (KG), representing facts in the form of triples, with vocabulary defined in a schema (also known as ontology)

---

### 363. Logic Rule Structure Definition

Formal definition of logic rules with head and body atoms. Example: isfatherOf(X, Y) from Male(X) and isParentOf(X, Y). Rules enable deductive reasoning over knowledge graphs.

**Sources**:

- **17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:79-85)**
  > One rule, which can be simply represented as B1 B2 ... Bn, means that the head atom H can be inferred H from the body atoms B1, ..., Bn

---

### 364. OWL 2 Schema Language Definition

OWL 2 defined as standard schema language for KGs based on Description Logics, providing rich expressive power for class hierarchies, complex classes and relations, domain/range definitions, and schema axioms.

**Sources**:

- **17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:86-94)**
  > Web Ontology Language OWL 2, which is based on Description Logics (DLs), is a key standard schema language of KGs. It is based on the SROIQ DL

---

### 365. KG Embedding Vector Representation

Knowledge Graph Embedding defined as technique representing entities and relations as vectors while preserving semantic relationships in vector space for reasoning and prediction.

**Sources**:

- **17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:97-99)**
  > KG embedding (KGE), as a kind of representation learning technique, aims to represent entities and relations by vectors with their semantics preserved

---

### 366. Class Hierarchy Entity Type Classification

Class hierarchies define how entity types are organized, with entities as class instances. Two key encoding tasks: entity type assignment and hierarchy structure representation.

**Sources**:

- **17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:200-202)**
  > Class hierarchies classify entity types, denoting entities as instantiations of classes. There are two tasks: encoding the types of entities and encoding hierarchies

---

### 367. Relation Hierarchy Subsumption Definition

Relation hierarchies define subsumption relationships where specialized relations inherit from general ones (e.g., hasFather subsumes hasParents).

**Sources**:

- **17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:224-227)**
  > Relation hierarchies contain subsumption relationships between relations; for example, hasFather is a sub-relation of hasParents

---

### 368. Relation Properties Ontological Constraints

Relation properties define ontological constraints including domain/range, asymmetry, composition, transitivity, reflexivity, symmetry, cardinality, equivalence, and inverse relationships.

**Sources**:

- **17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:237-250)**
  > Ontological schemas often define quite a few relation properties (and constraints)... domain and range of relations... Asymmetric relations... Composition between relations... Transitive relations

---

### 369. Query as Structured Entity Request

Query defined as structured request returning entities from KG, supporting path queries, conjunctive logical queries, and Existential Positive First-Order (EPFO) expressions.

**Sources**:

- **17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:359-361)**
  > Query answering returns correct entities in a KG as answers of a given structured query, where reasoning is usually considered for hidden answers

---

### 370. Goal Entity in Multi-Agent Systems

Goal defined as user-prompted objective that drives multi-agent system behavior, decomposable into manageable tasks for orchestrated execution and result synthesis.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:17-20)**
  > Such systems strive for autonomously tackling user-prompted goals by decomposing them into manageable tasks and orchestrating their execution

---

### 371. Task as Manageable Goal Decomposition Unit

Task defined as manageable unit resulting from goal decomposition, assignable to specialized agents with dedicated roles and LLM reasoning capabilities.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:65-71)**
  > tackle user-prompted goals by employing a divide & conquer strategy, by breaking them down into smaller manageable tasks. These tasks are then assigned to specialized agents

---

### 372. Agent as LLM-Powered Intelligent Entity

Agent defined as foundational intelligent component with unique competencies including role, memory, contextual resource access, and LLM-powered reasoning/interpretative capabilities.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:467-474)**
  > intelligent agents structure the system as the foundational components. Each agent is endowed with a unique set of competencies, which include a clearly defined role, an individual memory

---

### 373. Role as Agent Capability Specification

Role defined as specification of agent's unique competencies, responsibilities and domain expertise within the multi-agent system.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:468-470)**
  > Each agent is endowed with a unique set of competencies, which include a clearly defined role, an individual memory, as well as access to further contextual resources

---

### 374. Memory as Agent Knowledge Repository

Memory defined as agent repository containing condensed experiences and knowledge, manifesting as textual records, structured databases, or embeddings (short-term and long-term).

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:893-897)**
  > each agent possesses an individual Memory - a repository that encompasses condensed experiences and knowledge gained by the agent. It can manifest in multiple formats

---

### 375. Action as Agent-Performed Operation

Action defined as operation performed by agent toward goal achievement. Types include DecomposeTask (breaking down), CreateTask, DelegateTask, ExecuteTask, EvaluateResult, and MergeResult.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:34-49)**
  > Agents execute different kinds of Actions which in sum aim at achieving the user-prompted Goal. Sub-types: DecomposeTask, Create Task, DelegateTask, ExecuteTask, EvaluateResult, MergeResult

---

### 376. Task-Management Agent Types

Task-Management Agents defined as specialized agent types: Task-Creation (generating/breaking down tasks), Task-Prioritization (urgency/importance assignment), Task-Execution (completion efficiency).

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:3-12)**
  > Task-Management Agents: Task-Creation Agent: Generating new tasks... Task-Prioritization Agent: Assigning urgency or importance... Task-Execution Agent: Ensuring efficient task completion

---

### 377. Domain Role Agent Definition

Domain Role Agents defined as domain-specific experts with specialized roles (e.g., project manager, software architect, developer, QA engineer) collaborating within application context.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:14-17)**
  > Domain Role Agents: These agents are domain-specific experts. They excel in specialized roles within the application domain, collaborating with peer role agents

---

### 378. Technical Agent Definition

Technical Agents defined as technology-focused agents interfacing with technical platforms and development tools (e.g., SQL Agent for database, Python Agent for scripts).

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:19-21)**
  > Technical Agents: These agents are tech-savvies, typically tasked with interfacing with technical platforms or development tools. Examples: SQL Agent, Python Agent

---

### 379. Communication Protocol Structure

Communication Protocol defined as structured framework establishing rules and mechanisms for agent message exchanges within multi-agent network collaboration.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:75-79)**
  > Communication Protocol provides a structured framework and methodology for agents' collaboration, guiding execution of specific Actions by establishing rules for message exchanges

---

### 380. Context as External Resource Category

Context defined as external resources providing specialized competencies, categorized into Tools, Data, and Foundation Models for task execution.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:99-101)**
  > LLM-powered agents are able to leverage specialized competencies provided by additional Context which can be distinguished into Tools, Data, and Foundation Models

---

### 381. Tool Categories for Agents

Tools defined across five categories: Search/Analysis (data probing), Execution (platform interfacing), Reasoning (computational intelligence like Wolfram Alpha), Development (coding/debugging), Communication (external interactions like email).

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:104-124)**
  > Tools: Search and Analysis Tools (probing/analyzing data), Execution Tools (interfacing/executing), Reasoning Tools (computational intelligence), Development Tools, Communication Tools

---

### 382. Data Types in Multi-Agent Systems

Data entity types: Structured (schema-defined, queryable), Unstructured (PDF-like content in vector databases like Pinecone/Chroma), Multimodal (videos/images/audio), Domain-specific (proprietary/sector-tailored).

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:127-144)**
  > Data types: Structured Text Data (defined model/schema), Unstructured Text Data (no pre-defined model, stored in vector databases), Multimodal Data, Domain-specific Data

---

### 383. Foundation Model Categories

Foundation Models defined across modalities: NLP Models (including LLMs for language), Computer Vision (image/video), Audio (speech), Multimodal (combined handling).

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:150-166)**
  > Foundation Models: NLP Models (LLMs), Computer Vision Models (images/videos), Audio Models (speech), Multimodal Models (combining NLP, Vision, Audio)

---

### 384. Autonomy Definition in AI Systems

Autonomy defined as agent capability for self-organized strategy and task execution independent of architect-defined rules, enabling dynamic adaptation to environmental conditions.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:196-204)**
  > Autonomy primarily surfaces from the capability of the multi-agent system to fulfill the designated Goal autonomously through self-organized strategy and task execution

---

### 385. Alignment Definition in AI Systems

Alignment defined as techniques ensuring system behavior aligns with human intentions/values, implemented as infrastructural approaches, procedural controls, constraints, rules, or limitations.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:185-192)**
  > Alignment primarily manifests through implementation of dedicated Alignment Techniques by System Architect into the system architecture of the Interaction Layer

---

### 386. Static Autonomy Level Definition

Static Autonomy (L0) defined as foundational level where systems follow predefined rules/mechanisms with rule-based flexibility, but agents cannot modify rules during runtime.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:331-337)**
  > L0: Static Autonomy - systems are primarily automated, relying heavily on rules, conditions, and mechanisms embedded by system architects. Agents are not empowered to modify rules during runtime

---

### 387. Adaptive Autonomy Level Definition

Adaptive Autonomy (L1) defined as intermediate level where LLM-powered agents can adjust operations within provided framework but not beyond architect-established boundaries.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:339-344)**
  > L1: Adaptive Autonomy - systems possess capability to adapt behavior within structure and procedural guidelines established by system architects

---

### 388. Self-Organizing Autonomy Level Definition

Self-Organizing Autonomy (L2) defined as highest level where agents independently make decisions, learn dynamically, and tailor operations based on environmental cues and experiences.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:346-352)**
  > L2: Self-Organizing Autonomy - LLM-powered agents emerge as principal actors, capable of self-organization, actively learning and dynamically tailoring operations in real-time

---

### 389. Integrated Alignment Level Definition

Merged from 2 sources. Integrated Alignment (L0) defined as foundational level where alignment is embedded in system architecture, static, rule-driven, and unalterable by users during operation.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:413-416)**
  > L0: Integrated Alignment - alignment techniques are built directly into the system's architecture. Alignment mechanisms are static and rule-driven, cannot be altered by users

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:419-424)**
  > L1: User-Guided Alignment - empowers users by allowing them to set or adjust specific alignment parameters, such as conditions, rules, or boundaries, before system starts operation

---

### 390. Real-Time Responsive Alignment Level Definition

Real-Time Responsive Alignment (L2) defined as highest level enabling dynamic behavior adjustment through real-time monitoring and user feedback at critical junctures.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:427-432)**
  > L2: Real-Time Responsive Alignment - adjust system's behavior in real-time. Thanks to integrated monitoring, system can actively solicit user feedback at critical decision points

---

### 391. Task-Management Activity Phases

Task-Management Activity defined with three phases: Decomposition (goal breakdown), Orchestration (task distribution/delegation), Synthesis (result evaluation/combination).

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:856-868)**
  > three core phases: Decomposition (Breaking down complex tasks into manageable Tasks), Orchestration (Organizing distribution and delegation among Agents), Synthesis (combining Task Results)

---

### 392. Artefact as Action Output

Artefact defined as output produced by task execution, encompassing text, graphics, multimedia and other multi-modal outputs with potential external process impacts.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:879-881)**
  > result might also include multiple Artefacts, encompassing text, graphics, multimedia, and more. The nature and involvement of tools can lead to varied Impacts

---

### 393. Network as Agent Constellation

Network defined as collaborative constellation of multiple intelligent agents working together within task-management activities toward shared goals.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:889-890)**
  > Within each Task-Management Activity, a set of intelligent Agents collaborate, forming a multi-agent Network

---

### 394. Prompt as Agent Communication Unit

Prompt defined as agent-generated message sent to LLM within action context, potentially augmented with Role, Memory, Context Information, or Prompt Templates before processing.

**Sources**:

- **18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:56-60)**
  > Agent Prompt generated by an Agent and triggered within a certain Action is sent to and then processed by the LLM, which generates a Response informing the next steps

---

### 395. Thought as LLM Information Unit

Thought defined as unit of information generated by LLM, modeled as graph vertex. Can be paragraph (summary), document (generation), code block (debugging), or other use-case specific content.

**Sources**:

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:17-21)**
  > model the information generated by an LLM as an arbitrary graph, where units of information ('LLM thoughts') are vertices, and edges correspond to dependencies between these vertices

---

### 396. Graph of Thoughts Structure

Graph of Thoughts formally defined as tuple containing: G (reasoning process graph with vertices/edges), T (thought transformations), E (evaluator function for scoring), R (ranking function for selection).

**Sources**:

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:234-252)**
  > GoT modeled as tuple (G, T, E, R) where G is the LLM reasoning process, T are potential thought transformations, E is an evaluator function, and R is a ranking function

---

### 397. Thought Transformation Types

Thought Transformations defined as three types: Aggregation (combining multiple thoughts), Refining (iterating on single thought via loop), Generation (creating new thoughts from existing ones).

**Sources**:

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:344-364)**
  > Aggregation Transformations: aggregate arbitrary thoughts into new ones. Refining Transformations: modifying content via loop. Generation Transformations: generate new thoughts from existing

---

### 398. Volume of Thought Metric

Volume of Thought defined as metric measuring the number of preceding LLM thoughts that could have impacted a given thought, indicating reasoning breadth and integration.

**Sources**:

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:129-134)**
  > volume of a thought: for a given thought v, the volume of v is the number of LLM thoughts, from which one can reach v using directed edges

---

### 399. Controller in GoT Architecture

Controller defined as architectural component coordinating reasoning process, containing GoO (static task decomposition structure) and GRS (dynamic reasoning state with thought history).

**Sources**:

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:390-395)**
  > Controller coordinates entire reasoning process and decides how to progress it. Contains Graph of Operations (GoO) and Graph Reasoning State (GRS)

---

### 400. Graph of Operations (GoO)

Graph of Operations defined as static execution plan specifying task decomposition, thought transformations, and their ordering/dependencies, constructed before execution.

**Sources**:

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:434-437)**
  > GoO is a static structure that specifies the graph decomposition of a given task, prescribes transformations to be applied to LLM thoughts, together with their order and dependencies

---

### 401. Graph Reasoning State (GRS)

Graph Reasoning State defined as dynamic structure tracking ongoing reasoning process including executed operations, generated thought states, validity scores, and relevant process information.

**Sources**:

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:438-443)**
  > GRS is a dynamic structure that maintains the state of the ongoing LLM reasoning process - the history of its thoughts and their states

---

### 402. Prompter Module Definition

Prompter defined as module responsible for preparing prompts for LLM, encoding graph structure and enabling use-case specific graph encodings with full graph access.

**Sources**:

- **19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:398-402)**
  > Prompter prepares the prompts to be sent to the LLM. This module is responsible for the specifics of encoding the graph structure within the prompt

---

