field: abstraction_level
aggregated_at: '2025-12-29T11:26:21.694621'
batches_merged: 2
patterns_input: 24
patterns_output: 24
patterns:
- name: Knowledge Graph as Data Graph Plus Enhancements
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 2:72-87)
    quote: We refer to a knowledge graph as a data graph potentially enhanced with
      representations of schema, identity, context, ontologies and/or rules
  description: 'The paper defines a hierarchy of abstraction where a data graph is
    the base level (collection of data represented as nodes and edges), and a knowledge
    graph represents a higher abstraction level that adds schema, identity, context,
    ontologies and rules. This establishes a clear foundational-to-application abstraction
    pattern: data graph (foundational) -> knowledge graph (enhanced/application level).'
- name: Three Types of Graph Schemata Abstraction Hierarchy
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 2:89-98)
    quote: 'We discuss three types of graph schemata: semantic, validating, and emergent'
  description: 'The paper identifies three distinct schema abstraction levels: (1)
    Semantic schema - defines meaning of high-level terms/vocabulary for reasoning;
    (2) Validating schema - prescribes structure and constraints for validation; (3)
    Emergent schema - automatically extracted latent structures. This represents abstraction
    from conceptual (semantic) to structural (validating) to empirical (emergent).'
- name: Semantic Schema for Vocabulary Definition
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 2:100-118)
    quote: A semantic schema allows for defining the meaning of high-level terms (aka
      vocabulary or terminology) used in the graph, which facilitates reasoning
  description: Semantic schema operates at a high abstraction level focused on defining
    classes (Event, City), class hierarchies (Food Festival subclass of Festival),
    and property semantics (subproperties, domains, ranges). This is a core/domain
    abstraction level that sits between foundational ontologies and application-specific
    data.
- name: RDFS as Core Domain Schema Standard
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 2:176-191)
    quote: A prominent standard for defining a semantic schema for (RDF) graphs is
      the RDF Schema (RDFS) standard, which allows for defining subclasses, subproperties,
      domains, and ranges
  description: RDFS is positioned as a core/domain level ontology standard for RDF
    graphs, enabling the definition of class hierarchies and property characteristics.
    OWL extends this further with more expressive semantics, representing a progression
    from domain to application-level ontology features.
- name: Open vs Closed World Assumption Abstraction
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 2:192-222)
    quote: Semantic schema are typically defined for incomplete graph data, where
      the absence of an edge between two nodes... does not mean that the relation
      does not hold
  description: 'The paper distinguishes abstraction levels based on completeness assumptions:
    Open World Assumption (OWA) for incomplete data at higher abstraction levels vs
    Closed World Assumption (CWA) for complete data at lower/application levels. Local
    Closed World Assumption (LCWA) provides a middle-ground abstraction where portions
    are assumed complete.'
- name: Validating Schema with Shapes
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 2:230-265)
    quote: A shape targets a set of nodes in a data graph and specifies constraints
      on those nodes
  description: Validating schemas using shapes (ShEx, SHACL) operate at an application
    abstraction level, defining concrete constraints for data validation. This contrasts
    with semantic schemas that operate at a more abstract/conceptual level for reasoning.
    Shapes represent a more operational, constraint-focused abstraction.
- name: Quotient Graphs as Emergent Schema Abstraction
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 2:434-492)
    quote: A framework often used for defining emergent schema is that of quotient
      graphs, which partition groups of nodes... according to some equivalence relation
  description: Quotient graphs provide an empirical/bottom-up abstraction mechanism
    that automatically summarizes data graphs into higher-level structures. This represents
    an emergent abstraction level derived from data rather than prescribed top-down.
    Bisimilarity preserves forward-directed paths, connecting abstraction to structural
    properties.
- name: Ontology as Formal Convention at Domain Level
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 3:286-339)
    quote: In the context of computing, an ontology is then a concrete, formal representation
      of what terms mean within the scope in which they are used (e.g., a given domain)
  description: Ontologies are positioned at the domain abstraction level, providing
    formal conventions for term meanings. Different ontologies can capture different
    perspectives at the same abstraction level (e.g., one event ontology allowing
    multiple venues vs another requiring single venue). OWL/OBOF are the ontology
    languages operating at this level.
- name: Interpretation as Abstraction Bridge
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 3:361-394)
    quote: 'We can abstractly define an interpretation of a data graph as being composed
      of two elements: a domain graph, and a mapping from the terms of the data graph
      to those of the domain graph'
  description: The paper defines interpretations as a bridge between syntactic (data
    graph) and semantic (domain graph) abstraction levels. Entities and relations
    in the domain graph represent real-world phenomena, while nodes and edges in the
    data graph represent their syntactic encodings. This is a key foundational-to-application
    abstraction mechanism.
- name: UNA/NUNA and OWA/CWA Assumption Levels
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 3:405-451)
    quote: In the case of OWL, the NUNA and OWA are adopted, thus representing the
      most general case, whereby multiple nodes/edge-labels in the graph may refer
      to the same entity/relation-type
  description: OWL's adoption of No Unique Name Assumption (NUNA) and Open World Assumption
    (OWA) positions it at a higher foundational abstraction level that makes fewer
    assumptions. Closed World Assumption and Unique Name Assumption represent more
    constrained, application-level abstractions that make stronger assumptions about
    data completeness and identity.
- name: Description Logics as Foundational Formalism
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 4:127-189)
    quote: Description Logics (DLs) were initially introduced as a way to formalise
      the meaning of frames and semantic networks... DLs form a family of logics rather
      than a particular logic
  description: Description Logics are positioned as foundational formalisms that heavily
    influenced OWL. DLs provide the theoretical basis for decidable reasoning, with
    different DLs striking different balances between expressive power and computational
    complexity. OWL 2 DL is a fragment restricted for decidability, representing a
    constrained application-level subset of the foundational DL abstraction.
- name: Four Categories of Knowledge Graph Definitions by Abstraction
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 13:127-254)
    quote: 'Category I: simply defines the knowledge graph as a graph where nodes
      represent entities, and edges represent relationships... Category II: a knowledge
      graph is a graph-structured knowledge base... Category III: outline additional,
      technical characteristics... Category IV: adopts an extensional definition'
  description: 'The paper identifies four categories of knowledge graph definitions
    representing different abstraction approaches: Category I (minimal/foundational
    - just nodes and edges), Category II (intermediate - graph-structured knowledge
    base), Category III (detailed technical criteria including reasoning), Category
    IV (extensional/by example). This taxonomy itself represents varying abstraction
    levels in defining knowledge graphs.'
- name: DL Knowledge Base Three-Layer Architecture
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:342-344)
    quote: 'A DL knowledge base K is defined as a tuple (A, T, R), where A is the
      A-Box: a set of assertional axioms; T is the T-Box: a set of class axioms; and
      R is the R-Box: a set of relation axioms'
  description: 'Description Logics formally separate knowledge into three abstraction
    layers: A-Box (ground facts about individuals - application level), T-Box (terminological/class
    definitions - domain level), and R-Box (relation/property definitions - foundational
    level). This tripartite structure provides a principled way to organize ontological
    knowledge at different abstraction levels.'
- name: Graph Interpretation Semantic Layering
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:186-195)
    quote: A (graph) interpretation I is defined as a pair I := (Gamma, dot-I) where
      Gamma is a graph called the domain graph and dot-I is a partial mapping from
      constants to terms in the domain graph
  description: Graph interpretations provide a formal abstraction layer between syntactic
    graph representations and semantic meaning. The interpretation function maps abstract
    graph elements to a concrete domain, enabling reasoning at a higher semantic level
    than raw graph structure. This distinguishes foundational semantics from application-level
    data representation.
- name: Semantic Condition Abstraction Layer
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:223-227)
    quote: 'A semantic condition is a mapping phi: 2^G -> {true, false}. An interpretation
      I is a model of G under phi if and only if I is a model of G and phi(Gamma)'
  description: Semantic conditions provide an abstraction layer that separates graph
    validity from ontological constraints. This enables modular ontology design where
    foundational graph semantics can be extended with domain-specific or application-specific
    semantic conditions without modifying the base graph model.
- name: Description Logic Expressivity Hierarchy
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:424-465)
    quote: 'Most DLs are founded on one of the following base DLs: ALC (Attributive
      Language with Complement)... S extends ALC with transitive closure. These base
      languages can be extended as follows: H adds relation inclusion. R adds complex
      relation inclusion...'
  description: DL languages form a systematic expressivity hierarchy from foundational
    (ALC) through increasingly expressive extensions (S, H, R, O, I, F, N, Q). The
    naming scheme [ALC|S][H|R][O][I][F|N|Q] encodes the abstraction level and capabilities.
    This hierarchy directly maps to the trade-off between expressivity (application
    needs) and computational decidability (foundational constraints).
- name: OWL 2 DL as Application-Level Implementation
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:467-473)
    quote: DLs have been very influential in the definition of OWL, where the OWL
      2 DL fragment (roughly) corresponds to the DL SROIQ
  description: OWL 2 DL represents an application-level implementation of foundational
    Description Logic theory. The mapping from DL axioms to OWL constructs demonstrates
    how foundational ontology concepts are translated to practical, implementable
    standards. OWL serves as domain/application layer built on DL foundations.
- name: Quotient Graph Abstraction Levels
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:42-72)
    quote: Emergent schemata are often based on the notion of a quotient graph...
      a quotient graph can merge multiple nodes into one node, where the merged node
      preserves the edges of its constituent nodes
  description: Quotient graphs provide variable abstraction levels from concrete data
    (original graph) to abstract schemas (quotient). The range from 'input graph as
    its own quotient' (no abstraction) to 'single node with all edges' (maximum abstraction)
    shows how abstraction level is a continuous spectrum. Bisimulation preserves semantic
    equivalence across abstraction levels.
- name: Rule-Based Entailment Abstraction
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:269-311)
    quote: A rule is a pair R = (B, H) such that B and H are graph patterns and Var(H)
      subseteq B. We call B the body of the rule while we call H the head of the rule
  description: Rules provide an abstraction mechanism for deriving implicit knowledge
    from explicit graph data. The 'least model' concept represents the closure of
    inferences possible at a higher abstraction level. Rules bridge foundational graph
    structure (body patterns) to domain-level semantics (head conclusions).
- name: W3C PROV as Foundational Standard
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:197-204)
    quote: The W3C PROV standard is a widely adopted representation model for provenance...
      defines Agent as one of its three core classes, alongside Entity (data) and
      Activity (process)
  description: 'W3C PROV serves as a foundational ontology layer with three core abstractions:
    Agent, Entity, and Activity. This foundational triad provides the semantic basis
    for domain-specific extensions. The paper explicitly positions PROV as the base
    abstraction that PROV-AGENT extends for agentic AI applications.'
- name: PROV-AGENT as Domain Extension Layer
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:252-256)
    quote: PROV-AGENT is a provenance model for representing AI agent interactions,
      model invocations, and their relationships to non-agentic tasks and data in
      agentic workflows. It extends W3C PROV and incorporates MCP concepts
  description: PROV-AGENT represents a domain-level ontology extension built on the
    foundational W3C PROV standard. It demonstrates the pattern of extending foundational
    ontologies to domain-specific contexts (agentic AI workflows) while maintaining
    semantic compatibility with the base layer. MCP provides application-level protocol
    integration.
- name: Hierarchical Workflow Abstraction Stack
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:263-269)
    quote: At its core, the model includes standard workflow structures such as Campaign,
      Workflow, and Task, modeled as subclasses of PROV Activities. Campaigns are
      associated with Person or Organization agents
  description: 'PROV-AGENT implements a hierarchical abstraction stack: Campaign (high-level
    organization) > Workflow (process composition) > Task (atomic execution units).
    Each level inherits from PROV Activity, demonstrating how abstraction levels can
    be modeled through class hierarchy while maintaining foundational semantics.'
- name: AIAgent as Subclass of Abstract Agent
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:278-284)
    quote: We extend the abstract W3C PROV Agent by modeling AIAgent as its subclass,
      enabling a natural integration of agent actions and interactions into the broader
      workflow provenance graph
  description: The AIAgent subclass pattern demonstrates domain-specific specialization
    of foundational abstractions. By extending the abstract PROV Agent, the model
    maintains semantic interoperability with the foundational layer while adding AI-specific
    capabilities (tool execution, model invocations). This is the canonical pattern
    for ontology abstraction level extension.
- name: DataObject Entity Hierarchy
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:297-302)
    quote: The data used or generated by agents, including prompts, responses, are
      represented as subclasses of the DataObject Entity. This allows agents to consume
      and produce not only DomainData, but also system-level and contextual data
  description: 'PROV-AGENT defines a DataObject hierarchy with multiple abstraction
    levels: DomainData (application-specific), SchedulingData (infrastructure-level),
    TelemetryData (system-level). Prompt and ResponseData represent AI-specific data
    types. This multi-level data abstraction enables rich provenance tracking across
    different semantic layers.'
