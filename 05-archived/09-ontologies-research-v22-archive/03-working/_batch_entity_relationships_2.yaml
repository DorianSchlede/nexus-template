---
batch_id: "entity_relationships_2"
field: entity_relationships
extracted_at: "2025-12-29T12:00:00Z"
chunks_read: 4
patterns_found: 28
---

patterns:
  # From 02-Knowledge_Graphs_8.md (Chunk 8/15)

  - name: "Agent-Node Lookup Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 8:27-48)"
    quote: "Protocols for performing node lookups accept a node (id) request and return a (sub-)graph describing that node"
    description: "Agents interact with knowledge graphs through node lookup protocols. The relationship is Agent -> performs -> NodeLookup -> returns -> SubGraph. This establishes a behavioral relationship where agents traverse graphs by requesting nodes and receiving incident edges."

  - name: "Agent-EdgePattern Query Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 8:65-81)"
    quote: "Edge patterns provide more flexibility than node lookups, where graph patterns are more readily decomposed into edge patterns than node lookups"
    description: "Agents can query knowledge graphs using edge patterns (triple patterns). The relationship is Agent -> queries -> EdgePattern -> returns -> Solutions. Edge patterns are singleton graph patterns with a single edge, providing fine-grained access to graph data."

  - name: "Client-Server Protocol Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 8:108-134)"
    quote: "Another alternative is to let client agents make requests based on (complex) graph patterns, with the server returning (only) the final solutions"
    description: "Client agents and servers have a request-response relationship for graph patterns. The relationship is ClientAgent -> requests -> GraphPattern -> Server -> evaluates -> Solutions. This reduces bandwidth but increases server computational cost."

  - name: "License-Asset Permission Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 8:186-198)"
    quote: "ODRL provides an information model and related vocabularies that can be used to specify permissions, duties, and prohibitions with respect to actions relating to assets"
    description: "ODRL defines relationships between licenses, assets, and permissions. The structure is License -> grants -> Permission -> allows -> Action -> on -> Asset. Actions include Modify, Distribute, Derive. This models usage rights in knowledge graphs."

  - name: "Usage Policy-Data Processing Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 8:257-269)"
    quote: "usage policies specify how data can be used: what kinds of processing can be applied, by whom, for what purpose"
    description: "Usage policies define multi-dimensional relationships: Data -> canBeProcessedBy -> Agent -> forPurpose -> Goal -> onResource -> Server. This extends access control to specify purpose, processor, and constraints for data usage."

  - name: "Entity-Edge-Encryption Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 8:272-305)"
    quote: "more fine-grained encryption can be performed for individual nodes or edge-labels in a graph, potentially providing different clients access to different information"
    description: "Encryption creates selective visibility relationships between entities and clients. The pattern is Node/Edge -> encryptedWith -> Key -> grantsAccessTo -> Client. CryptOntology embeds encryption metadata within the knowledge graph structure."

  - name: "Node-Anonymisation Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 8:321-380)"
    quote: "k-anonymity guarantees that the data of an individual is indistinguishable from at least k-1 other individuals"
    description: "Anonymisation establishes equivalence relationships between nodes. Patterns include k-anonymity (Individual -> indistinguishableFrom -> k-1 Others), k-degree anonymity (same degree nodes), and k-isomorphic neighbour anonymity (isomorphic neighbourhoods)."

  # From 02-Knowledge_Graphs_13.md (Chunk 13/15)

  - name: "Goal-Dependency Edge Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 13:5-9)"
    quote: "plan knowledge graphs where nodes represent goals and edges dependencies between goals, further encoding supporting degrees that can change upon further evidence"
    description: "In plan knowledge graphs, edges represent goal dependencies. The relationship is Goal -> dependsOn -> Goal with a supporting degree weight. This captures prerequisite and causal relationships for planning and search algorithms."

  - name: "Knowledge Actor Flow Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 13:11-18)"
    quote: "nodes representing knowledge actors (creators, sharers, users), edges representing knowledge flow from one actor to another, and edge weights indicating the velocity and viscosity"
    description: "Knowledge graphs model organizational knowledge flow. The relationship is KnowledgeActor -> flowsTo -> KnowledgeActor with velocity (delay) and viscosity (depth) attributes. This enables bottleneck analysis in knowledge transfer."

  - name: "Source-Edge Confidence Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 13:19-23)"
    quote: "knowledge graphs, defined to be weighted directed edge-labelled graphs, where weights denote confidence scores based on the centrality of source documents"
    description: "Edges carry confidence scores derived from source document centrality. The relationship is Edge -> hasConfidence -> Score -> derivedFrom -> SourceCentrality. This grounds edge reliability in document authority."

  - name: "Entity-Causality Dependency Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 13:77-87)"
    quote: "edges as denoting a form of dependence or causality, where x-y may denote that x is a prerequisite for y or that x leads to y"
    description: "Historical knowledge graphs used edges for causality and dependency. The relationship types include: Entity -> prerequisiteFor -> Entity, Entity -> leadsTo -> Entity, with optional and-or graph conjunctions/disjunctions and weighted beliefs."

  - name: "Knowledge Graph Definition Categories"
    chunk_ref: "02-Knowledge_Graphs (Chunk 13:127-191)"
    quote: "a knowledge graph is a graph where nodes represent entities, and edges represent relationships between those entities"
    description: "Four definitional categories establish entity-relationship paradigms: Category I (entities-edges basic), Category II (graph-structured knowledge base), Category III (technical criteria including schema), Category IV (extensional/by example). Each implies different relationship semantics."

  - name: "Schema-Entity Interrelation Constraint"
    chunk_ref: "02-Knowledge_Graphs (Chunk 13:176-191)"
    quote: "defines possible classes and relations of entities in a schema; allows for potentially interrelating arbitrary entities with each other"
    description: "Paulheim's criteria define schema-entity relationships: Schema -> definesClasses -> EntityTypes, Schema -> allowsRelations -> EntityRelations. Knowledge graphs allow arbitrary entity interrelation, distinguishing them from relational databases with stricter schema constraints."

  - name: "Ontology-Reasoner Integration Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 13:196-211)"
    quote: "A knowledge graph acquires and integrates information into an ontology and applies a reasoner to derive new knowledge"
    description: "Ehrlinger and Woss define a key relationship: KnowledgeGraph -> integratesInto -> Ontology, Reasoner -> derives -> NewKnowledge. This distinguishes knowledge graphs from pure ontologies through reasoning capability."

  # From 02-Knowledge_Graphs_14.md (Chunk 14/15)

  - name: "Shape-Node Validation Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 14:5-7)"
    quote: "G is valid under Sigma and T if and only if there exists a shapes map sigma such that for all s in S and v in V it holds that sigma(v,s) equals the shape evaluation"
    description: "Shapes define validation relationships between nodes and constraints. The relationship is Node -> satisfies/violates -> Shape via ShapesMap. This enables declarative data quality validation in knowledge graphs."

  - name: "Quotient Graph Partition Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 14:45-72)"
    quote: "a quotient graph can merge multiple nodes into one node, where the merged node preserves the edges of its constituent nodes"
    description: "Quotient graphs define equivalence relationships: Nodes -> partitionedBy -> EquivalenceRelation -> formsQuotient -> MergedNode. The merged node preserves original edges, enabling schema abstraction through type-based or topology-based partitioning."

  - name: "Simulation-Bisimulation Graph Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 14:77-98)"
    quote: "If a simulation exists on G and G', we say that G' simulates G... If a bisimulation exists on G and G', we say that they are bisimilar"
    description: "Simulation and bisimulation define structural relationships between graphs. Simulation is asymmetric (G' simulates G), while bisimulation is symmetric equivalence. These relationships preserve graph topology for schema derivation."

  - name: "Annotation Domain Semi-Ring Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 14:113-171)"
    quote: "An annotation domain is defined as an idempotent, commutative semi-ring D = <A, oplus, otimes, bottom, top>"
    description: "Annotated graphs add contextual relationships via semi-ring algebra. Edges become Edge -> annotatedWith -> Value from AnnotationDomain. The semi-ring operators define how annotations combine (oplus) and intersect (otimes), enabling temporal, fuzzy, or trust annotations."

  - name: "Interpretation-Model Satisfaction Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 14:186-227)"
    quote: "An interpretation I satisfies G if and only if... for all (u,l,v) in E, it holds that (u^I, l^I, v^I) in E_Gamma"
    description: "Graph interpretations define semantic relationships: Interpretation -> satisfies -> Graph when all edges map correctly to the domain graph. Interpretations that satisfy become Models, enabling semantic reasoning under UNA/NUNA assumptions."

  - name: "Rule Body-Head Entailment Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 14:269-311)"
    quote: "A rule is a pair R = (B, H) such that B and H are graph patterns and Var(H) subset of B. We call B the body of the rule while we call H the head"
    description: "Rules define entailment relationships: Body -> entails -> Head when body patterns match. Rules are applied by substituting mappings from body evaluation into head, generating new edges. The least model captures all possible inferences."

  - name: "Description Logic Class-Individual Relationship"
    chunk_ref: "02-Knowledge_Graphs (Chunk 14:335-409)"
    quote: "A DL knowledge base K is defined as a tuple (A, T, R), where A is the A-Box: a set of assertional axioms; T is the T-Box: a set of class axioms; R is the R-Box: a set of relation axioms"
    description: "DL knowledge bases structure relationships across three boxes: Individuals -> assertedIn -> A-Box, Classes -> definedIn -> T-Box, Relations -> constrainedIn -> R-Box. Class axioms (subclass, equivalence) and relation axioms (sub-property, transitivity) define the relationship semantics."

  # From 03-PROV-AGENT_Unified_Provenance_for_AI_Agents_1.md (Chunk 1/1)

  - name: "W3C PROV Agent-Activity-Entity Triad"
    chunk_ref: "03-PROV-AGENT (Chunk 1:197-207)"
    quote: "W3C PROV standard already defines Agent, the central abstraction in this work, as one of its three core classes, alongside Entity (data) and Activity (process)"
    description: "W3C PROV establishes the foundational triad: Agent -> wasAssociatedWith -> Activity -> used/generated -> Entity. Agents (software or human) are responsible for activities that consume and produce entities. This is the universal provenance pattern."

  - name: "AIAgent-Tool Execution Relationship"
    chunk_ref: "03-PROV-AGENT (Chunk 1:278-292)"
    quote: "We extend the abstract W3C PROV Agent by modeling AIAgent as its subclass... an AI agent can be associated with one or many tool executions (AgentTool)"
    description: "PROV-AGENT extends the Agent concept: AIAgent -> associatedWith -> AgentTool -> wasInformedBy -> AIModelInvocation. Tools may invoke AI models (LLMs) and generate responses attributed to the agent. This captures agentic workflow relationships."

  - name: "AIModelInvocation-Prompt-Response Relationship"
    chunk_ref: "03-PROV-AGENT (Chunk 1:285-296)"
    quote: "Each AIModelInvocation uses a Prompt and a specific AIModel... and generates a ResponseData object, which is attributedTo the corresponding agent"
    description: "Model invocations structure LLM interactions: AIModelInvocation -> uses -> Prompt, AIModelInvocation -> uses -> AIModel, AIModelInvocation -> generates -> ResponseData -> attributedTo -> AIAgent. This enables tracing reasoning through prompts to outputs."

  - name: "Task-Data Generation-Consumption Relationship"
    chunk_ref: "03-PROV-AGENT (Chunk 1:263-277)"
    quote: "Tasks consume (PROV used) and produce (PROV generated) domain-specific data objects (DomainData)... Tasks also generate SchedulingData and TelemetryData"
    description: "Tasks define data flow relationships: Task -> used -> DomainData (input), Task -> generated -> DomainData (output). Additional metadata types SchedulingData (where) and TelemetryData (runtime metrics) enrich the provenance graph."

  - name: "Agent Decision Chain Relationship"
    chunk_ref: "03-PROV-AGENT (Chunk 1:437-445)"
    quote: "the decision made for each layer informs the decision logic in the next, enabling the system to learn over the course of a print"
    description: "Agent decisions form temporal chains: AgentDecision_i -> informs -> AgentDecision_i+1. This iterative relationship enables learning over time but also risk propagation where a single error compounds across subsequent decisions."

  - name: "Provenance Query Traceability Relationship"
    chunk_ref: "03-PROV-AGENT (Chunk 1:493-537)"
    quote: "Given an agent decision Agent_Decision_i, the query traverses to its generating Agent_Tool_i, then to the inputs it used... These are traced back through Model_Evaluation_i and Physics_Model_i"
    description: "Provenance enables backwards traceability: AgentDecision -> generatedBy -> AgentTool -> used -> Scores/Results -> generatedBy -> ModelEvaluation -> used -> SensorData. This complete lineage supports root cause analysis for hallucination detection."

  - name: "Multi-Agent Workflow Coordination Relationship"
    chunk_ref: "03-PROV-AGENT (Chunk 1:280-284)"
    quote: "Multi-agentic workflows, with other AI agents, each with their own tools and reasoning paths, can be instantiated within the same provenance graph"
    description: "Multiple AI agents can coordinate within a single provenance graph. The relationships are: AIAgent_1 -> generates -> Data -> usedBy -> AIAgent_2_Tool, enabling representation of collaborative or parallel agent behaviors with full traceability."
