field: entity_relationships
aggregated_at: '2026-01-01T16:22:21.876199'
batches_merged: 11
patterns_input: 452
patterns_output: 439
patterns:
- name: Endurant-Perdurant Participation
  sources:
  - chunk_ref: 01-UFO (Chunk 1:295-296)
    quote: An endurant then participates in a perdurant if that perdurant has a part
      that is a manifestation of a disposition inhering in that endurant
  - chunk_ref: 01-UFO (Chunk 2:505-507)
    quote: Any endurant is connected to a perdurant by the manifestation relation...
      The life of an endurant is then specified by a functional relation
  description: Merged from 2 sources. Fundamental relationship connecting endurants
    to perdurants. The participation relation links entities that exist in time (endurants)
    to events/processes (perdurants) through the manifestation of dispositions. This
    grounds the Agent-Activity relationship pattern.
- name: Moment Inherence Relation
  sources:
  - chunk_ref: 01-UFO (Chunk 1:299-301)
    quote: Moments are parasitic entities and can only exist by inhering in other
      entities
  description: Inherence is the foundational existential dependence relation connecting
    moments (particularized properties) to their bearers. Moments cannot exist independently
    - they must inhere in substantials or other moments. This is a one-to-one, non-transferable
    relation.
- name: Quality-to-Value-Space Projection
  sources:
  - chunk_ref: 01-UFO (Chunk 1:302-305)
    quote: Qualities are entities that can be directly projected into certain value
      spaces. The latter, termed quality structures, are abstract entities delimiting
      the space of possible values
  description: Qualities as intrinsic moments have a projection relationship to quality
    structures (value spaces). This enables formal representation of attribute values
    through qualia in quality dimensions or domains.
- name: External Dependence for Relational Qualities
  sources:
  - chunk_ref: 01-UFO (Chunk 1:322-324)
    quote: Externally dependent modes inhere in an entity while being externally dependent
      on another entity
  description: Externally dependent modes represent truly relational properties -
    they inhere in one entity (bearer) while being existentially dependent on a separate
    entity. This grounds one-sided relational properties like 'John's love for Mary'.
- name: Qua Individual Composition
  sources:
  - chunk_ref: 01-UFO (Chunk 1:325-328)
    quote: a qua individual, which is a mode composed of other externally dependent
      modes that share the same bearer, the same source of external dependence, and
      the same foundational event
  description: 'Qua individuals aggregate externally dependent modes sharing three
    properties: same bearer, same external dependence target, same foundational event.
    Example: John-qua-husband-of-Mary aggregates all conjugal commitments.'
- name: Relator as Aggregation of Qua Individuals
  sources:
  - chunk_ref: 01-UFO (Chunk 1:329-332)
    quote: a relator is a moment that is an aggregation of qua individuals... For
      instance, John and Mary's Marriage is composed of John-qua-husband-of-Mary and
      Mary-qua-wife-of-John
  description: Relators are complex moments that aggregate multiple qua individuals
    (one from each relata). They serve as truthmakers for material relations and ground
    multi-sided relationships like marriages, enrollments, and contracts.
- name: Relator Mediation of Material Relations
  sources:
  - chunk_ref: 01-UFO (Chunk 1:333-334)
    quote: Externally dependent modes as well as relators serve as truthmarkers of
      material relations, the first for one-sided relations and the second for double-sided
      ones
  description: 'Distinction between one-sided and multi-sided material relations:
    externally dependent modes truthmake one-sided relations; relators truthmake double-sided/multi-sided
    relations. This grounds the semantic distinction between different relation types.'
- name: Kind-Instance Identity Provision
  sources:
  - chunk_ref: 01-UFO (Chunk 1:368-369)
    quote: a kind, which provides uniform principles of individuation, identity, and
      persistence to its instances
  description: Kinds provide the identity principles that define what changes an entity
    can undergo while maintaining numerical identity. Every endurant necessarily instantiates
    exactly one kind throughout its existence.
- name: Sortal Specialization of Kind
  sources:
  - chunk_ref: 01-UFO (Chunk 1:369-372)
    quote: A sortal is either a kind or a specialization of a kind, and every sortal
      that is not a kind specializes exactly one kind
  description: Sortals form taxonomic hierarchies under kinds. Subkinds are rigid
    specializations; phases and roles are anti-rigid specializations with intrinsic
    vs relational contingent conditions respectively.
- name: Role-Relator Dependence
  sources:
  - chunk_ref: 01-UFO (Chunk 1:376-377)
    quote: roles (e.g., employee as a role of a person in the scope of an employment
      relator, and husband as a role of a person in the scope of a marriage relator)
  description: Roles are anti-rigid sortals whose instantiation depends on participation
    in a relator. The role exists only while the relator exists and the entity participates
    in the relationship it reifies.
- name: Substantial-Moment Partition
  sources:
  - chunk_ref: 01-UFO (Chunk 1:298-301)
    quote: accounting for both substantial individuals (or Substantials), i.e., independent
      entities... as well as particularized properties, i.e., existentially dependent
      entities or moments
  description: The fundamental partition of endurants into substantials (independent)
    and moments (dependent). Substantials can exist independently; moments require
    a bearer for existence.
- name: Object-Collective-Quantity Partition
  sources:
  - chunk_ref: 01-UFO (Chunk 1:353-361)
    quote: Quantities are maximally-topologically-self-connected of homeomerous amounts
      of matter... Collectives are entities whose parts play the same role... Objects
      are entities whose parts play differentiated functional roles
  description: 'Three-way partition of substantials based on unity conditions: quantities
    (homogeneous matter), collectives (uniform parts), objects/functional complexes
    (differentiated functional parts).'
- name: Part-Whole Composition Relation
  sources:
  - chunk_ref: 01-UFO (Chunk 1:874-882)
    quote: P(x,x) (reflexivity)... P(x,y) and P(y,x) implies x=y (anti-symmetry)...
      P(x,y) and P(y,z) implies P(x,z) (transitivity)
  description: General extensional mereology axioms for part-whole relations. Parthood
    is reflexive, anti-symmetric, and transitive. Proper part (PP) excludes reflexive
    case.
- name: Functional Part (ComponentOf) Relation
  sources:
  - chunk_ref: 01-UFO (Chunk 1:909-913)
    quote: componentOf(x,x',y,y') iff x PP y and ifd(x,x',y,y')
  description: Functional parthood combines proper parthood with individual functional
    dependence. A component functions as type x' only when part of a whole functioning
    as type y'. This is not irrestrictively transitive.
- name: Constitution Relation
  sources:
  - chunk_ref: 01-UFO (Chunk 1:918-921)
    quote: it is a relation that holds between things of the same ontological category
  description: Constitution holds between entities of the same category (endurant-endurant
    or perdurant-perdurant) but different kinds. It is non-reflexive and asymmetric,
    grounded in asymmetric dependence.
- name: Generic Constitutional Dependence
  sources:
  - chunk_ref: 01-UFO (Chunk 1:959-961)
    quote: statues of clay are generically dependent on the type Lump of Clay. This
      can be captured with the notions of Generic Constitutional Dependence (GCD)
  description: 'Type-level constitutional dependence: instances of one kind necessarily
    require constitution by instances of another kind, but not vice versa. Enables
    modeling of material constitution patterns.'
- name: Existential Dependence Relation
  sources:
  - chunk_ref: 01-UFO (Chunk 2:117-118)
    quote: we implicitly define the relation of existential dependence between two
      entities, ed(x,y)
  description: 'Core dependence relation: ed(x,y) holds iff necessarily, if x exists
    then y exists. This grounds inherence and external dependence as special cases.'
- name: Inherence as Existential Dependence
  sources:
  - chunk_ref: 01-UFO (Chunk 2:138-139)
    quote: Inherence is a type of existential dependence relation holding between
      a moment and an entity of which it depends, called its bearer
  description: 'Inherence specializes existential dependence for moments. Properties:
    non-reflexive, asymmetric, anti-transitive, non-migratable (moment cannot inhere
    in two distinct individuals).'
- name: Ultimate Bearer Grounding
  sources:
  - chunk_ref: 01-UFO (Chunk 2:156-158)
    quote: Moments can also be involved in chains of inherence relations, which are
      ultimately grounded on a unique entity that does not inhere in anything else.
      This entity we will call the Ultimate Bearer
  description: Chains of inherence (moments of moments) terminate at a unique ultimate
    bearer that is not itself a moment. This grounds complex property structures.
- name: External Dependence Definition
  sources:
  - chunk_ref: 01-UFO (Chunk 2:189-194)
    quote: a mode x that is existentially dependent on an entity that is independent
      of the bearer of x
  description: 'External dependence: ed(x,y) where y is existentially independent
    of x''s bearer. Captures truly relational qualities where the dependence target
    is disjoint from the inherence target.'
- name: Foundational Event for Externally Dependent Modes
  sources:
  - chunk_ref: 01-UFO (Chunk 2:207-210)
    quote: Externally dependent modes (as well as relators) are founded by means of
      a unique event... John's conjugal commitments towards Mary are founded on the
      event of the wedding
  description: Every externally dependent mode and relator has exactly one foundational
    event. This event grounds/creates the relational property and defines its existence
    conditions.
- name: Qua Individual Definition
  sources:
  - chunk_ref: 01-UFO (Chunk 2:222-226)
    quote: the relation quaIndividualOf holds between x and y iff x is the sum of
      all externally dependent modes of y that share the same foundational event
  description: 'A qua individual aggregates all externally dependent modes of an entity
    sharing the same foundational event. Example: John-qua-husband-of-Mary comprises
    all marriage-founded commitments of John.'
- name: Relator Composition from Qua Individuals
  sources:
  - chunk_ref: 01-UFO (Chunk 2:248-249)
    quote: 'Relators are then implicitly defined: they are sums of qua individuals
      that share the same foundation and are existentially dependent on each other'
  description: Relators aggregate mutually dependent qua individuals with shared foundation.
    A relator must have at least two distinct qua individuals as parts, from distinct
    bearers.
- name: Mediation Relation
  sources:
  - chunk_ref: 01-UFO (Chunk 2:279-280)
    quote: We introduce the relation of mediation, mediates(x,y), between a relator
      x and an individual y that the relator connects
  description: Mediation connects a relator to the endurants it relates. Every relator
    mediates at least two distinct individuals (theorem t33). This is the semantic
    grounding for material relations.
- name: Characterization Relation
  sources:
  - chunk_ref: 01-UFO (Chunk 2:302-306)
    quote: a type is characterized by moment types that inhere in its instances
  description: Type-level relation connecting endurant types to the moment types that
    characterize them. Every instance of the characterized type bears exactly one
    instance of the characterizing moment type.
- name: Quality-Quale Value Assignment
  sources:
  - chunk_ref: 01-UFO (Chunk 2:386-388)
    quote: The hasValue relation holds from qualities to quales, where hasValue is
      functional
  description: Qualities are connected to their current values (qualia) via the functional
    hasValue relation. Each quality has exactly one value at any time, but values
    can change (generic dependence).
- name: Employment Relator Mediation Pattern
  sources:
  - chunk_ref: 01-UFO (Chunk 2:780-793)
    quote: Teacher is a role (contingently) played by a Person in the scope of an
      Employment relation to a School
  - chunk_ref: 01-UFO (Chunk 2:801-815)
    quote: Student is a role played by a Person when connected via a School Enrollment
      relator to a School
  description: 'Merged from 2 sources. Concrete instantiation of role-relator pattern:
    Employment relator mediates between Person (as Teacher) and School. The role exists
    contingently based on relator existence.'
- name: Nested Relator Dependence
  sources:
  - chunk_ref: 01-UFO (Chunk 2:749-752)
    quote: the enrollment of a Student to a Course Offering existentially depends
      both on the offering and on a particular School Enrollment
  description: Relators can depend on other relators. Course Enrollment depends on
    both Course Offering and School Enrollment, creating hierarchical relational structures.
- name: Generic vs Specific Dependence in Relations
  sources:
  - chunk_ref: 01-UFO (Chunk 2:751-754)
    quote: the relation from Course Enrollment to Course Offering is one of existential
      dependence (mediation) and, hence, immutable. However, the relation from Course
      Offering to Course Enrollment is optional
  description: 'Asymmetry in relational dependencies: mediation relations are immutable;
    inverse relations may be contingent/mutable. This enables dynamic membership in
    relational contexts.'
- name: Teacher Assignment Relator Pattern
  sources:
  - chunk_ref: 01-UFO (Chunk 2:845-857)
    quote: a Teacher is assigned to a Course Offering by having a Course Teacher Assignment
      relator that connects a Course Offering to an Employment
  description: 'Complex relator pattern: Course Teacher Assignment mediates between
    Course Offering and Employment (not Person directly). Shows relator-to-relator
    mediation enabling role-based assignments.'
- name: Agent-LLM Core Integration
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:487-493)
    quote: 'LLM (with defined Role and Task): Serves as the agent''s primary reasoning
      engine and dialogue interface. It interprets user queries, generates responses,
      and maintains coherence.'
  description: Structural relationship between Agent and LLM where the LLM serves
    as the reasoning core. The Agent contains an LLM component that has defined Role
    and Task attributes, establishing a composition relationship.
- name: Agent-Memory Association
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:491-493)
    quote: 'Memory (Short-Term and Long-Term): Captures context and relevant data
      across interactions. Short-term memory tracks immediate conversation state,
      while long-term memory stores accumulated knowledge'
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:469-474)
    quote: Each agent is endowed with a unique set of competencies, which include
      a clearly defined role, an individual memory, as well as access to further contextual
      resources
  description: Merged from 2 sources. Agents have two types of memory relationships
    - short-term for immediate context and long-term for accumulated knowledge. This
    establishes a part-whole relationship between Agent and Memory components.
- name: Agent-Planning Relationship
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:496-497)
    quote: 'Planning (Reflection & Self-Critique): Guides the agent''s iterative reasoning
      process through reflection, query routing, or self-critique, ensuring that complex
      tasks are broken down effectively'
  description: Planning capability is a component of the Agent that enables task decomposition.
    The relationship includes sub-capabilities of reflection and self-critique that
    guide the reasoning process.
- name: Agent-Tool Usage Relationship
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:500-501)
    quote: 'Tools (Vector Search, Web Search, APIs, etc.): Expands the agent''s capabilities
      beyond text generation, enabling access to external resources, real-time data,
      or specialized computations.'
  description: Agents have a uses/extends relationship with Tools. Tools are external
    resources that expand agent capabilities, establishing an association relationship
    between Agent and Resource entities.
- name: Retrieval-Augmentation-Generation Pipeline
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:158-169)
    quote: 'The architecture of RAG systems integrates three primary components...
      Retrieveal: Responsible for querying external data sources... Augmentation:
      Processes retrieved data... Generation: Combines retrieved information'
  description: 'Sequential pipeline relationship between three core components: Retrieval
    queries data sources, Augmentation processes and filters data, Generation synthesizes
    final output. This establishes a chain of process relationships.'
- name: Agent-Orchestrator Coordination
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:699-704)
    quote: This workflow features a central orchestrator model that dynamically breaks
      tasks into subtasks, assigns them to specialized worker models, and compiles
      the results. Unlike parallelization, it adapts to varying input complexity.
  description: Hierarchical relationship where an Orchestrator Agent decomposes Tasks
    and assigns to Worker Agents. The orchestrator has delegatesTo relationship with
    workers and aggregates their results.
- name: Multi-Agent Collaboration Pattern
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:575-592)
    quote: Multi-agent collaboration is a key design pattern... Agents communicate
      and share intermediate results, ensuring the overall workflow remains efficient
      and coherent. By distributing subtasks among specialized agents
  description: Peer relationship among multiple specialized agents where they communicate
    via message passing and share intermediate results. Each agent operates with its
    own memory and workflow in a collaborative structure.
- name: Reflection Feedback Loop
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:515-525)
    quote: Reflection is a foundational design pattern... enabling agents to iteratively
      evaluate and refine their outputs. By incorporating self-feedback mechanisms,
      agents can identify and address errors, inconsistencies
  description: Self-referential relationship where an Agent evaluates its own outputs
    and provides feedback to improve subsequent iterations. Creates a cyclical relationship
    between Agent, Output, and Evaluation.
- name: Query-Source Selection Relationship
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:764-788)
    quote: 'Query Submission and Evaluation: The process begins when a user submits
      a query. A coordinating agent... analyzes it to determine the most suitable
      sources of information... Knowledge Source Selection'
  description: Agent performs analysis of Query to determine which data sources (structured
    databases, semantic search, web search, recommendation systems) are appropriate.
    Establishes a selects relationship between Agent and Data Sources.
- name: Graph Node Connectivity
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:302-318)
    quote: 'Graph RAG extends traditional RAG... by integrating graph-based data structures...
      Node Connectivity: Captures and reasons over relationships between entities.
      Hierarchical Knowledge Management'
  description: Entities in Graph RAG have explicit node connectivity relationships.
    Entities are connected through graph edges that capture semantic relationships
    and enable multi-hop reasoning across connected nodes.
- name: Tool Integration with External APIs
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:555-564)
    quote: Tool Use enables agents to extend their capabilities by interacting with
      external tools, APIs, or computational resources... dynamically integrating
      tools into workflows, agents can adapt to complex tasks
  description: Agents dynamically bind to external tools and APIs during workflow
    execution. This establishes a runtime association relationship between Agent and
    external Resource entities.
- name: Prompt Chaining Sequential Dependency
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:623-625)
    quote: Prompt chaining decomposes a complex task into multiple steps, where each
      step builds upon the previous one. This structured approach improves accuracy
      by simplifying each subtask before moving forward.
  description: Tasks have sequential dependency relationships where each task step
    depends on and builds upon the output of the previous step. Creates a chain of
    precedes/follows relationships.
- name: Routing Classification Relationship
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:647-648)
    quote: Routing involves classifying an input and directing it to an appropriate
      specialized prompt or process. This method ensures distinct queries or tasks
      are handled separately
  description: Input entities are classified and directed to specialized processing
    entities. Establishes a classifies/directsTo relationship pattern between Query
    and appropriate processing Resource.
- name: Parallelization Task Division
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 1:674-676)
    quote: Parallelization divides a task into independent processes that run simultaneously,
      reducing latency and improving throughput. It can be categorized into sectioning
      (independent subtasks) and voting
  description: Tasks are divided into independent subtasks with no dependencies, enabling
    parallel execution. Creates a decomposesInto relationship where parent Task has
    multiple concurrent child Tasks.
- name: Hierarchical Agent Tiers
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:103-106)
    quote: Hierarchical Agentic RAG systems employ a structured, multi-tiered approach
      to information retrieval and processing... Agents are organized in a hierarchy,
      with higher-level agents overseeing and directing lower-level agents.
  description: Agents exist in hierarchical relationships with top-tier, mid-level,
    and lower-level agents. Higher agents oversee and delegate to subordinate agents,
    creating supervisory control relationships.
- name: Top-Tier Agent Delegation
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:115-125)
    quote: 'Query Reception: A user submits a query, received by a top-tier agent...
      Strategic Decision-Making: The top-tier agent evaluates the query''s complexity
      and decides which subordinate agents or data sources to prioritize'
  description: Top-tier agent receives queries and makes strategic decisions about
    which subordinate agents to engage. Establishes delegatesTo and prioritizes relationships
    between agent levels.
- name: Aggregation and Synthesis
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:131-132)
    quote: 'Aggregation and Synthesis: The results from subordinate agents are collected
      and integrated by the higher-level agent, which synthesizes the information
      into a coherent response.'
  description: Higher-level agents collect and aggregate outputs from subordinate
    agents. Creates an aggregates relationship where parent agent synthesizes child
    agent outputs into unified response.
- name: Corrective RAG Agent Chain
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:226-244)
    quote: 'The Corrective RAG system is built on five key agents: Context Retrieval
      Agent... Relevance Evaluation Agent... Query Refinement Agent... External Knowledge
      Retrieval Agent... Response Synthesis Agent'
  description: Five specialized agents form a processing chain with defined roles
    and handoff relationships. Each agent has specific responsibilities and passes
    results to subsequent agents in the correction pipeline.
- name: Relevance Evaluation Triggering
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:204-206)
    quote: 'Document Relevance Evaluation: Retrieved documents are assessed for relevance
      by the Relevance Evaluation Agent. Documents below the relevance threshold trigger
      corrective steps.'
  description: Evaluation agent assesses documents against relevance threshold. When
    threshold not met, creates a triggers relationship that activates corrective action
    agents.
- name: Query Refinement Feedback
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:208-209)
    quote: 'Query Refinement and Augmentation: Queries are refined by the Query Refinement
      Agent, which leverages semantic understanding to optimize retrieval for better
      results.'
  description: Query Refinement Agent has a refines relationship with Query entity,
    transforming input queries to improve retrieval effectiveness through semantic
    optimization.
- name: Adaptive Query Complexity Classification
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:317-321)
    quote: Adaptive RAG enhances the flexibility... by dynamically adjusting query
      handling strategies based on the complexity of the incoming query... employs
      a classifier to assess query complexity
  description: Classifier component assesses Query complexity and triggers different
    processing strategies. Creates a classifiesComplexity relationship between Classifier
    and Query with routing to appropriate handlers.
- name: Graph-Text Retrieval Integration
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:449-452)
    quote: Agent-G introduces a novel agentic architecture that integrates graph knowledge
      bases with unstructured document retrieval. By combining structured and unstructured
      data sources
  description: 'Framework integrates two types of data sources: graph knowledge bases
    (structured) and documents (unstructured). Creates a combines/integrates relationship
    between different data modality sources.'
- name: Critic Module Validation
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:474-476)
    quote: 'Critic Module: Evaluates the relevance and quality of retrieved information,
      ensuring alignment with the query.'
  description: Critic module has an evaluates relationship with retrieved information,
    assessing quality and relevance. Acts as a validation checkpoint in the agent
    pipeline.
- name: Dynamic Agent Collaboration
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:502-508)
    quote: 'Dynamic Agent Interaction: Task-specific agents collaborate to integrate
      diverse data types. Ensures cohesive retrieval and synthesis across graph and
      text sources.'
  description: Task-specific agents collaborate dynamically to integrate heterogeneous
    data types. Creates collaboratesWith relationships among specialized agents working
    on shared objectives.
- name: Graph Expansion for Entity Relations
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:595-598)
    quote: 'Graph Expansion: Enhances conventional base retrievers (e.g., BM25) by
      expanding the retrieval process to include graph-structured data, enabling the
      system to capture complex relationships and dependencies between entities.'
  description: Graph expansion technique enables capture of entity relationships and
    dependencies. Entities are connected through graph structure that explicitly models
    relationships between concepts.
- name: Agent Graph Path Selection
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:615-622)
    quote: 'Agent-Based Retrieval: Employs an agent framework to manage the retrieval
      process, enabling dynamic selection and combination of retrieval strategies...
      Agents can autonomously decide to utilize graph-expanded retrieval paths'
  description: Agents make autonomous decisions about which graph paths to traverse
    for retrieval. Creates a navigates/selects relationship between Agent and graph
    structure paths.
- name: Document Workflow State Maintenance
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:722-728)
    quote: 'State Maintenance Across Processes: The system maintains state about document
      context, ensuring consistency and relevance across multi-step workflows. Tracks
      the progression of the document through various processing stages.'
  description: Workflow system maintains state relationships with documents across
    processing stages. Creates a tracks/maintains relationship between Workflow and
    Document entities through their lifecycle.
- name: Agentic Orchestration Business Rules
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 2:737-742)
    quote: 'Agentic Orchestration: Intelligent agents apply business rules, perform
      multi-hop reasoning, and generate actionable recommendations. Orchestrates components
      such as parsers, retrievers, and external APIs'
  description: Orchestrating agents apply Rule entities to govern processing flow.
    Creates applies/enforces relationships between Agent, Rule, and processing components.
- name: EHR Integration Relationship
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 3:27-34)
    quote: Agentic RAG systems enable this by retrieving real-time clinical guidelines,
      medical literature, and patient history to assist clinicians... integrating
      electronic health records (EHR) and up-to-date medical literature
  description: Healthcare agentic RAG creates integration relationships between EHR
    data, clinical guidelines, and medical literature. Data entities from multiple
    sources are linked to support decision-making.
- name: Contract Knowledge Graph Integration
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 3:56-59)
    quote: A legal agentic RAG system can analyze contracts, extract critical clauses,
      and identify potential risks. By combining semantic search capabilities with
      legal knowledge graphs
  description: Legal domain creates integration between semantic search and knowledge
    graphs. Contract entities are analyzed through graph-based relationships to identify
    clause patterns and risks.
- name: LangChain-LangGraph Complementary Relationship
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 3:164-167)
    quote: LangChain provides modular components for building RAG pipelines, seamlessly
      integrating retrievers, generators, and external tools. LangGraph complements
      this by introducing graph-based workflows that support loops, state persistence
  description: LangChain and LangGraph have complementary relationship where LangChain
    provides components and LangGraph adds graph workflow capabilities including loops
    and state persistence.
- name: Meta-Agent Sub-Agent Architecture
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 3:169-172)
    quote: LlamaIndex's Agentic Document Workflows (ADW) enable end-to-end automation...
      introduces a meta-agent architecture where sub-agents manage smaller document
      sets, coordinating through a top-level agent
  description: Meta-agent coordinates multiple sub-agents in hierarchical structure.
    Sub-agents have manages relationship with document sets and coordinates relationship
    with top-level meta-agent.
- name: Multi-Agent Framework Patterns
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 3:182-185)
    quote: 'CrewAI and AutoGen: These frameworks emphasize multi-agent architectures.
      CrewAI supports hierarchical and sequential processes, robust memory systems,
      and tool integrations.'
  description: Multi-agent frameworks support both hierarchical and sequential process
    relationships between agents. Agents connect to memory systems and tools through
    integration relationships.
- name: Agent Autonomy and Structured Collaboration
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 3:188-189)
    quote: An educational framework designed for ergonomic, lightweight multi-agent
      orchestration, emphasizing agent autonomy and structured collaboration.
  description: Agents balance autonomy with structured collaboration relationships.
    Creates tension between independent operation and coordinated teamwork patterns.
- name: Knowledge Graph Question Answering
  sources:
  - chunk_ref: 20-Agentic_RAG_Survey (Chunk 3:280-282)
    quote: 'GNN-RAG: This benchmark evaluates graph-based RAG systems on tasks like
      node-level and edge-level predictions, focusing on retrieval quality and reasoning
      performance in Knowledge Graph Question Answering (KGQA)'
  description: KGQA systems reason over knowledge graph structures with node-level
    and edge-level relationships. Questions are answered by traversing entity relationships
    in the graph.
- name: Process-Smart Contract Transformation
  sources:
  - chunk_ref: 21-LLM_Smart_Contracts_from_BPMN (Chunk 1:54-57)
    quote: Blockchain-based business process execution relies on a model-driven paradigm,
      where process descriptions are transformed into executable artefacts based on
      rule-based transformation tools.
  description: Process models have transformsTo relationship with smart contract code.
    BPMN process descriptions are source entities that transform into executable blockchain
    artifacts.
- name: Choreography Task-Participant Relationship
  sources:
  - chunk_ref: 21-LLM_Smart_Contracts_from_BPMN (Chunk 1:313-314)
    quote: The simulator also generates an encoding that maps the events and participants
      to how they should be represented in the smart contract (taskIDs and participantIDs,
      the latter associated with a blockchain address).
  description: Tasks and Participants have encoding relationships with smart contract
    identifiers. Participants map to blockchain addresses, establishing identity relationships
    across domains.
- name: Trace-Contract Conformance
  sources:
  - chunk_ref: 21-LLM_Smart_Contracts_from_BPMN (Chunk 1:239-251)
    quote: An established method to benchmark the correctness of a blockchain-based
      business process is to replay all possible conforming traces (which the smart
      contract has to accept) and replay a set of non-conforming traces (which the
      smart contract has to reject)
  description: Traces have conformsTo or violates relationships with smart contracts.
    Conforming traces must be accepted while non-conforming traces must be rejected,
    establishing validation relationships.
- name: Process Flow Enforcement
  sources:
  - chunk_ref: 21-LLM_Smart_Contracts_from_BPMN (Chunk 1:467-469)
    quote: 'Specifically, in our prompt we ask for a Solidity implementation for the
      given process model, enforcing: (i) the control flow, i.e., the order of tasks,
      (ii) that only the respective initiator can execute a task'
  description: Smart contracts enforce relationships between tasks (control flow order)
    and between tasks and roles (initiator authorization). Creates enforcedBy relationship
    from process rules to contract code.
- name: XOR Gateway Data Decision
  sources:
  - chunk_ref: 21-LLM_Smart_Contracts_from_BPMN (Chunk 1:355-358)
    quote: As we also want to benchmark data-based exclusive gateways (XOR), we had
      to extend the playout functionality to generate appropriate data manipulation
      events... for each outgoing flow (other than the default flow), we generate
      a boolean decision.
  description: XOR gateways create conditional relationships between tasks based on
    data values. Data entities determine which branch of the process flow is executed
    through boolean decision relationships.
- name: Predecessor-Successor Task Chain
  sources:
  - chunk_ref: 21-LLM_Smart_Contracts_from_BPMN (Chunk 1:309-312)
    quote: From the model data (process models), a simulator component generates conforming
      and non-conforming traces. This simulator component is external to the framework,
      so it can be swapped based on different model data inputs.
  description: Process models contain predecessor-successor relationships between
    tasks. Traces are sequences of events following these defined relationships through
    the process flow.
- name: Activity-Predecessor-Successor Flow
  sources:
  - chunk_ref: 22-RPA_Framework_BPM_Activities (Chunk 1:328-331)
    quote: the execution order and the number of process variants to measure a process's
      standardization. We can, for instance, analyze predecessors and successors of
      the process of interest. Ideally, the order of execution remains the same
  description: Activities have predecessor and successor relationships defining execution
    order. Process standardization is measured by consistency of these relationships
    across variants.
- name: Activity-Resource Assignment
  sources:
  - chunk_ref: 22-RPA_Framework_BPM_Activities (Chunk 1:399-405)
    quote: The framework includes resources as criterion to highlight the number of
      users involved in the process... based on the number of users performing the
      same task. Second, multiple users contribute to an activity's instance.
  description: Activities have assignedTo relationships with Resources (users). Multiple
    users can perform same activity type, and multiple users can contribute to single
    activity instance.
- name: Activity-System Interaction
  sources:
  - chunk_ref: 22-RPA_Framework_BPM_Activities (Chunk 1:194-201)
    quote: tasks including the access to different systems are mentioned to be suitable
      for RPA... A software robot can work within the different systems flawlessly
      and execute the tasks more rapidly, enabling not only the extraction of information
      but also the triggering of events
  description: Activities have interactsWith relationships with multiple systems.
    Tasks may access, extract from, or trigger events in various information systems
    during execution.
- name: Activity-Data Dependency
  sources:
  - chunk_ref: 22-RPA_Framework_BPM_Activities (Chunk 1:365-374)
    quote: In many processes, information is processed in multiple systems... the
      data source must be digital. Moreover, the data must at least be semi-structured
      to enable automation. When a process involves handling data, users may perform
      simple operations to extract it from the source
  description: Activities have data dependencies where they extract, process, and
    enter data. Data must be structured or semi-structured, creating type constraints
    on the data relationship.
- name: Process Variant Relationship
  sources:
  - chunk_ref: 22-RPA_Framework_BPM_Activities (Chunk 1:492-495)
    quote: 'Maturity: The maturity expresses the number of compliant process variants
      which establish over time. In total there are 25 variants containing the activity.
      Out of these 25 variants, 22 are following compliant pre- and successors'
  description: Process models have variant relationships where activities appear in
    different execution paths. Variants share common activities but differ in predecessor-successor
    relationships.
- name: Self-Loop Rework Relationship
  sources:
  - chunk_ref: 22-RPA_Framework_BPM_Activities (Chunk 1:341-344)
    quote: Last, the failure rate relates to self loops to repair previous executions
      and a non-recoverable unsuccessful termination. A low failure rate leverages
      automation.
  description: Activities can have self-loop relationships representing rework cycles.
    Failure creates loops back to previous activities for correction, affecting process
    completion.
- name: UFO Four-Category Ontology Structure
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:127-129)
    quote: we needed a Four-Category Ontology. We needed particularized properties
      not only because they were of great importance in making sense of language and
      cognition
  description: 'UFO structures entities into four fundamental categories: individuals,
    universals, substantial objects, and accidents (particularized properties). These
    form the foundational relationship taxonomy.'
- name: Substance-Accident Dependency
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:128-136)
    quote: we needed a Four-Category Ontology... particularized properties (modes,
      relators also have their identity supplied by substance sortals... and are also
      subject of both essential and accidental properties
  description: Accidents (modes, relators) have existential dependency on substances.
    Particularized properties inherit identity from substance sortals through inheresIn
    relationship.
- name: Endurant-Perdurant Connection via Disposition
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:183-185)
    quote: 'UFO-B: An Ontology of Perdurants (Events, Processes) dealing with aspects
      such as Perdurant Mereology, Temporal Ordering of Perdurants, Object Participation
      in Perdurants, Causation, Change and the connection between Perdurants and Endurants
      via Dispositions'
  description: Endurants and Perdurants are connected through Dispositions. Dispositions
    enable the potential for objects to participate in events, bridging structural
    and behavioral ontology layers.
- name: Object Participation in Events
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:183-184)
    quote: 'UFO-B: An Ontology of Perdurants (Events, Processes) dealing with aspects
      such as Perdurant Mereology, Temporal Ordering of Perdurants, Object Participation
      in Perdurants'
  description: Objects (endurants) have participation relationships with Events (perdurants).
    This participatesIn relationship connects entities that exist wholly at each moment
    to entities that unfold over time.
- name: Part-Whole Relations in UFO
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:176-177)
    quote: An Ontology of Endurants dealing with aspects of structural conceptual
      modeling... Part-Whole Relations
  description: UFO-A includes comprehensive theory of part-whole relations including
    theories of transitivity scope. Entities can have partOf relationships with constraints
    on transitivity based on types.
- name: Relator-Material Relation Pattern
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:179-181)
    quote: Particularized Relational Properties and Relations (Guizzardi & Wagner,
      2008; Costal et al., 2011; Guarino & Guizzardi, 2015) and Roles
  description: Material relations are grounded by relators - particularized relational
    properties that mediate connections between entities. The relator-material relation
    pattern defines how domain relationships are ontologically founded.
- name: Agent-Activity-Role Structure
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:191-193)
    quote: 'UFO-C: An Ontology of Intentional and Social Entities... addresses notions
      such as Beliefs, Desires, Intentions, Goals, Actions, Commitments and Claims,
      Social Roles and Social Particularized Relational Complexes (Social Relators)'
  description: Agents (intentional entities) have beliefs, desires, and intentions
    that drive Actions. Agents occupy Social Roles with associated Commitments and
    Claims, creating structured social relationships.
- name: Universal-Particular Instantiation
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:366-369)
    quote: These distinctions, however, were considered to be distinctions among object
      universals. However, consciously ignoring this rule, users of the language started
      to systematically employ these distinctions also when characterizing universals
      whose instances are existentially dependent endurants
  description: Universals have instantiation relationships with particulars. Both
    object types and existentially dependent endurants (modes, relators) can be organized
    under universal taxonomies with type distinctions.
- name: Type Taxonomy Structure
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:174-176)
    quote: theories of Types and Taxonomic Structures connected to a theory of object
      identifiers (including a formal semantics in a Sortal Quantified Modal Logics)
  description: Types exist in taxonomic structures with specialization relationships.
    Types connect to object identifiers through formal semantics, establishing type-instance
    classification relationships.
- name: Powertype Instantiation Pattern
  sources:
  - chunk_ref: 23-UFO_Story_Ontological_Foundations (Chunk 1:383-387)
    quote: Powertypes can be loosely defined as 'types whose instances are other types'
      (e.g., the type Organization Position, which can be instantiated by the types
      Director, Manager and Secretary, or the type Bird Species
  description: Powertypes have instances that are themselves types. This creates a
    meta-level instantiation relationship where Organization Position is instantiated
    by Director, Manager, Secretary as types.
- name: Process-FlowElements Composition
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:220-224)
    quote: Process is a sub-class of FlowElementsContainer. Describing a process consists
      in defining the FlowElements that compose it.
  description: Process entities contain FlowElements through composition relationship.
    This establishes a hierarchical decomposition pattern where processes are defined
    by their constituent flow elements (activities, events, gateways).
- name: SequenceFlow Transition Pattern
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:221-223)
    quote: SequenceFlow represents transitions that ensure the move from the source
      FlowNode to the target one. A SequenceFlow may depend on a given condition
  description: SequenceFlow entities connect FlowNodes through source/target relationships.
    The relationship can be conditional, represented by Expression entities. This
    defines temporal ordering between activities.
- name: FlowNode Specialization Hierarchy
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:223-241)
    quote: 'FlowNode class groups the activities that compose a process: Activity
      is the work to be performed. Activity class has three sub-classes'
  description: FlowNode is specialized into Activity, Event, and Gateway. Activity
    further specializes into Task (atomic), Sub-Process (composite), and CallActivity
    (reusable). This establishes the core taxonomy for behavioral entities.
- name: Activity-LoopCharacteristics Iteration
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:234)
    quote: Activity class is related to LoopCharacteristics to represent iteration
      specifications.
  description: Activities can have loop characteristics attached to them, enabling
    representation of iterative/repetitive work patterns. This is a behavioral relationship
    defining execution semantics.
- name: Event-Flow Causation Pattern
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:236-239)
    quote: Event is something that happens during the course of a process. Events
      affect the flow of the process and usually have a cause or an impact and may
      require or allow for a reaction.
  description: Events relate to process flow through causation - they trigger, interrupt,
    or conclude activities. Events can be interrupting (stopping related activity)
    or non-interrupting, and are typed (Timer, Conditional, etc.).
- name: Gateway-SequenceFlow Control
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:241)
    quote: Gateway is used to control how SequenceFlows interact as they converge
      or diverge within a Process.
  description: Gateways have relationships with multiple SequenceFlows, controlling
    convergence and divergence of process paths. The cardinality of incoming/outgoing
    relationships defines gateway type (Converging, Diverging, Mixed).
- name: Activity-InputOutputSpecification Association
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:282-286)
    quote: an activity may have at most one InputOutputSpecification that is related
      to the required Input/Output Data...we have added the two relations has_resourceInput
      and has_resourceOutput
  description: Activities relate to InputOutputSpecification entities which in turn
    connect to Resources through has_resourceInput and has_resourceOutput relationships.
    This enables specification of what resources an activity consumes and produces.
- name: Resource Taxonomy Hierarchy
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:299-303)
    quote: In BBO, like in (Karray et al., 2012), we adopt the first definition of
      Resource, that englobes all resource types. Hence, we may define a resource
      taxonomy
  description: Resource is a superclass with specializations including MaterialResource,
    HumanResource, SoftwareResource, DataResource, etc. This enables typing resources
    for competency questions like 'What is the type of a given resource?'
- name: Task-ManufacturingFacility Location
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:309-317)
    quote: We limit Task to have at most one ManufacturingFacility, while other types
      of activities...may require several manufacturing facilities. Indeed, a Task
      is an atomic unit of work and should be performed at one place.
  description: Tasks have a constrained relationship (max 1) to ManufacturingFacility,
    while Processes/SubProcesses can relate to multiple facilities. ManufacturingFacility
    specializes into Station, Cell, Shop, Factory.
- name: WorkProduct-Resource Composition
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:326-331)
    quote: we consider WorkProduct as a particular type of MaterialResource...To define
      the composition of a given product, we added the relation is_composedOf between
      WorkProduct and Resource
  description: WorkProduct is a subclass of MaterialResource and can be composed of
    other Resources through is_composedOf relationship. Products can become resources
    for subsequent activities once produced.
- name: Agent-Role-Activity Assignment
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:340-354)
    quote: An Agent may be a HumanResource or a SoftwareResource...For a given Activity,
      we may assign a specific Agent (i.e., direct assignment), or a Role (i.e., indirect
      assignment)
  description: Agents relate to Activities through either direct assignment (specific
    agent) or indirect assignment (via Role). This enables flexible resource allocation
    - all agents playing a role are potential performers.
- name: Job Organizational Hierarchy
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:346-351)
    quote: The concept Job with the two relations subordinated and superior represent
      the organizational model of the company...we differentiated Job from Role to
      offer more flexibility
  description: Job entities form hierarchical relationships through subordinated/superior
    relations, modeling organizational structure. Jobs are distinct from Roles - same
    Job may have different authorization levels for Activity execution.
- name: ConvergingGateway Cardinality Constraint
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:248-252)
    quote: A Gateway with a gatewayDirection of converging MUST have multiple incoming
      Sequence Flows, but MUST NOT have multiple outgoing Sequence Flows
  description: 'ConvergingGateway has cardinality constraints: min 2 incoming SequenceFlows,
    exactly 1 outgoing. This is formalized in OWL as class definition with cardinality
    restrictions on has_incoming/has_outgoing properties.'
- name: StartEvent-SequenceFlow Source Constraint
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:415)
    quote: A Start Event MUST be a source for a Sequence Flow. StartEvent subClassOf
      has_outgoing some SequenceFlow
  description: StartEvent entities must have at least one outgoing SequenceFlow relationship.
    This is an existential constraint formalized in OWL - start events initiate process
    flow.
- name: EndEvent-SequenceFlow Target Constraint
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:416)
    quote: End Event ends the flow of the Process, and thus, will not have any outgoing
      Sequence Flows. EndEvent subClassOf not (has_outgoing some SequenceFlow)
  description: EndEvent entities cannot have outgoing SequenceFlow relationships -
    formalized as negation in OWL. End events terminate process flow.
- name: ConditionalSequenceFlow-Expression Association
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:443)
    quote: Conditional SequenceFlow is a SequenceFlow that has a specified condition
      Expression. ConditionalSequenceFlow equivalentTo (SequenceFlow and has_conditionExpression
      some Expression)
  description: ConditionalSequenceFlow is defined by having a relationship to at least
    one Expression entity via has_conditionExpression. This enables conditional routing
    in process flow.
- name: TimerEvent-EventDefinition Typing
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:444)
    quote: A Timer Event is an Event that has exactly one TimerEventDefinition. TimerEvent
      equivalentTo (Event and (has_eventDefinition exactly 1 TimerEventDefinition))
  description: Events are typed through their relationship to EventDefinition entities.
    TimerEvent requires exactly one TimerEventDefinition - cardinality constraint
    defines event type.
- name: AdHocSubProcess Content Restriction
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:417)
    quote: 'List of BPMN elements that MUST NOT be used in an Ad-HocSub-Process: Start
      Event, End Event. AdHocSubProcess SubClassOf not (has_flowElements some (StartEvent
      or EndEvent))'
  description: AdHocSubProcess has negative relationship constraints - cannot contain
    StartEvent or EndEvent via has_flowElements. This restricts valid composition
    patterns.
- name: Process-Task has_ioSpecification
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:513-516)
    quote: has_ioSpecification (T1,IO1)...has_ioSpecification (T2,IO2)...has_ioSpecification
      (P1,IO3)
  description: Both Tasks and Processes can have InputOutputSpecification entities
    attached via has_ioSpecification relationship. This enables resource tracking
    at multiple granularity levels.
- name: SequenceFlow has_sourceRef/has_targetRef
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:513-520)
    quote: has_sourceRef (F1,E1)...has_targetRef (F1,T1)...has_sourceRef (F2,T1)...has_targetRef
      (F2,T2)
  description: SequenceFlow entities connect FlowNodes through explicit has_sourceRef
    and has_targetRef relationships, establishing the directed graph structure of
    process models.
- name: Process-FlowElements has_flowElements
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:512-517)
    quote: has_flowElements (P1,Fj) j=1,..,6...has_flowElements (P1,Ti) i=1,2...has_flowElements
      (P1,G1)...has_flowElements (P1,E1)...has_flowElements (P1,E2)...has_flowElements
      (P1,SP1)
  description: Process contains all FlowElements (SequenceFlows, Tasks, Gateways,
    Events, SubProcesses) via has_flowElements relationship. This is the primary composition
    pattern.
- name: InputOutputSpecification has_resourceInput/Output
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:519)
    quote: has_resourceInput (IO3,R1)...has_resourceOutput (IO2,R4)
  description: InputOutputSpecification entities mediate between Activities and Resources
    through has_resourceInput and has_resourceOutput relationships, enabling resource
    flow modeling.
- name: Expression has_inputValue
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:519)
    quote: has_inputValue (EX1,R4)...has_inputValue (EX2,R4)
  description: Expression entities (used for conditions) reference Data/Resources
    through has_inputValue relationship, connecting conditional logic to data state.
- name: SequenceFlow has_conditionExpression
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:510)
    quote: has_conditionExpression (F4,EX1)...has_conditionExpression (F5,EX2)
  description: ConditionalSequenceFlow entities link to Expression entities via has_conditionExpression,
    enabling conditional branching based on evaluated expressions.
- name: Process takesPlaceAt ManufacturingFacility
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:517)
    quote: takesPlaceAt (P1,W1)
  description: Process entities relate to ManufacturingFacility (e.g., Workstation
    W1) via takesPlaceAt relationship, establishing spatial context for process execution.
- name: Agent-Activity Execution Relationship
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:191-192)
    quote: 'Agent: the actor that performs a given process activity. Indeed, it is
      important to specify who is responsible for the accomplishment of a given activity.'
  description: Agents have a 'performs' relationship with Activities, establishing
    accountability and authorization for activity execution. This is central to resource
    assignment in BPM.
- name: CallActivity-CallableElement Invocation
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:232-233)
    quote: 'CallActivity: an activity that calls a CallableElement that may be a GlobalTask
      (i.e., a reusable task) or Sub-Process.'
  description: CallActivity entities have a 'calls' relationship to CallableElement
    entities (GlobalTask or SubProcess), enabling process reuse and modular composition.
- name: OWL Property Domain-Range Constraints
  sources:
  - chunk_ref: 31-BBO_BPMN_Ontology (Chunk 1:388-392)
    quote: In an ontology the names (identifiers) of object and data properties must
      be distinct if they have a different semantics...the domain and range of the
      property are super-classes of all the classes linked by this property
  description: Entity relationships in BBO are formalized as OWL ObjectProperties
    with explicit domain/range constraints. Same property name implies same semantics
    with domain/range being superclasses of all connected classes.
- name: Quality-Bearer Characterization Relationship
  sources:
  - chunk_ref: 01-UFO (Chunk 3:48-52)
    quote: 'the quality type Flower Color characterizes the object type Flower: characterization(Flower,
      FlowerColor)'
  description: UFO defines a characterization relationship where quality types (like
    FlowerColor) characterize object types (like Flower). This is a structural relationship
    indicating that instances of the quality type inhere in instances of the object
    type.
- name: Inherence Relationship (Quality to Bearer)
  sources:
  - chunk_ref: 01-UFO (Chunk 3:82-85)
    quote: inherence is an existential dependence relation and, hence, the connection
      between a particular quality and its bearer is immutable
  description: In UFO, inherence represents an immutable existential dependence between
    a quality and its bearer. Once a quality inheres in a bearer, this connection
    cannot change, though the quality's value can change.
- name: HasValue Relationship (Quality to Quality Structure)
  sources:
  - chunk_ref: 01-UFO (Chunk 3:83-86)
    quote: the relation of hasValue between a quality and its value (qualia) in a
      quality structure is one of generic dependence
  description: UFO distinguishes hasValue as a generic dependence relation (mutable)
    from inherence (immutable). A quality's value in a quality structure can change
    from situation to situation.
- name: Role-Person Specialization Relationship
  sources:
  - chunk_ref: 01-UFO (Chunk 3:129-135)
    quote: Jogger is a role played by a Person when bearing a Jog mode... Role(Jogger)
      Jogger < Person
  description: UFO models roles as specializations of object kinds that are played
    when certain mode conditions are met. The Jogger role specializes Person and is
    played when the Person bears a Jog mode.
- name: Mode-Role Characterization Relationship
  sources:
  - chunk_ref: 01-UFO (Chunk 3:143-146)
    quote: 'characterization(Jogger, Jog) forall x. (x :: Jog -> exists!y. (y :: JoggingTrack
      ^ externallyDependent(x,y)))'
  description: Modes characterize roles in UFO. The Jog mode characterizes the Jogger
    role and is externally dependent on a JoggingTrack, showing both characterization
    and external dependence relationships.
- name: Event-Disposition Manifestation Relationship
  sources:
  - chunk_ref: 01-UFO (Chunk 3:149-152)
    quote: we have Jogging Events, which are direct manifestations of the dispositions
      constituting a Jog, and Jogging Processes, which are constituted by Jogging
      Events
  description: Events in UFO are manifestations of dispositions (bundles of moments).
    Jogging Events manifest dispositions in a Jog mode, while Jogging Processes are
    constituted by Jogging Events.
- name: Process-Event Constitution Relationship
  sources:
  - chunk_ref: 01-UFO (Chunk 3:161-165)
    quote: At each situation, we have a particular type of maximal Jogging Process
      (termed the life of a Jog) that is constituted by (exactly) the sum of Jogging
      Events
  description: UFO defines a constitution relationship between processes and events.
    A Jogging Process (the life of a Jog) is constituted by exactly the sum of Jogging
    Events that manifest the underlying Jog mode.
- name: Event Temporal Succession (Meet Relationship)
  sources:
  - chunk_ref: 01-UFO (Chunk 3:176-178)
    quote: two Jogging Processes that are manifestations of the same Jog and that
      immediately follow each other, meeting in the Allen sense
  description: UFO uses Allen's interval algebra for temporal relationships. Processes
    that meet in the Allen sense immediately follow each other, and constituents of
    the preceding process also constitute the succeeding process.
- name: Event Type Partition Relationship
  sources:
  - chunk_ref: 01-UFO (Chunk 3:219-228)
    quote: isPartitionedInto(JoggingEvent, JogState, JoggingLocomotion) isPartitionedInto(JoggingLocomotion,
      WalkWhileJogging, RunWhileJogging)
  - chunk_ref: 01-UFO (Chunk 3:320-328)
    quote: isPartitionedInto(Walk, OngoingWalk, FinalizedWalk)... isPartitionedInto(FinalizedWalk,
      SuccessfulWalk, RedirectedWalk)
  description: Merged from 2 sources. UFO supports partitioning of event types, where
    subsets completely cover and are disjoint from each other. JoggingEvent is partitioned
    into JogState and JoggingLocomotion, which is further partitioned.
- name: Focus Relationship (Event-Endurant)
  sources:
  - chunk_ref: 01-UFO (Chunk 3:251-257)
    quote: 'events cannot genuinely change... Alleged events change are either: (a)
      event variation... (b) the subject of change is the focus of the event, i.e.,
      the underlying endurant'
  description: In UFO, events are modally fragile and cannot change. What appears
    as event change is either variation of temporal parts or change in the underlying
    endurant (the focus). Events are carved from scenes by their focus.
- name: External Dependence Relationship (Mode to Object)
  sources:
  - chunk_ref: 01-UFO (Chunk 3:264-266)
    quote: a Walk is modeled as an externally dependent mode that inheres in the Walker
      and that is externally dependent on Place
  description: UFO distinguishes external dependence from inherence. A Walk mode inheres
    in a Walker but is also externally dependent on a Place (the destination), showing
    multiple dependency relationships.
- name: Relator Mediation Relationship
  sources:
  - chunk_ref: 01-UFO (Chunk 3:454-457)
    quote: 'forall x (x :: Spouse -> exists y (y :: ConjugalRelationship ^ mediates(y,x)))
      forall x (x :: ConjugalRelationship -> exists y,z (y :: Spouse ^ z :: Spouse
      ^ y != z ^ mediates(x,y) ^ mediates(x,z)))'
  description: UFO defines relators as entities that mediate between roles. A ConjugalRelationship
    relator mediates between at least two distinct Spouses, and each Spouse must be
    mediated by some ConjugalRelationship.
- name: Higher-Order Type Categorization Relationship
  sources:
  - chunk_ref: 01-UFO (Chunk 3:432-439)
    quote: categorizes(ConjugalRelationshipType, ConjugalRelationship)... categorizes(SpouseType,
      Spouse)
  description: UFO supports higher-order types (types of types). The categorizes relation
    connects a second-order type to its base type, ensuring all instances of the higher-order
    type specialize the base type.
- name: Node-Edge-Node Directed Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 1:140-143)
    quote: a knowledge graph as a graph of data intended to accumulate and convey
      knowledge of the real world, whose nodes represent entities of interest and
      whose edges represent relations between these entities
  description: 'Knowledge graphs define the fundamental relationship pattern: nodes
    represent entities, edges represent binary relations between entities. This is
    the core structural relationship in KGs.'
- name: Entity-Entity Binary Relation
  sources:
  - chunk_ref: 02-KG (Chunk 1:393-400)
    quote: the refined, flexible schema that the board ends up with... is modelling
      a set of binary relations between entities, which indeed can be viewed as modelling
      a graph
  description: Knowledge graphs model relationships as binary relations between entities.
    This pattern emerged from refining relational schemas to maximize flexibility
    for incomplete/diverse data.
- name: Edge-Label Semantic Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 1:405-408)
    quote: A directed edge-labelled graph... is defined as a set of nodes... and a
      set of directed labelled edges between those nodes, like Santa Lucia city Santiago
  description: In directed edge-labelled graphs, relationships are typed by edge labels.
    The label (e.g., 'city') defines the semantic nature of the relationship between
    source and target nodes.
- name: Homogeneous vs Heterogeneous Edge Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 1:491-494)
    quote: An edge is called homogeneous if it is between two nodes of the same type
      (e.g., borders); otherwise it is called heterogeneous (e.g., capital)
  description: Heterogeneous graphs distinguish edge types based on whether they connect
    nodes of the same type (homogeneous) or different types (heterogeneous), affecting
    graph partitioning strategies.
- name: Property-Value Annotation Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 1:549-556)
    quote: A property graph allows a set of property-value pairs and a label to be
      associated with both nodes and edges
  description: Property graphs extend relationships beyond simple edges by allowing
    property-value annotations on both nodes and edges, enabling richer contextual
    descriptions of relationships.
- name: Named Graph Container Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 1:583-609)
    quote: A graph dataset then consists of a set of named graphs and a default graph.
      Each named graph is a pair of a graph ID and a graph
  description: Graph datasets establish containment relationships between named graphs
    and their constituent edges. Graph names can also be used as nodes, creating meta-level
    relationships.
- name: Subclass Inheritance Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:115-118)
    quote: In Figure 11, we present a class hierarchy for events where children are
      defined to be subclasses of their parents such that if we find an edge EID15
      type Food Festival... we may also infer that EID15 type Festival
  description: Semantic schema defines subclass relationships enabling type inference.
    If X is a subclass of Y, then instances of X are also instances of Y (inheritance
    pattern).
- name: Subproperty Inheritance Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:121-125)
    quote: the properties city and venue are sub-properties of a more general property
      location, such that given an edge Santa Lucia city Santiago... we may also infer
      that Santa Lucia location Santiago
  description: Properties form hierarchies through subproperty relationships. If property
    P is a subproperty of Q, then any edge with label P also implies an edge with
    label Q between the same nodes.
- name: Domain Typing Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:127-131)
    quote: We may further define the domain of properties, indicating the class(es)
      of entities for nodes from which edges with that property extend
  description: Domain relationships connect properties to classes, enabling type inference.
    If property P has domain C, then any node with an outgoing P edge is inferred
    to be of type C.
- name: Range Typing Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:171-174)
    quote: Conversely, we may define the range of properties, indicating the class(es)
      of entities for nodes to which edges with that property extend; for example,
      we may define that the range of city is a class City
  description: Range relationships connect properties to classes for target nodes.
    If property P has range C, then any node that is the target of a P edge is inferred
    to be of type C.
- name: Shape Target Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:251-258)
    quote: A shape targets a set of nodes in a data graph and specifies constraints
      on those nodes. The shape's target can be defined in many ways, such as targetting
      all instances of a class
  description: Validating schemas use shape-target relationships to connect constraint
    specifications to sets of nodes. Shapes define structural requirements for nodes
    they target.
- name: Shape Inheritance Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:286-288)
    quote: Shapes can inherit the constraints of parent shapes - denoted with a triangle
      connector - as in the case of City and Venue, whose conforming nodes must also
      conform to the Place shape
  description: Shapes can inherit constraints from parent shapes, creating a shape
    hierarchy. Nodes conforming to child shapes must also conform to all parent shape
    constraints.
- name: Quotient Graph Simulation Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:464-471)
    quote: every quotient graph simulates its input graph (based on the simulation
      relation of set membership between data nodes and quotient nodes)
  description: Quotient graphs establish simulation relationships with their source
    data graphs. For every edge in the data graph, there must be a corresponding edge
    in the quotient graph preserving structure.
- name: Bisimilarity Structural Preservation
  sources:
  - chunk_ref: 02-KG (Chunk 2:477-491)
    quote: A stronger notion of structural preservation is given by bisimilarity,
      which... would further require that if [X] y Z is an edge in the quotient graph,
      then for all x in X, there must exist a z in Z such that [x] y z is in the data
      graph
  description: Bisimilarity defines a stronger structural relationship between graphs
    than simulation. It requires that quotient graph edges are matched by data graph
    edges for all partition members.
- name: Identity Link (Same-As) Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:690-694)
    quote: A second option is to use identity links to state that a local entity has
      the same identity as another coreferent entity found in an external source;
      an instantiation of this concept can be found in the OWL standard, which defines
      the owl:sameAs property
  description: Identity links establish coreference relationships between nodes in
    different graphs. owl:sameAs indicates two identifiers refer to the same real-world
    entity.
- name: Derivation Provenance Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 2:866-870)
    quote: entities (e.g., graphs, nodes, physical document) are derived from other
      entities, are generated and/or used by activities (e.g., extraction, authorship),
      and are attributed to agents (e.g., people, software, organisations)
  description: 'PROV Data Model defines provenance relationships: derivation (entity-entity),
    generation/usage (activity-entity), and attribution (entity-agent). Forms the
    Agent-Activity-Entity triad.'
- name: Reification Statement-About-Statement Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 3:879-891)
    quote: reification, which allows for making statements about statements in a generic
      manner... RDF reification defines a new node [e] to represent the edge and connects
      it to the source node (via subject), target node (via object), and edge label
      (via predicate)
  description: Reification creates meta-level relationships, allowing edges to become
    subjects of other edges. RDF reification uses subject/predicate/object relationships
    to represent edges as nodes.
- name: Annotation Context Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 3:107-109)
    quote: annotations that provide mathematical definitions of a contextual domain
      and key operations possible within that domain that can then be applied automatically
  description: Annotations establish contextual relationships on edges, associating
    them with domain values (temporal intervals, fuzzy values). Operations like meet
    and join combine these contextual values.
- name: Meet/Join Annotation Combination
  sources:
  - chunk_ref: 02-KG (Chunk 3:170-184)
    quote: applying a conjunction of annotations on compatible flight and city edges,
      applying the meet operator to compute the annotation for which both edges hold...
      combine these two annotations for Arica using the join operator
  description: Annotated RDF defines meet (intersection) and join (union) operations
    for combining contextual relationships. Meet computes when both edges hold; join
    computes when either holds.
- name: Ontological Assertion Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 4:530-531)
    quote: Assertional axioms can be either unary class relations on individuals,
      such as City(Santiago), or binary property relations on individuals, such as
      flight(Santiago,Arica)
  description: 'Description Logics define two fundamental relationship types: unary
    class membership (type assertions) and binary property relations (edge assertions).
    These form the A-Box.'
- name: Same-As Identity Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 3:565-567)
    quote: 'Same As: x1 same as x2 implies x1 = x2. Example: Region V same as Region
      de Valparaiso'
  description: OWL same-as relationship establishes that two terms refer to identical
    entities in the domain. This enables merging data about the same entity from different
    sources.
- name: Different-From Distinction Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 3:567)
    quote: 'Different From: x1 diff. from x2 implies x1 != x2. Example: Valparaiso
      diff. from Region de Valparaiso'
  description: OWL different-from relationship explicitly states that two terms refer
    to distinct entities, disambiguating cases where naming similarity might suggest
    identity.
- name: Inverse Property Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 3:583)
    quote: 'Inverse: p inv. of q implies x p y iff y q x. Example: venue inv. of hosts'
  description: OWL inverse relationship defines properties that are symmetric converses.
    If P is inverse of Q, then [x] P y implies [y] Q x, enabling bidirectional navigation.
- name: Transitive Property Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 3:587)
    quote: 'Transitive: p type Transitive implies x p y p z implies x p z. Example:
      part of type Transitive'
  - chunk_ref: 02-KG (Chunk 3:603)
    quote: 'Functional: p type Functional implies y1 p x p y2 implies y1 = y2. Example:
      population type Functional'
  description: Merged from 2 sources. Functional properties establish many-to-one
    relationships. If property P is functional, then any entity can have at most one
    value for P, enabling identity inference from shared values.
- name: Property Chain Composition Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 3:510-512)
    quote: we can relate a property to a chain (a path expression only allowing concatenation
      of properties) such that pairs of entities related by the chain are also related
      by the given property
  description: OWL property chains define composition relationships. If property P
    is defined as chain Q o R, then [x] Q y and [y] R z implies [x] P z, enabling
    complex path-based inferences.
- name: Rule Body-Head Implication Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 4:23-31)
    quote: A rule is composed of a body (if) and a head (then). Both the body and
      head are given as graph patterns. A rule indicates that if we can replace the
      variables of the body with terms from the data graph and form a subgraph...
      then using the same replacement of variables in the head will yield a valid
      entailment
  description: Rules define conditional relationships between graph patterns. If the
    body pattern matches, the head pattern is entailed, enabling inference of new
    relationships from existing ones.
- name: Embedding Plausibility Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 4:807-811)
    quote: given an edge [s] p o, a specific embedding approach defines a scoring
      function that accepts es (the entity embedding of node s), rp (the relation
      embedding of edge label p) and eo... and computes the plausibility of the edge
  description: Knowledge graph embeddings define plausibility relationships between
    entities and relations. The scoring function maps (subject, predicate, object)
    triples to plausibility scores indicating likelihood of truth.
- name: Translational Transformation Relationship
  sources:
  - chunk_ref: 02-KG (Chunk 4:907-912)
    quote: Translational models interpret edge labels as transformations from subject
      nodes... to object nodes; for example, in the edge San Pedro bus Moon Valley,
      the edge label bus is seen as transforming San Pedro to Moon Valley
  description: TransE and related models interpret relationships as geometric translations
    in embedding space. Edge labels transform source entity vectors toward target
    entity vectors, es + rp approximates eo.
- name: Translational Edge Transformation
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:7-12)
    quote: Translational models interpret edge labels as transformations from subject
      nodes (aka the source or head) to object nodes (aka the target or tail)
  description: Edge labels in knowledge graphs represent transformations between entities.
    The relationship between source and target nodes is modeled as a vector transformation
    where edge labels act as translation operators. This is fundamental to the Agent-Activity-Entity
    triad where Activities transform entity states.
- name: Entity-Relation Vector Embedding
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:12-14)
    quote: Over all positive edges [s] p -, TransE learns vectors es, rp, and eo aiming
      to make es + rp as close as possible to eo
  description: Entity relationships are encoded as vector arithmetic where the subject
    entity vector plus the relation vector approximates the object entity vector.
    This mathematical formalization of relationships enables computational reasoning
    over entity connections.
- name: Relation-Specific Vector Spaces
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:42-44)
    quote: TransR generalises this approach by projecting [s] and [o] into a vector
      space specific to p, which involves multiplying the entity embeddings for [s]
      and [o] by a projection matrix specific to p
  description: Different relationship types can have their own distinct vector spaces.
    Entities are projected into relation-specific spaces for computing relationship
    plausibility, allowing relationships to have semantically distinct characteristics
    (structural, behavioral, temporal).
- name: Relation Symmetry and Direction
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:50-52)
    quote: RotatE proposes translational embeddings in complex space, which allows
      to capture more characteristics of relations, such as direction, symmetry, inversion,
      antisymmetry, and composition
  description: Entity relationships possess inherent properties including directionality
    (one-way vs bidirectional), symmetry (if A relates to B, does B relate to A?),
    and composition (chaining relationships). These properties are critical for modeling
    real-world entity interactions.
- name: Graph Tensor Decomposition
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:178-184)
    quote: a graph can be encoded as a one-hot 3-order tensor G with |V| x |L| x |V|
      elements, where the element (G)ijk is set to one if the ith node links to the
      kth node with an edge having the jth label
  description: 'The complete set of entity relationships in a knowledge graph can
    be represented as a 3-dimensional tensor: entities x relationship-types x entities.
    This provides a formal mathematical structure for all relationships in the graph.'
- name: Bilinear Relationship Scoring
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:194-198)
    quote: DistMult is a seminal method for computing knowledge graph embeddings based
      on rank decompositions, where each entity and relation is associated with a
      vector of dimension d, such that for an edge [s] p -, a plausibility scoring
      function is defined
  description: Entity relationships can be evaluated for plausibility using bilinear
    scoring functions that combine subject, predicate, and object embeddings. This
    enables probabilistic assessment of potential relationships between entities.
- name: Graph-Neural Network Topology
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:427-431)
    quote: A graph neural network (GNN) builds a neural network based on the topology
      of the data graph; i.e., nodes are connected to their neighbours per the data
      graph
  description: In GNNs, the structural relationships between entities define the neural
    network architecture itself. Node connections in the knowledge graph become neural
    connections, making entity relationships fundamental to the computational structure.
- name: Entity State Propagation
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:470-476)
    quote: Each node in the graph is also associated with a state vector, which is
      recursively updated based on information from the node's neighbours - i.e.,
      the feature and state vectors of the neighbouring nodes and the feature vectors
      of the edges extending to/from them
  description: Entity states are defined and updated through their relationships with
    neighboring entities. The relationship structure mediates information flow between
    entities, with edge features carrying relationship semantics.
- name: Transition and Output Functions
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:476-480)
    quote: using a parametric function, called the transition function. A second parametric
      function, called the output function, is used to compute the final output for
      a node based on its own feature and state vector
  description: 'Two types of functions govern entity behavior in graph neural networks:
    transition functions that propagate state through relationships, and output functions
    that derive results. This parallels the Agent-Activity-Entity pattern where Activities
    transform entities.'
- name: Neighbourhood-Based Node Classification
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:582-584)
    quote: we may define neighbouring nodes differently, for example to include nodes
      for outgoing edges, or nodes one or two hops away
  description: Entity types and properties can be determined by their relationship
    neighborhoods. The pattern of connections an entity has (structural, incoming,
    outgoing, multi-hop) defines its classification and role in the knowledge graph.
- name: Rule Entailment from Edges
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:667-678)
    quote: The hypotheses then serve as interpretable models that can be used for
      further deductive reasoning. Given the graph of Figure 30, we may, for example,
      learn the rule [?x] flight ?y => [?y] flight ?x from observing that flight routes
      tend to be return routes
  description: Relationship patterns between entities can be learned as logical rules.
    These rules capture systematic patterns in how entities relate (e.g., symmetric
    relationships like 'flight'), enabling inference of new relationships from existing
    ones.
- name: Rule-Based Relationship Inference
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:680-690)
    quote: 'we might learn a DL axiom stating that airports are either domestic, international,
      or both: Airport subc DomesticAirport union InternationalAirport'
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:274-290)
    quote: A rule is a pair R = (B, H) such that B and H are graph patterns and Var(H)
      subset B. We call B the body of the rule while we call H the head of the rule
  description: Merged from 2 sources. New entity relationships are derived through
    rules with body patterns (conditions) and head patterns (conclusions). Rules formalize
    how relationship patterns imply other relationships, enabling deductive reasoning
    over the graph.
- name: Positive and Negative Edge Sets
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:706-712)
    quote: we assume a set of positive and negative edges as given. Typically positive
      edges are observed edges (i.e., those given or entailed by a knowledge graph)
      while negative edges are defined according to a given assumption of completeness
  description: Entity relationships are categorized as positive (existing/true) or
    negative (non-existing/false). This binary classification of relationships enables
    supervised learning of relationship patterns.
- name: Rule Support and Confidence
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:738-744)
    quote: The number of entailments that are positive is called the support for the
      rule, while the ratio of a rule's entailments that are positive is called the
      confidence for the rule
  description: 'Relationship patterns (rules) are evaluated by two metrics: support
    (how many entity pairs follow the pattern) and confidence (what proportion of
    applicable cases follow the pattern). These metrics quantify the strength of relationship
    patterns.'
- name: Partial Completeness Assumption
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 5:756-764)
    quote: A common heuristic is to adopt a Partial Completeness Assumption (PCA),
      which considers the set of positive edges to be those contained in the data
      graph, and the set of negative examples to be the set of all edges x p y' not
      in the graph but where there exists a node y such that x p y is in the graph
  description: For relationship learning, negative relationships are defined relative
    to known positive relationships. If an entity has a relationship of type P with
    some entity, then missing P-relationships are considered negative. This models
    relationship completeness at the entity level.
- name: Rule Refinement Operations
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:86-95)
    quote: three types of refinements are considered, each of which adds a new edge
      to the body of the rule. This new edge takes an edge label from the graph and
      may otherwise use fresh variables not appearing previously in the rule, existing
      variables that already appear in the rule, or nodes from the graph
  description: Relationship rules are constructed iteratively by adding edge patterns.
    New edges can connect existing variables, introduce new variables, or reference
    specific entities, building complex multi-hop relationship patterns.
- name: Closed Rule Constraint
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:116-123)
    quote: a rule must be closed, meaning that each variable appears in at least two
      edges of the rule, which ensures that rules are safe, meaning that each variable
      in the head appears in the body
  description: Valid relationship rules require that every entity variable participates
    in at least two relationships. This ensures that inferred relationships are grounded
    in multiple observable relationship patterns.
- name: Non-Monotonic Rules with Exceptions
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:130-140)
    quote: Gad-Elrab et al. propose a method to learn non-monotonic rules - rules
      with negated edges in the body - in order to capture exceptions to base rules
  description: Relationship patterns can include negative conditions (absence of relationships).
    Rules like 'flights within same country are domestic EXCEPT when departure airport
    is international' capture conditional relationship semantics.
- name: Disjointness Axiom Relationships
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:19-26)
    quote: the disjointness axiom DomesticAirport intersect InternationalAirport equiv
      Bottom states that the intersection of the two classes is equivalent to the
      empty class, or in simpler terms, no node can be simultaneously of type [Domestic
      Airport] and [International Airport]
  description: Entity types can have mutually exclusive (disjoint) relationships.
    An entity cannot simultaneously belong to disjoint classes, constraining the space
    of valid entity-type relationships.
- name: Class Learning from Positive/Negative Sets
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:59-70)
    quote: class learning (aka concept learning), whereby given a set of positive
      nodes and negative nodes, the goal is to find a logical class description that
      divides the positive and negative sets
  description: Entity classifications can be learned by finding relationship-based
    descriptions that distinguish positive from negative entity sets. Classes are
    defined by the patterns of relationships their members exhibit.
- name: Named Entity Recognition Relationships
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:205-210)
    quote: The NER task identifies mentions of named entities in a text, typically
      targetting mentions of people, organisations, locations, and potentially other
      types
  description: Entity extraction from text identifies typed entities (Person, Organization,
    Location) that can participate in relationships. The entity types constrain what
    relationships are applicable.
- name: Entity Linking to Knowledge Graph
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:233-240)
    quote: The EL task associates mentions of entities in a text with the existing
      nodes of a target knowledge graph, which may be the nucleus of a knowledge graph
      under creation, or an external knowledge graph
  description: Entities mentioned in text are linked to canonical entities in knowledge
    graphs, establishing identity relationships. This enables integration of relationships
    from multiple sources about the same entity.
- name: Relation Extraction Binary and N-ary
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:274-277)
    quote: The RE task extracts relations between entities in the text. The simplest
      case is that of extracting binary relations in a closed setting wherein a fixed
      set of relation types are considered
  description: Relationships are extracted between entities identified in text. Binary
    relations connect two entities; n-ary relations (like events with participants)
    involve multiple entities in structured relationships.
- name: Reification for Higher-Arity Relations
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:300-305)
    quote: an n-ary relation captures additional temporal context, denoting when Rapa
      Nui was named a World Heritage site; in this case, an anonymous node is created
      to represent the higher-arity relation in the directed-labelled graph
  description: Complex relationships involving multiple entities or contextual information
    are modeled using reification - creating intermediate nodes that have relationships
    to all participants. This enables representing events, processes, and temporal
    relationships.
- name: Direct Mapping from Tables
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:597-604)
    quote: A direct mapping automatically generates a graph from a table. creates
      an edge [x] y z for each (non-header, non-empty, non-null) cell of the table,
      such that [x] represents the row of the cell, y the column name of the cell,
      and [z] the value of the cell
  description: Tabular data maps to entity relationships where rows become entities,
    columns become relationship types, and cell values become related entities or
    values. This formalizes structured data as a relationship graph.
- name: Foreign Key as Entity Reference
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 6:615-621)
    quote: In case of a foreign key between two tables - such as Report.claimant referencing
      Claimant.id - we can link, for example, to [Claimant-XY12SDA] rather than [XY12SDA],
      where the former node also has the name and country of the claimant
  description: Database foreign keys become explicit entity relationships in knowledge
    graphs. The referential integrity constraint in relational data becomes a typed
    edge connecting two entity nodes.
- name: Ontology-Based Data Access
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 7:89-96)
    quote: The area of Ontology-Based Data Access (OBDA) is then concerned with QR
      approaches that support ontological entailments as discussed in Section 4. Although
      most QR approaches only support non-recursive entailments expressible as a single
      (non-recursive) query
  description: Entity relationships defined in ontologies enable query rewriting over
    data sources. Ontological axioms about relationships (subclass, subproperty, domain,
    range) allow inferring additional relationships during query answering.
- name: Completeness Dimensions
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 7:97-108)
    quote: 'Completeness comprises the following aspects: (i) schema completeness
      refers to the degree to which the classes and properties of a schema are represented
      in the data graph, (ii) property completeness refers to the ratio of missing
      values for a specific property'
  description: 'Entity relationship quality is measured along multiple dimensions:
    schema completeness (are all relationship types represented?), property completeness
    (are all relationships of a type populated?), population completeness (are all
    entities present?), and linkability (are entities properly connected?).'
- name: Geographic and Social Biases
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 7:126-138)
    quote: Examples of data biases include geographic biases that under-represent
      entities/relations from certain parts of the world, linguistic biases that under-represent
      multilingual resources, social biases that under-represent people of particular
      genders or races
  description: Entity relationship coverage may exhibit systematic biases - certain
    entity types, geographic regions, or demographic groups may be under-represented
    in relationships, affecting the completeness and fairness of knowledge graph applications.
- name: Consistency via Logical Entailment
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 7:168-176)
    quote: Consistency means that a knowledge graph is free of (logical/formal) contradictions
      with respect to the particular logical entailment considered. not condition
      can give rise to inconsistencies if the negated condition is entailed
  description: Entity relationships must be logically consistent - no set of relationships
    should entail contradictions. Inconsistencies arise when relationship constraints
    (like disjointness or cardinality) are violated.
- name: Shape-Based Validity Constraints
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 7:179-192)
    quote: Validity means that the knowledge graph is free of constraint violations,
      such as captured by shape expressions. We may, for example, specify a shape
      City whose target nodes have at most one country
  description: Entity-relationship validity is enforced through shape constraints
    specifying required, optional, and cardinality-restricted relationships. Shapes
    define valid relationship patterns for entity types.
- name: Node Lookup Protocol
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 8:27-38)
    quote: Protocols for performing node lookups accept a node (id) request and return
      a (sub-)graph describing that node. a common convention is to return a sub-graph
      containing either all outgoing edges for that node or all incident edges (both
      outgoing and incoming) for that node
  description: Entity access protocols return the relationship neighborhood of an
    entity - either outgoing relationships, incoming relationships, or both. This
    enables traversal-based exploration of entity relationship networks.
- name: Edge Pattern Queries
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 8:65-78)
    quote: Edge patterns - also known as triple patterns in the case of directed,
      edge-labelled graphs - are singleton graph patterns, i.e., graph patterns with
      a single edge. Examples of edge patterns are [?ff] type Food Festival or [?ff]
      location Santiago
  description: Relationships can be queried as patterns with variables for unknown
    entities. Edge patterns allow finding all entities related to known entities via
    specified relationship types, forming the basis of graph pattern matching.
- name: Join-Based Pattern Matching
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 8:101-105)
    quote: Extensions to the edge-pattern protocol have thus been proposed to allow
      for more efficient joins, such as allowing batches of solutions to be sent alongside
      the edge pattern, returning only solutions compatible with the solutions in
      the request
  description: Complex relationship queries are answered by joining multiple edge
    patterns. Joining combines relationships from different patterns where variables
    match, enabling multi-hop relationship traversal.
- name: FAIR Interoperability Principles
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 8:160-168)
    quote: Interoperability refers to the ease with which the dataset can be exploited
      (in conjunction with other datasets) using standard tools. (meta)data use an
      accessible, shared, and general knowledge representation formalism. (meta)data
      use vocabularies that follow FAIR principles
  description: Entity relationships must use shared vocabularies and formalisms to
    enable interoperability. Standardized relationship types and entity identifiers
    allow combining knowledge graphs and reasoning across sources.
- name: Linked Data Web of Data
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 8:153-174)
    quote: where one can click on a node or edge-label - or more precisely perform
      a HTTP lookup on an IRI of the graph - to be transported to another graph elsewhere
      on the Web with relevant content on that node or edge-label
  description: Entity relationships span knowledge graphs through linked data principles.
    An entity in one knowledge graph can reference entities in other graphs via IRIs,
    creating a global web of interconnected entity relationships.
- name: Link Discovery Across Graphs
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 8:205-225)
    quote: the link discovery task considers adding such links from one knowledge
      graph to another, which may involve inclusion of IRIs that dereference to external
      graphs, or links with special semantics such as identity links
  description: Entity relationships across knowledge graphs are discovered through
    link discovery - finding same-as, related-to, or other cross-graph relationships.
    This enables knowledge graph integration and federation.
- name: Goal-Dependency Edges
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 13:5-10)
    quote: Jiang and Ma (2002) introduce the notion of 'plan knowledge graphs' where
      nodes represent goals and edges dependencies between goals, further encoding
      supporting degrees that can change upon further evidence
  description: Entity relationships can model dependencies between goals. Edges encode
    prerequisite relationships where achieving one goal depends on achieving others,
    directly relevant to Goal-Task-Rule relationships in UDWO metamodel.
- name: Knowledge Flow Relationships
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 13:11-18)
    quote: Helms and Buijsrogge (2005) propose a knowledge graph to represent the
      flow of knowledge in an organisation, with nodes representing knowledge actors
      (creators, sharers, users), edges representing knowledge flow from one actor
      to another
  description: Entity relationships model knowledge transfer between agents (actors).
    Edges have properties like velocity (delay) and viscosity (depth), capturing the
    dynamics of Agent-to-Agent knowledge relationships in organizational contexts.
- name: Weighted Confidence Edges
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 13:19-23)
    quote: Kasneci et al. (2008) propose a search engine for knowledge graphs, defined
      to be weighted directed edge-labelled graphs, where weights denote confidence
      scores based on the centrality of source documents from which the edge/relation
      was extracted
  description: Entity relationships carry confidence weights indicating the reliability
    of the relationship. Edge weights can be derived from source credibility, enabling
    probabilistic reasoning over relationships.
- name: Causal and Dependency Edges
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 13:78-85)
    quote: quite a lot of the knowledge graphs defined in this period consider edges
      as denoting a form of dependence or causality, where [x] y may denote that x
      is a prerequisite for y or that x leads to y
  description: Entity relationships can represent causal and prerequisite dependencies.
    This temporal/causal semantics for edges enables reasoning about process flow,
    event sequences, and goal-subgoal hierarchies relevant to workflow ontologies.
- name: 'Category I: Entity-Relationship Definition'
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 13:127-142)
    quote: The first category simply defines the knowledge graph as a graph where
      nodes represent entities, and edges represent relationships between those entities.
      Often a directed edge-labelled graph is assumed (or analogously, a set of binary
      relations, or a set of triples)
  description: 'The foundational definition of knowledge graphs: nodes are entities,
    edges are relationships. This maps directly to the Entity concept in ontologies,
    with relationships providing structural, behavioral, and organizational connections
    between entities.'
- name: Knowledge Base Extension
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 13:205-211)
    quote: A knowledge graph acquires and integrates information into an ontology
      and applies a reasoner to derive new knowledge. a knowledge graph is distinguished
      from an ontology (considered synonymous with a knowledge base) by the provision
      of reasoning capabilities
  description: Entity relationships in knowledge graphs support inference of new relationships
    through reasoning. The relationship structure combined with ontological axioms
    enables deriving implicit relationships from explicit ones.
- name: Quotient Graph Merging
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:45-52)
    quote: a quotient graph can merge multiple nodes into one node, where the merged
      node preserves the edges of its constituent nodes. the partition V of V is often
      defined in terms of an equivalence relation on the set V
  description: Entity relationships are preserved under node merging operations. When
    entities are grouped by equivalence relations (e.g., same type), the merged node
    inherits all relationships of its constituents, enabling schema-level relationship
    views.
- name: Simulation and Bisimulation
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:77-92)
    quote: if (v, p, w) in E then there exists w' such that (v', p, w') in E' and
      (w, w') in R. If a simulation exists on G and G', we say that G' simulates G
  description: Entity relationship structures can be compared through simulation relations.
    One graph simulates another if every relationship pattern in the first can be
    matched in the second, enabling formal comparison of relationship structures.
- name: Annotated Graph Relationships
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:161-166)
    quote: we define an annotated directed-edge labelled graph G := (V, EA, L) where
      V is a set of nodes, L is a set of edge labels, and EA subset V x L x V x A
      is a set of edges annotated with values from A
  description: Entity relationships can carry annotations from structured domains
    (temporal intervals, confidence scores, provenance). This enables contextual and
    qualified relationships essential for representing events, temporal validity,
    and uncertainty.
- name: Least Model Inference
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:300-304)
    quote: 'The least model of R over G is defined as R*(G) := union of R^k(G). At
      some point R^k''(G) = R^k''+1(G): the rule applications reach a fixpoint and
      we have the least model'
  description: The complete set of inferable entity relationships is computed by repeatedly
    applying rules until no new relationships can be derived. This fixpoint computation
    yields all relationships entailed by explicit data and rules.
- name: Description Logic Relation Semantics
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:537-548)
    quote: Relation R^I (a subset of Delta^I x Delta^I). Inverse Relation R^- {(y,x)
      | (x,y) in R^I}. Universal Relation U Delta^I x Delta^I. Relation Inclusion
      R subsetOf S
  description: 'Entity relationships have formal semantics in Description Logics:
    relations are sets of entity pairs; inverses swap the pairs; relation inclusion
    models subproperty hierarchies. These semantics enable precise reasoning about
    relationship properties.'
- name: Relation Axioms in DL
  sources:
  - chunk_ref: 02-Knowledge_Graphs (Chunk 14:545-560)
    quote: Transitive Relations Trans(R). Functional Relations Func(R). Reflexive
      Relations Ref(R). Irreflexive Relations Irref(R). Symmetric Relations Sym(R).
      Asymmetric Relations Asym(R). Disjoint Relations Disj(R,S)
  description: 'Entity relationships have formal properties: transitivity (chains),
    functionality (single values), reflexivity (self-loops), symmetry (bidirectional),
    and disjointness (mutually exclusive). These axioms constrain valid relationship
    patterns.'
- name: Agent-Activity-Entity Core Triad
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:200-204)
    quote: the W3C PROV standard already defines Agent, the central abstraction in
      this work, as one of its three core classes, alongside Entity (data) and Activity
      (process)
  description: W3C PROV defines Agent, Entity, and Activity as the three core classes
    with agents representing software or human actors responsible for activities.
    This is the foundational relationship triad for provenance tracking.
- name: Agent wasAssociatedWith Activity
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:263-265)
    quote: Campaigns are associated with Person or Organization agents via wasAssociatedWith
  - chunk_ref: 03-PROV-AGENT (Chunk 1:285-287)
    quote: an AI agent can be associated with one or many tool executions (AgentTool)
      and each tool may be informed by one or many AIModelInvocations
  description: Merged from 2 sources. The wasAssociatedWith relationship links agents
    (Person, Organization) to Activities (Campaigns, Workflows). This is a core PROV
    relationship showing responsibility.
- name: Activity uses/generates Entity
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:265-267)
    quote: Tasks consume (PROV used) and produce (PROV generated) domain-specific
      data objects (DomainData)
  description: Activities (Tasks) relate to Entities through 'used' (consumes input)
    and 'generated' (produces output) relationships. This captures data flow through
    workflow processes.
- name: AIAgent extends W3C PROV Agent
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:278-280)
    quote: We extend the abstract W3C PROV Agent by modeling AIAgent as its subclass,
      enabling a natural integration of agent actions
  description: AIAgent is modeled as a subclass of the W3C PROV Agent, allowing AI
    agents to be integrated into the provenance graph alongside human agents. This
    is a structural subclass relationship.
- name: AIModelInvocation uses Prompt generates Response
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:288-292)
    quote: Each AIModelInvocation uses a Prompt and a specific AIModel...and generates
      a ResponseData object, which is attributedTo the corresponding agent
  description: AIModelInvocation uses a Prompt Entity and generates ResponseData Entity.
    The response is attributed to the agent that initiated it. This captures LLM interaction
    patterns.
- name: AgentTool wasInformedBy AIModelInvocation
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:365-367)
    quote: When a tool depends on LLM results, Flowcept establishes a wasInformedBy
      relationship from the AgentTool to the relevant AIModelInvocation activities
  description: The wasInformedBy relationship connects AgentTool executions to the
    AIModelInvocations that informed their decisions, enabling traceability of AI
    reasoning chains.
- name: Entity attributedTo Agent
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:291-292)
    quote: generates a ResponseData object, which is attributedTo the corresponding
      agent
  description: Generated data (ResponseData, Agent_Decision) is attributed to the
    Agent that produced it via the wasAttributedTo relationship, establishing accountability.
- name: Agent_Decision used by subsequent Agent_Tool
  sources:
  - chunk_ref: 03-PROV-AGENT (Chunk 1:527-529)
    quote: Agent_Decision_i is used by another Agent_Decision_i+1, the query recursively
      navigates on the used/wasGeneratedBy relationships
  description: Iterative agent decisions create chains where one decision becomes
    input to the next. This models feedback loops and cumulative reasoning in agentic
    workflows.
- name: PROV Activity equivalentClass BFO process
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:151-152)
    quote: the class PROV Activity is mapped as equivalent to the class BFO process
  description: PROV Activity is semantically equivalent to BFO process. Both represent
    things that unfold in time. This equivalence mapping enables interoperability
    between PROV and BFO ontologies.
- name: PROV Entity subClassOf BFO continuant
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:636-639)
    quote: We therefore map PROV Entity as a subclass of BFO continuant...independent
      continuants and not spatial regions, in a union with generically dependent and
      specifically dependent continuants
  description: PROV Entity maps to BFO continuant (excluding spatial regions). Entities
    persist through time with all parts present, unlike occurrents which unfold temporally.
- name: PROV Agent subClassOf BFO material entity
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:654-656)
    quote: PROV Agent is mapped as a subclass of BFO material entities that both participate
      in some PROV Activity and bear some BFO role that is realized in a PROV Activity
  description: 'PROV Agent is a material entity with two constraints: must participate
    in Activity and must bear a role realized in Activity. This captures the responsibility
    nature of agents.'
- name: Agent participates_in Activity
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:688-689)
    quote: all instances of PROV Agent are participants in some PROV Activity at some
      time
  description: The participates_in relationship connects Agent to Activity. Agents
    are defined by their participation in activities - they cannot exist as agents
    without this relationship.
- name: Agent bears Role realized_in Activity
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:662-663)
    quote: every PROV Agent participates in, and bears some role that is realized
      in, some PROV Activity
  description: Agents bear roles (specifically dependent continuants) that are realized
    through activities. The Role mediates between Agent and Activity, capturing responsibility.
- name: wasGeneratedBy subPropertyOf participates_in
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:735-738)
    quote: PROV wasGeneratedBy...is mapped as a subproperty of BFO participates in,
      whose domain and range are non-spatial region continuants and process
  description: The PROV wasGeneratedBy relationship (Entity to Activity) is subsumed
    by BFO participates_in. Entities participate in the activities that generate them.
- name: wasAssociatedWith subPropertyOf has_participant
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:758-761)
    quote: PROV wasAssociatedWith has domain PROV Activity and range PROV Agent. This...is
      mapped as a subproperty of BFO has participant
  description: wasAssociatedWith (Activity to Agent) maps to has_participant. Activities
    have agents as participants when agents are responsible for those activities.
- name: PROV Person equivalentClass intersection CCO Person and PROV Agent
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:773-776)
    quote: We map PROV Person as equivalent to the intersection of CCO Person and
      PROV Agent. This entails that every PROV Person is both a CCO Person and PROV
      Agent
  description: PROV Person requires both being a CCO Person AND being a PROV Agent.
    Not all CCO Persons are PROV Persons - only those actively acting as agents in
    provenance contexts.
- name: wasDerivedFrom subPropertyOf causally_influenced_by
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:818-821)
    quote: PROV wasDerivedFrom...with domain and range of PROV Entity...is mapped
      as a subproperty of RO causally influenced by
  description: Derivation relationships between entities (hadPrimarySource, wasQuotedFrom,
    wasRevisionOf) are all causal relationships. Entity derivation implies causal
    influence.
- name: PROV Location equivalentClass BFO site
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:808-810)
    quote: PROV Location is mapped as equivalent to BFO site, which is defined as
      a three-dimensional immaterial entity whose boundaries...coincide with...material
      entities
  description: Locations are immaterial spatial regions bounded by or relative to
    material entities. This allows both geographic and non-geographic locations (like
    database rows).
- name: atLocation maps to occurs_in and located_in
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:837-843)
    quote: PROV atLocation is mapped using SWRL rules...BFO occurs in has...domain...process
      and process boundary...BFO located in has...domain...independent continuants
  description: 'atLocation relationship splits: Activities occur_in Locations, while
    Entities/Agents are located_in Locations. Different relationship types for occurrents
    vs continuants.'
- name: PROV Influence disjoint_union BFO process and process_boundary
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:911-914)
    quote: PROV Influence, as the superclass of 16 Qualified Influence classes, is
      mapped to a subclass of the disjoint union of BFO process and BFO process boundary
  description: Influences can be either processes (extended in time) or process boundaries
    (instantaneous). Subclasses like Generation, Start, End are process boundaries;
    Communication, Derivation are processes.
- name: PROV InstantaneousEvent equivalentClass BFO process_boundary
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 1:914-916)
    quote: PROV InstantaneousEvent...is equivalently mapped to BFO process boundary
      since instances of PROV InstantaneousEvent are indivisible boundaries of some
      PROV Activity
  description: Instantaneous events (Start, End, Generation) are process boundaries
    - they mark the temporal edges of activities. They are indivisible and have no
    temporal parts.
- name: PROV Role subClassOf BFO role
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 2:103-113)
    quote: PROV Role is defined as 'the function of an entity or agent with respect
      to an activity'...we map PROV Role directly as a subclass of BFO role on the
      grounds that a PROV Role is externally determined
  description: Roles are externally determined by context, unlike functions which
    are internally determined by physical makeup. PROV Role is not equivalent to BFO
    role because it's activity-context-specific.
- name: PROV Plan subClassOf CCO Information Content Entity
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 2:116-124)
    quote: PROV Plan is mapped to a subclass of CCO Information Content Entity...it
      is a GDC because it may have multiple copies and thus does not have to depend
      on any specific bearer
  description: Plans are generically dependent continuants (information) that can
    exist in multiple copies. They are 'about' some entity (steps/actions intended
    to achieve goals).
- name: qualifiedInfluence subPropertyOf causally_related_to
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 2:149-154)
    quote: PROV qualifiedInfluence and PROV influencer are the superproperties of
      Qualification properties and Influencer properties...map them both as subproperties
      of RO causally related to
  description: All qualification and influencer properties are fundamentally causal
    relationships. The qualified pattern reifies binary influence relations for additional
    attributes.
- name: qualifiedStart/End/Usage subPropertyOf has_temporal_part
  sources:
  - chunk_ref: 04-PROV-O_to_BFO (Chunk 2:160-167)
    quote: PROV qualifiedStart, qualifiedEnd, and qualifiedUsage take PROV Activity
      as their shared domain...map them as subproperties of BFO has temporal part
  description: Start, End, and Usage events are temporal parts of Activities. Activities
    have these events as their components along the time dimension.
- name: Endurant participates_in Perdurant
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:134-137)
    quote: The relation connecting endurants and perdurants is called participation.
      An endurant can be in time by participating in a perdurant, and perdurants happen
      in time by having endurants as participants
  description: Participation is the fundamental relationship between continuants (endurants)
    and occurrents (perdurants). Endurants exist through participation; perdurants
    require participants.
- name: Quality inheres_in Endurant/Perdurant
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:168-173)
    quote: Qualities are...particulars inhering in endurants or perdurants...when
      we talk about the red of a rose, we are talking about a particular quality...which
      inheres in a particular endurant
  description: Qualities are specifically dependent particulars that inhere in their
    bearers. Each quality instance is specific to one bearer and cannot migrate to
    another.
- name: Quale locates Quality in QualitySpace
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:177-181)
    quote: A quale is the position occupied by an individual quality within a quality
      space...if the rose and the book cover exhibit the same shade of red, their
      individual colors occupy the same position (quale)
  description: Qualia enable comparison of qualities across bearers. Two distinct
    quality instances can have the same quale (position) in a quality space, allowing
    comparison and measurement.
- name: Role classifies Endurant via Classification
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:186-189)
    quote: Roles are represented as (social) concepts, which are connected to other
      entities...by the relation of classification...roles are concepts that are anti-rigid
      and founded
  description: Roles classify endurants through the Classification relation. Roles
    are anti-rigid (can be gained/lost) and founded (dependent on context and other
    roles).
- name: Part-of between Endurants (time-indexed)
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:206-207)
    quote: An important relation in DOLCE is parthood, which is time-indexed when
      connecting endurants and a-temporal when holding between perdurants
  description: Parthood is time-indexed for endurants (parts can change over time)
    but atemporal for perdurants (their temporal structure is fixed once complete).
- name: Constitution relates different-category entities
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:208-213)
    quote: Constitution is another temporalized relation in DOLCE...often used to
      single out entities that are spatio-temporally co-located but...distinguishable
      for their histories, persistence conditions, or relational properties
  description: Constitution relates entities of different categories (e.g., statue
    and matter) that share location but have different identity conditions. It's asymmetric
    and co-temporal.
- name: Physical Quality inheres_in Physical Endurant
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:344-346)
    quote: PQ(x) -> exists!y (qt(x,y) ^ PED(x)) (Physical quality)
  description: Physical qualities inhere in exactly one physical endurant. Each quality
    type (physical, temporal, abstract) has a specific category of bearer.
- name: PC(x,y,t) Participation typing
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:366-376)
    quote: PC(x,y,t) -> ED(x) ^ PD(y) ^ T(t) (Participation typing)...PD(x) ^ PRE(x,t)
      -> exists y (PC(y,x,t))...ED(x) -> exists y,t (PC(x,y,t))
  description: Participation relates endurants to perdurants at times. Every perdurant
    has at least one participant when present; every endurant participates in at least
    one perdurant during its existence.
- name: Constitution K(x,y,t) between same-level entities
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:390-396)
    quote: K(x,y,t) -> ((ED(x) v PD(x)) ^ (ED(y) v PD(y)) ^ T(t))...K(x,y,t) -> (PED(x)
      <-> PED(y))...K(x,y,t) -> not K(y,x,t)
  description: Constitution relates endurants to endurants or perdurants to perdurants
    (not cross-category). Physical endurants only constitute physical endurants. Asymmetric
    relation.
- name: CF(x,y,t) Classification between Endurant and Concept
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:411-415)
    quote: CF(x,y,t) -> ED(x) ^ C(y) ^ T(t)...CF(x,y,t) -> PRE(x,t)...CF(x,y,t) ->
      not CF(y,x,t)
  description: Classification relates endurants to concepts at times. Requires endurant
    to be present, is asymmetric, and concepts can classify concepts but not what
    those classify (no circularity).
- name: Composition (parthood within category)
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:487-497)
    quote: constitution connects elements belonging to distinct categories...The composition
      relation (expressed in DOLCE by parthood restricted to the category at stake)
      holds instead among elements of the same category
  description: Composition (parthood) relates same-category entities forming a whole;
    constitution relates different-category entities that are co-located. Both capture
    different dependence types.
- name: Functional Role has single classifier at time
  sources:
  - chunk_ref: 05-DOLCE (Chunk 1:777)
    quote: Funct_RL(y) ^ CF(x,y,t) ^ CF(x',y,t) -> x = x'
  description: A functional role can classify only one entity at each time. This distinguishes
    functional roles (teacher) from non-functional roles (student) where multiple
    entities can hold the role.
- name: ExecutesPlan relates Perdurant to Concept
  sources:
  - chunk_ref: 05-DOLCE (Chunk 2:208-211)
    quote: ExecutesPlan(x,y) -> PD(x) ^ C(y)...ExecutesPlan to connect a perdurant
      to a plan. This relation is used to state that an event complies with the plan
      requirements
  description: Events can execute plans (concepts), even partially. An event that
    takes a person to point A executes the plan to go A then B, even without completing
    it.
- name: Constant Participation PCC(x,y)
  sources:
  - chunk_ref: 05-DOLCE (Chunk 2:145-150)
    quote: e = e1 + e2 + e3 ^ PCC(p,e)...p constantly participates in the perdurant
      e which is the sum of the perdurants e1, e2, e3
  description: Constant participation means an endurant participates in a perdurant
    throughout its entire duration. Used for modeling continuous involvement across
    event phases.
- name: SpeedQuality quale changes during SpeedUp
  sources:
  - chunk_ref: 05-DOLCE (Chunk 2:174-180)
    quote: qt(s,x) ^ SpeedUp(x) -> exists li,lj,ti,tj (P(ti,tx) ^ P(tj,tx) ^ ql(li,s,ti)
      ^ ql(lj,s,tj) ^ li != lj)
  description: Speeding up events are characterized by quality change - the speed
    quale must be different at different times within the event. Contrasts with stable
    qualities during walking/running.
- name: Legal Marriage classifies Social Marriage
  sources:
  - chunk_ref: 05-DOLCE (Chunk 2:400-407)
    quote: CF(sm,M,t) -> CF(lm,M,t) ^ CF(sm,M,t') -> CF(lm',M,t')...The same concept
      of social marriage (sm) persists through time, from t to t' while changing its
      legal characterization
  description: Social concepts can persist while their legal characterizations change.
    If social marriage classifies M at t, then the current legal marriage concept
    must also classify M. Concepts can evolve.
- name: Realizable Entity inheres_in Independent Continuant
  sources:
  - chunk_ref: 06-BFO_Function_Role_Disposition (Chunk 1:241-243)
    quote: A realizable entity is defined as a specifically dependent continuant that
      has an independent continuant entity as its bearer, and whose instances can
      be realized...in associated processes
  description: Functions, roles, dispositions, capabilities are realizable entities
    that inhere in independent continuants (objects). They are specifically dependent
    - cannot migrate between bearers.
- name: Realizable Entity realized_in Process
  sources:
  - chunk_ref: 06-BFO_Function_Role_Disposition (Chunk 1:222-233)
    quote: a screwdriver's function is realized in the actual process of turning a
      screw...the Waterford crystal's fragile disposition is realized as it smashes
      on the floor
  description: Realizable entities (functions, roles, dispositions) are manifested
    through processes in which their bearers participate. The realization is a process,
    not the realizable itself.
- name: Role is externally-grounded
  sources:
  - chunk_ref: 06-BFO_Function_Role_Disposition (Chunk 1:269-275)
    quote: A role is a realizable entity which exists because the bearer is in some
      special physical, social, or institutional set of circumstances...not such that,
      if it ceases to exist, then the physical make-up of the bearer is thereby changed
  description: Roles are extrinsic/externally-grounded - they exist due to external
    circumstances, not the bearer's physical makeup. Losing a role does not physically
    change the bearer.
- name: Disposition is internally-grounded
  sources:
  - chunk_ref: 06-BFO_Function_Role_Disposition (Chunk 1:333-339)
    quote: A disposition is a realizable entity which is such that, if it ceases to
      exist, then its bearer is physically changed...Unlike roles, dispositions are
      not optional
  description: Dispositions are intrinsic/internally-grounded - they reflect the bearer's
    physical makeup. If a disposition is lost, the bearer has physically changed.
- name: Function is Disposition with evolutionary/design origin
  sources:
  - chunk_ref: 06-BFO_Function_Role_Disposition (Chunk 1:385-388)
    quote: A function is a disposition that exists in virtue of the bearer's physical
      make-up, and this physical make-up is something the bearer possesses because
      it came into being, either through evolution...or through intentional design
  description: Functions are a special kind of disposition - they require an origin
    story (evolution or design) that explains why the bearer has the physical makeup
    enabling the function.
- name: Biological Function borne by organism part
  sources:
  - chunk_ref: 06-BFO_Function_Role_Disposition (Chunk 1:449-455)
    quote: A biological function is a function whose bearer is part of an organism,
      and that bearer's existence and physical make-up is due to having evolved in
      a way that contributes to the organism's fulfillment
  description: Biological functions are attributed to parts of organisms, not whole
    organisms. Hearts have functions; organisms have roles. This captures the proper
    level of functional attribution.
- name: having role vs playing role distinction
  sources:
  - chunk_ref: 06-BFO_Function_Role_Disposition (Chunk 1:309-311)
    quote: There is also a distinction between having a role and playing a role. An
      entity can play a role, as when a passenger plays the role of a pilot...but
      neither the person nor the pyramidal neuron have those roles
  description: Playing a role is temporary/contextual; having a role implies genuine
    bearer status. A passenger playing pilot doesn't have the pilot role. This distinguishes
    temporary performance from role bearing.
- name: Role has input/output distinction
  sources:
  - chunk_ref: 06-BFO_Function_Role_Disposition (Chunk 1:289-292)
    quote: there are therapeutic and prophylactic roles, and input and output roles.
      For example, the primary functionor input roleof mitochondria is to produce
      ATP...these same mitochondria play an output role in Alzheimer's disease
  description: The same entity can play different roles in different causal contexts.
    Mitochondria have an input role (ATP production) and can have an output role (oxidative
    stress causing disease).
- name: is_a Subtype Relation
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:104-106)
    quote: the most important (illustrated in Figure 1) are is_a (abbreviating 'is
      a subtype of') and part_of
  description: BFO uses is_a as the primary hierarchical relationship between types/universals.
    When two nodes are joined by is_a, it represents that all instances of the first
    type are also instances of the second type. This is a fundamental structural relationship
    in ontology graphs.
- name: part_of Mereological Relation
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:135-147)
    quote: When two nodes are joined together by the part_of relation... this represents
      an assertion to the effect that every instance of the first type is a part of
      some instance of the second type
  description: BFO's part_of relation holds between instances at the particular level,
    representing mereological composition. Distinguished between types and instances
    - the type-level relation implies an instance-level parthood relation.
- name: Continuant-Occurrent Categorical Division
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:430-440)
    quote: The distinction between continuants and occurrents is for BFO categorical.
      All the parts of continuants are continuants, and any whole to which a continuant
      belongs is also a continuant
  description: BFO enforces strict categorical separation between continuants (3D
    entities existing wholly at any time) and occurrents (4D entities that unfold
    in time). Parthood relations are constrained within each category - no cross-category
    parts allowed.
- name: Participation Relation (Continuant-Occurrent Bridge)
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:437-440)
    quote: Certainly there are manifold connections between continuants and occurrents,
      but they are secured in BFO not through parthood relations, but rather through
      relations of participation
  description: BFO uses participation as the key relation connecting continuants and
    occurrents. Continuants participate in occurrents - this bridges the categorical
    divide without violating the parthood constraint.
- name: Bearer-Quality Dependence
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:498-500)
    quote: They are entities which are dependent on the independent continuant entities
      (such as molecules, organisms, planets) which are their bearers
  description: Qualities in BFO are specifically dependent on their bearers (independent
    continuants). This dependence relationship is fundamental - qualities cannot exist
    without their bearers.
- name: Determinable-Determinate Quality Hierarchy
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:500-502)
    quote: Qualities instantiate quality universals, which are divided into determinable
      (such as temperature, length and mass) and determinate (such as 37.0C temperature,
      1.6 meter length)
  description: Quality universals are organized in a determinable-determinate hierarchy.
    Determinable universals (like temperature) are rigid - if exemplified at any time,
    exemplified at every time the bearer exists. Determinates are specific values
    under determinables.
- name: Process-Participant Specific Dependence
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:847-852)
    quote: Processes themselves stand to the independent continuants which are their
      participants in a relation that is analogous to that in which qualities stand
      to the independent continuants which are their bearers. In both cases we have
      to deal with the relation of what BFO calls specific dependence
  description: Processes are specifically dependent on their participants (independent
    continuants). This is analogous to quality-bearer dependence but in the occurrent
    realm. Processes depend on participants for existence.
- name: Temporal Part Relation
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:574-593)
    quote: a temporal_part_of b =Def. a occurrent_part_of b & for some temporal region
      r (a spans r...
  description: BFO defines temporal parthood for occurrents as a restriction of occurrent
    parthood to a temporal region. First quarter of a game is temporal part of whole
    game. Distinguished from mere occurrent parts that don't fill entire temporal
    slice.
- name: Occupies Relation (Process-Spatiotemporal Region)
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:549-552)
    quote: BFO uses 'occupies' to refer to the relation that holds between an occurrent
      and the spatiotemporal region which it exactly fills
  description: Processes occupy spatiotemporal regions - the occupies relation links
    occurrents to their spatiotemporal extension. This is distinct from continuants
    which exist at spatial regions at times.
- name: Spans Relation (Process-Temporal Region)
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:549-563)
    quote: Processes and process boundaries occupy spatiotemporal regions and they
      span temporal intervals and temporal instants, respectively
  description: Processes span temporal intervals while process boundaries span temporal
    instants. The spans relation connects occurrents to their temporal projections.
- name: Instance-Universal Instantiation
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 1:789-801)
    quote: motion p instance_of universal motion with speed v... where the universal
      motion with speed v is a specification of the universal motion
  description: BFO uses instantiation as the relation between particulars and their
    universals. Process attributions are treated in terms of instantiation rather
    than qualities - a motion instantiates the universal 'motion with speed v'.
- name: Process Profile Comparison Dimension
  sources:
  - chunk_ref: 07-Classifying_Processes_Barry_Smith (Chunk 2:119-125)
    quote: When comparing two heart beating processes as being for example of the
      same rate... there is something in each of the two processes which is not numerically
      but qualitatively 'the same'. This something which the two processes share in
      common we shall refer to as a process profile
  description: Process profiles are shareable aspects of processes along specific
    dimensions of comparison (rate, speed, etc.). Two processes can share the same
    process profile universal even though numerically distinct.
- name: Event-to-Object (E2O) Relationship
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 1:178-185)
    quote: 'Event-to-Object (E2O) Relationships: Events are associated with objects.
      This relationship describes that an object affects an event or that an event
      affects an object... events can be related to multiple objects'
  description: OCEL 2.0 defines E2O as many-to-many relationships between events and
    objects. Unlike traditional logs where events relate to single cases, E2O allows
    events to relate to multiple objects of different types. Relationships can be
    qualified to describe the role an object plays.
- name: Object-to-Object (O2O) Relationship
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 1:191-194)
    quote: 'Object-to-Object (O2O) Relationships: Objects can also be related to other
      objects outside the context of an event. For example, an employee may be part
      of an organizational unit'
  description: OCEL 2.0 introduces O2O relationships to capture structural relationships
    between objects independent of events. These can be qualified with relationship
    types like part-of, reports-to, or belongs-to.
- name: Event Type Assignment
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 1:408)
    quote: 'evtype: E -> U_etype assigns types to events'
  description: Every event is assigned exactly one event type (activity) via the evtype
    function. This is a many-to-one relationship from events to event types.
- name: Object Type Assignment
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 1:424)
    quote: 'objtype: O -> U_otype assigns types to objects'
  description: Every object is assigned exactly one object type via the objtype function.
    This is a many-to-one relationship from objects to object types.
- name: Qualified E2O Relationship
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 1:306-308)
    quote: E2O relationship qualifiers describe in which role an object takes part
      in an event, while O2O relationship qualifiers can further characterize the
      association between two objects
  description: OCEL 2.0 enriches relationships with qualifiers. E2O qualifiers describe
    object roles in events (e.g., organizer vs participant). O2O qualifiers characterize
    object associations (e.g., part-of, reports-to).
- name: Event Attribute Type Mapping
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 1:416-417)
    quote: 'eatype: EA -> U_etype assigns event types to event attributes'
  description: Event attributes are scoped to specific event types via eatype function.
    An attribute is only valid for events of the corresponding type, ensuring type-consistent
    attribute assignments.
- name: Object Attribute Type Mapping
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 1:430)
    quote: 'oatype: OA -> U_otype assigns object types to object attributes'
  description: Object attributes are scoped to specific object types via oatype function.
    This ensures attributes are only assigned to objects of appropriate types.
- name: Dynamic Object Attribute Values (Temporal)
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 1:293-297)
    quote: OCEL 2.0 adopts a dynamic approach where attribute values can change over
      time. Instead of having a single, fixed value, an object attribute may have
      a value that changes during the process
  description: OCEL 2.0 introduces temporal relationships for object attributes -
    attribute values are indexed by time, allowing tracking of object state changes
    throughout process execution.
- name: Foreign Key Event-Object Relationship
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 2:276-283)
    quote: The event_object table contains the event-to-object relationships (E2O
      in Definition 2). Therefore, it contains the correlated event identifier and
      object identifier (foreign key to event.ocel_id and object.ocel_id respectively)
      with a qualifier
  description: In relational implementation, E2O relationships are captured via a
    junction table with foreign keys to both event and object tables plus a qualifier
    column. Primary key spans all three columns to prevent duplicates.
- name: Foreign Key Object-Object Relationship
  sources:
  - chunk_ref: 09-OCEL_20_Specification (Chunk 2:319-325)
    quote: The object_object table contains the object-to-object relationships (O2O
      in Definition 2). Therefore, it contains the correlated object identifiers (source
      and target; both are foreign keys to object.ocel_id) with a qualifier
  description: O2O relationships stored in junction table with source and target object
    foreign keys plus qualifier. Same object pair can have multiple qualified relationships.
- name: Event-Object Many-to-Many Mapping
  sources:
  - chunk_ref: 10-OC-PM_Object-Centric_Process_Mining (Chunk 1:502-505)
    quote: 'pi_omap: E -> P(O) is the function associating an event (identifier) to
      a set of related object identifiers. Example: the first event in Table 1 is
      related to three objects pi_omap(e1) = {o1, i1, i2}'
  description: Object-centric event logs define pi_omap function mapping each event
    to a set of related objects. This is the formal basis for many-to-many event-object
    relationships, distinguishing OCEL from case-centric logs.
- name: Object Type Partitioning
  sources:
  - chunk_ref: 10-OC-PM_Object-Centric_Process_Mining (Chunk 1:510-512)
    quote: 'pi_otyp in O -> OT assigns precisely one object type to each object identifier.
      Example: for the first object in Table 2, pi_otyp(o1) = order'
  description: Every object has exactly one type, creating a partition of the object
    set by type. This type assignment is fundamental for flattening operations and
    object lifecycle analysis.
- name: Object Lifecycle (Event Sequence)
  sources:
  - chunk_ref: 10-OC-PM_Object-Centric_Process_Mining (Chunk 1:609-611)
    quote: 'The lifecycle of an object o in O as the sequence of events to which the
      object is related: lif(o) = case_FL(L,pi_otyp(o))(o)'
  description: An object's lifecycle is defined as the ordered sequence of events
    it participates in. This temporal relationship sequence captures how an object
    evolves through the process.
- name: Object Trace (Activity Sequence)
  sources:
  - chunk_ref: 10-OC-PM_Object-Centric_Process_Mining (Chunk 1:613-614)
    quote: 'The trace of an object o in O as the sequence of activities of the events
      belonging to its lifecycle: trace(o) = trace_FL(L,pi_otyp(o))(o)'
  description: Object trace is the sequence of activities from lifecycle events, abstracting
    from specific event instances to activity types. Enables comparison of object
    behaviors.
- name: Object Start/End Activity Relationships
  sources:
  - chunk_ref: 10-OC-PM_Object-Centric_Process_Mining (Chunk 1:616-620)
    quote: 'The start activity of an object o in O as the first activity of its trace:
      start(o)... The end activity of an object o in O as the last activity of its
      trace: end(o)'
  description: Objects have distinguished start and end activities marking lifecycle
    boundaries. These are used for identifying incomplete/improperly terminated objects
    and process endpoints.
- name: Object-Centric Directly-Follows Typed Edge
  sources:
  - chunk_ref: 10-OC-PM_Object-Centric_Process_Mining (Chunk 1:781)
    quote: F subset of N x OT x N is a set of typed arcs
  description: OC-DFG edges are typed by object type. An arc (n1, ot, n2) indicates
    activities n1 and n2 are directly-follows for object type ot. Enables multi-perspective
    process models.
- name: Flattening Transformation
  sources:
  - chunk_ref: 10-OC-PM_Object-Centric_Process_Mining (Chunk 1:582-597)
    quote: FL(L, ot) = (E^ot, pi_act^ot, pi_time^ot, pi_case^ot, <=^ot) where E^ot
      = {e in E | exists o in O pi_otyp(o) = ot and o in pi_omap(e)}
  description: Flattening transforms object-centric log to traditional log by selecting
    an object type as case notion. Events are filtered to those involving objects
    of chosen type, and cases are defined by object identifiers.
- name: Entity Correlation Relationship
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:265-269)
    quote: Event e is correlated to entity n, written (e,n) in corr_ent,T iff n =
      e.ent or n in e.ent. We write corr(n, ent, T) = {e in E | (e,n) in corr_ent,T}
  - chunk_ref: 15-SciAgents (Chunk 4:108-111)
    quote: 'Biological materials -- can be integrated -- novel functionalities: Biological
      materials can be engineered or combined with other materials to introduce novel
      functionalities'
  description: Merged from 2 sources. Correlation is the formal relationship between
    events and entities. An event is correlated to entity n if n appears in the entity
    attribute. This is the foundation for local directly-follows relations.
- name: Entity-to-Entity Relation Inference
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:293-297)
    quote: A record e in Table 1 containing two identifiers n1, n2 of two different
      types implicitly relates n1 and n2... We can write this as a relation R(Invoice,Order)
      = {(O1, I1), (O2, I2)}
  description: Relations between entity types are inferred from event data when events
    contain multiple entity identifiers. Co-occurrence of identifiers in events implies
    relationship between those entities.
- name: Relation Cardinality (1-to-1, n-to-1, n-to-m)
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:307-322)
    quote: each relation R(ent1,ent2) has a cardinality describing how many entities
      of type ent1 are related to each entity of type ent2... R(Invoice,Order) is
      a 1-to-1 relation... R(Item,Order) is an n-to-1 relation
  description: Entity relations have cardinalities inferred from data - 1-to-1, n-to-1,
    or n-to-m. Cardinality affects how behavior is structured when flattening and
    can cause convergence/divergence issues.
- name: Transitive Entity Relation
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:325-329)
    quote: Entities are also transitively related by concatenating or joining the
      relations on a shared entity type... R(Order,Payment) = R(Invoice,Order) join
      R(Invoice,Payment)
  description: Entity relations compose transitively via join operations. Order relates
    to Payment through Invoice. This enables computing case entities for complex multi-entity
    processes.
- name: Local Directly-Follows (Per Entity)
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:519-529)
    quote: e2 directly follows e1 from the perspective of n, written e1 <n,T e2 iff
      (e1,n),(e2,n) in corr_ent,T (both are correlated to n), e1.time < e2.time (e1
      occurred before e2), and there is no other event...
  description: Directly-follows is defined locally per entity rather than globally.
    e2 follows e1 from n's perspective only if both are correlated to n and no intervening
    event exists for n. Foundation for event knowledge graphs.
- name: Labeled Property Graph Node Label
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:579)
    quote: Each node n in N carries a label lambda(n) in Lambda_N
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:580-581)
    quote: Each relationship r in R carries a label lambda(r) in Lambda_R and defines
      a directed edge r_arrow = (n_source, n_target)
  description: Merged from 2 sources. In labeled property graphs, every node has a
    type label (Event, Entity). This enables typed graph traversal and distinguishing
    events from entities structurally.
- name: Event-Entity Correlation Relationship (Graph)
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:633-635)
    quote: Every correlation relationship r in R[corr], r_arrow = (e,n) is defined
      from an event node to an entity node, e in N[Event], n in N[Entity]; we write
      n in corr(e) and e in corr(n)
  description: In event knowledge graphs, correlation is a directed relationship type
    from events to entities. Enables bidirectional lookup - entities correlated to
    event and events correlated to entity.
- name: Directly-Follows Relationship with Entity Reference
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:636-642)
    quote: Any directly-follows relationship df in R[df], df_arrow = (e1, e2) is defined
      between event nodes e1, e2 in N[Event] and refers to a specific entity df.ent
      = n in N[Entity]
  description: DF relationships in event knowledge graphs carry entity reference as
    property. This enables multi-dimensional behavior analysis - same event pair may
    have DF relationships for different entities.
- name: DF-Path for Entity
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:668-670)
    quote: A path r = <r1,...,rk> in (R[df])* of df-relationships is a directly-follows
      path (df-path) iff all relationships are defined for the same entity, i.e.,
      for all 1<=i<k, ri.ent = ri+1.ent = n
  description: A DF-path is a sequence of DF-relationships all for the same entity.
    Corresponds to a trace in classical event logs but allows paths to meet at events
    correlated to multiple entities.
- name: Derived Entity from Relation Reification
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:893-898)
    quote: We reify the relation between two entity types ent1 and ent2 into a new
      derived entity type (ent1, ent2). That is, we make each pair (n1, n2) in R[related]
      an entity node (n1, n2) in N[Entity]
  description: Relations between entities can be reified into derived entity nodes.
    This enables inferring DF-relationships for entity interactions (e.g., Order-Payment)
    that cross entity boundaries.
- name: Derived Relationship Traceability
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 1:897-898)
    quote: For traceability, we add a new relationship d in R[derived] with label
      derived from entity (n1, n2) to n1 and to n2
  description: Derived entities link back to their source entities via derived relationships.
    Maintains provenance of reified relationships for tracing entity interactions.
- name: Entity-to-Entity Derived Relationship via Reification
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:3-12)
    quote: Then we can treat any derived entity (n1, n2) just like any other entity
      and infer the df-relationships for (n1, n2)
  description: Describes how relationships between entities can be reified into derived
    entities, creating new entity types that capture interactions. This enables inferring
    directly-follows relationships that describe cross-entity behavior, turning structural
    relations into behavioral ones.
- name: Directly-Follows Relationship for Entity Paths
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:54-58)
    quote: construct entities and correlation based on the presence of an entity identifier
      or a relation; and derive a local directly-follows relation from the viewpoint
      of each entity
  description: The df-relationship connects events from the perspective of each entity.
    Events are correlated to entities, and temporal ordering is inferred per entity
    rather than globally, enabling multi-perspective behavioral analysis.
- name: Entity-Event Correlation Relationship
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:265-271)
    quote: We select a subset of entities, but keep all event nodes correlated to
      the entities and all directly-follows relations between the events of these
      entities
  description: Entities are correlated to events through explicit 'corr' relationships.
    This entity-event correlation is fundamental to event knowledge graphs, enabling
    filtering and selection operations based on entity types.
- name: Event Synchronization Between Entities
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:155-161)
    quote: Two or more entities n1,...,nk synchronize in a shared event e if two or
      more df-paths of n1,...,nk go through e
  description: Entities synchronize when their df-paths meet at the same event. This
    synchronization relationship captures how different entities interact through
    shared activities, representing a fundamental coordination pattern.
- name: Entity Creation Relationship via Starting Event
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:169-173)
    quote: An event e that is intermediate for one entity n but a starting event for
      entities n1,...,nk can be interpreted as entity n 'created' or 'initiated' entities
      n1,...,nk
  description: Entity creation relationships are inferred when one entity's intermediate
    event is another entity's starting event. This captures lifecycle relationships
    like 'Supplier Order A created Items X1, X2, X3'.
- name: Entity Completion Relationship via Ending Event
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:172-173)
    quote: an event e that is intermediate for entity n and ending event for n1,...,nk
      is 'closing' or 'completing' entities n1,...,nk
  description: 'Completion relationships are inferred when one entity''s intermediate
    event is another entity''s ending event. Example: Order O1 ''completes'' items
    X1, X2, Y1 when Pack Shipment occurs.'
- name: Batching Relationship Between Same-Type Entities
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:174-176)
    quote: An event e where multiple entities n1,...,nk of the same type synchronize
      is a batching event for n1,...,nk
  description: Batching relationships occur when multiple entities of the same type
    synchronize in a shared event. This captures batch processing patterns where items
    are processed together.
- name: Synchronous Interaction Between Entities
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:196-199)
    quote: An event e where the df-paths of n1 and n2 synchronize is a synchronous
      interaction. A df-path for entity n describes an asynchronous interaction between
      n1 and n2
  description: Distinguishes synchronous interactions (entities meet at same event)
    from asynchronous interactions (entities communicate via intermediate entity).
    These are fundamental coordination patterns.
- name: Asynchronous Message-Passing Relationship
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:199-202)
    quote: If the df-path for n has only 2 events <e1, e2> then we can interpret entity
      n as message from n1 to n2
  description: An entity with only two events on its df-path can be interpreted as
    a message passing from one entity to another. This models asynchronous communication
    patterns between process participants.
- name: Handover Relationship Between Entities
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:201-205)
    quote: We can interpret an event e that is the ending event of entity n1 and the
      starting event of entity n2 as a handover from n1 to n2
  description: 'Handover relationships capture work transfer between entities when
    one entity''s ending event is another''s starting event. Example: ''O1 hands over
    to (O1,P1)'' at event e28.'
- name: Entity Delay Dependency Relationship
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:232-241)
    quote: Event e directly depends on any event ei that directly precedes e via an
      incoming df-relationship... The entity ni, for which (ei,e) was observed, was
      the first entity ready to synchronize in e
  description: Delay dependencies capture which entities delayed synchronization.
    When multiple entities must synchronize, the entity whose preceding event occurred
    last is identified as causing the delay.
- name: Actor-Entity Work Pattern Relationship
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:598-604)
    quote: We prefer the term Actor used in organizations research, as each actor
      follows its own behavior. To study actor behavior... we only have to (1) infer
      the Actor entities from the event nodes, and (2) infer each actor's df-path
  description: Actors (resources/workers) are modeled as entities whose df-paths describe
    their work patterns. This enables analysis of how actors perform tasks across
    multiple other entities.
- name: Task Instance as Actor-Entity Subgraph
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:621-627)
    quote: A task instance of an actor R working on an entity X materializes in an
      event knowledge graph as a specific subgraph over event nodes e1,...,ek
  description: Task instances are subgraphs where actor and entity df-paths synchronize
    over consecutive events. This captures units of work where an actor performs multiple
    related activities on an entity.
- name: Entity-to-Activity Queue Relationship
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:510-517)
    quote: The space between two work stations A and B is a queue A:B, i.e., the space
      where Items after being worked on at A wait until being worked on at B
  description: Queues emerge as relationships between Activity entities, representing
    waiting spaces where other entities pause between processing at different work
    stations.
- name: Contains Relationship for Aggregation
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:714-716)
    quote: We add a new contains relationship (ti,e) from each TaskInstance node ti
      to each Event node e that is part of the task instance
  description: The 'contains' relationship links higher-level aggregated nodes (like
    TaskInstances) to the events they encompass, enabling hierarchical process analysis.
- name: Observes Relationship for Classification
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:337-338)
    quote: We add an observes relationship from each event e to the Class node c if
      e.Activity = c
  description: The 'observes' relationship connects events to activity class nodes,
    enabling aggregation of events into activity types for process discovery.
- name: Synchronization Edge in Proclet Models
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 2:888-890)
    quote: Dashed synchronization edges between transitions describe that the transitions
      have to occur together; the multiplicity annotations indicate how many entities
      of each type have to be involved
  description: 'Synchronization edges in proclet models explicitly capture cardinality
    constraints between entity types during synchronized activities. Example: R4 packs
    2-3 Items into 1 Shipment.'
- name: Object-Centric Petri Net Entity Composition
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 3:17-23)
    quote: Object-centric Petri nets also first discover one Petri net per entity
      type, then annotate the places and arcs with entity identifiers, and then compose
      all entity nets along transitions for the same activity
  description: Entity relationships in object-centric Petri nets are captured through
    composition along shared activities. Entity nets are composed at transitions where
    multiple entity types participate together.
- name: Entity Interaction Relationship via Proclets
  sources:
  - chunk_ref: 11-Process_Mining_Event_Knowledge_Graphs (Chunk 3:22-23)
    quote: synchronization by composition prevents explicitly modeling (and thus discovering)
      interactions between entities such as the relation from Order to Payment described
      by proclet (Order,Payment)
  description: Some entity relationships (like Order-Payment interactions) require
    explicit modeling beyond simple composition. Derived entity types like (Order,Payment)
    capture complex inter-entity behavior patterns.
- name: Event-to-Case Correlation via Case ID
  sources:
  - chunk_ref: 12-Foundations_of_Process_Event_Data (Chunk 1:68-75)
    quote: each event should be linked to a case or process instance, typically by
      using a Case ID. This is 'Requirement 1'... Events will be collected for every
      process instance
  description: The fundamental relationship connecting events to cases/process instances.
    Case IDs enable grouping events into coherent process executions, essential for
    process mining analysis.
- name: Event-to-Activity Mapping Relationship
  sources:
  - chunk_ref: 12-Foundations_of_Process_Event_Data (Chunk 1:92-95)
    quote: each event should correspond to an activity executed within the process.
      More specifically, an assumption is made that there exists a restricted set
      of labels, reflecting the activities in the business process
  description: Events are mapped to activities through activity labels, establishing
    the relationship between observed events and the business activities they represent.
- name: Temporal Ordering Relationship Between Events
  sources:
  - chunk_ref: 12-Foundations_of_Process_Event_Data (Chunk 1:110-116)
    quote: the last requirement entails that there exists an ordering of the events
      pertaining to a case. As such, each case logically consists of a sequence of
      events
  description: Events within a case have temporal ordering relationships derived from
    timestamps, establishing the sequence in which activities occurred within process
    instances.
- name: Event-to-Trace Containment
  sources:
  - chunk_ref: 12-Foundations_of_Process_Event_Data (Chunk 1:167-170)
    quote: In IEEE XES, events are considered as an observed atomic granule of activity.
      Next to events, IEEE XES specifies the concept of a log, a trace, and an attribute
      component
  description: 'XES defines hierarchical containment: logs contain traces, traces
    contain events. This establishes the structural relationships between process
    artifacts.'
- name: Activity Lifecycle Transitions
  sources:
  - chunk_ref: 12-Foundations_of_Process_Event_Data (Chunk 1:181-186)
    quote: events oftentimes relate to the transactional lifecycle that activities
      undergo. One example of such a transactional lifecycle model is shown... Such
      a transactional lifecycle model describes the states and state transitions
  description: Activities have lifecycle states (start, complete, suspend, etc.) with
    defined transitions. Events capture these state changes, establishing temporal
    relationships within activity executions.
- name: Event Correlation via Attribute Matching
  sources:
  - chunk_ref: 12-Foundations_of_Process_Event_Data (Chunk 1:453-459)
    quote: Mapping event data extracted from source systems and databases to cases...
      In cases where event data is obtained but Case IDs are missing... using additional
      event data attributes, sometimes aided by a conceptual model or even a process
      model
  description: Event correlation techniques establish relationships between events
    and cases using shared attributes, conceptual models, or process models when explicit
    Case IDs are unavailable.
- name: Object-Centric Event-to-Object Relationship
  sources:
  - chunk_ref: 12-Foundations_of_Process_Event_Data (Chunk 1:424-433)
    quote: Many source systems, including popular ERP systems, store data at the logical
      level of objects instead of providing a true process perspective... object or
      artifact centricity
  description: In object-centric approaches, events relate to multiple objects rather
    than single cases. The OCEL standard enables representing events with connections
    to multiple case notions.
- name: Event Abstraction Aggregation Relationship
  sources:
  - chunk_ref: 12-Foundations_of_Process_Event_Data (Chunk 1:476-481)
    quote: abstraction techniques can be considered as mapping techniques that can
      translate one or more lower-level events into higher-level events pertaining
      to business process activities
  description: Event abstraction creates aggregation relationships, mapping multiple
    low-level events to single high-level activity events, enabling analysis at appropriate
    granularity levels.
- name: Knowledge Graph Node-Edge Relationships
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:108-110)
    quote: knowledge graphs not only provide a mechanistic breakdown of information
      but also offer an ontological framework that elucidates the interconnectedness
      of different concepts, delineated as nodes and edges within the graph
  description: Knowledge graphs represent entities as nodes and their relationships
    as edges, creating an interconnected network of concepts. This forms the foundation
    for ontological reasoning and discovery.
- name: Path-Based Concept Connection
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:276-280)
    quote: silk --> provides --> biocompatibility --> possess --> biological materials
      --> has --> multifunctionality --> include --> self-cleaning
  description: Paths through knowledge graphs connect concepts via typed relationships
    (provides, possess, has, include). These paths reveal hidden interdisciplinary
    connections between seemingly unrelated concepts.
- name: Agent-to-Agent Collaborative Relationships
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:126-130)
    quote: Each agent in the system is assigned a distinct role, optimized through
      complex prompting strategies... This strategic division of labor allows the
      AI system to proficiently manage the complexities
  description: Multi-agent systems establish collaborative relationships where agents
    with distinct roles work together. Relationships include task delegation, information
    exchange, and critique feedback loops.
- name: Ontologist-Scientist Knowledge Transfer
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:289-296)
    quote: Utilizing our LLM-powered ontologist agent, we move deeper into the intricacies
      of the relationships that have been mapped out... the agent helps transition
      from static knowledge retrieval to dynamic knowledge generation
  description: The Ontologist agent processes knowledge graph relationships and transfers
    refined understanding to Scientist agents, establishing a knowledge flow relationship
    in the multi-agent architecture.
- name: Scientist-Critic Review Relationship
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:511-516)
    quote: the Critic agent, responsible for thoroughly reviewing the research proposal,
      summarizing its key points, and recommending improvements. This agent delivers
      a comprehensive scientific critique
  description: The Critic agent maintains an adversarial review relationship with
    Scientist agents, evaluating proposals and providing improvement suggestions,
    mirroring peer-review processes.
- name: Hierarchical Agent Task Assignment
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:225-230)
    quote: 'Each agent plays a specialized role: The Ontologist defines key concepts
      and relationships, Scientist 1 crafts a detailed research proposal, Scientist
      2 expands and refines the proposal, and the Critic agent conducts a thorough
      review'
  description: 'Agents are organized in hierarchical task assignment relationships:
    Ontologist provides context, Scientist_1 creates initial hypotheses, Scientist_2
    expands them, and Critic reviews.'
- name: Concept-to-Property Relationships
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:333-348)
    quote: 'Silk - possess - biopolymers: Silk is a type of biopolymer... Silk - broad
      applicability in biomaterial design - multifunctionality: Silk''s multifunctional
      properties make it highly applicable'
  - chunk_ref: 15-SciAgents (Chunk 5:328-337)
    quote: Keratin Scales -- increases within beak -- vf... Keratin Scales -- decreases
      from tip to root -- Rhamphotheca
  description: Merged from 2 sources. Ontological relationships connect concepts to
    their properties using typed predicates (possess, is, has, exhibited by). These
    capture taxonomic, compositional, and attributive relationships.
- name: Material Design Principle Relationships
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:434-440)
    quote: 'the model proposes the following design principles: It utilizes the natural
      multi-scale organization of silk fibroin to guide the self-assembly of dandelion
      pigments, leveraging hierarchical structuring from the nano to the macro scale'
  description: Design principles establish relationships between materials and their
    organizational patterns (multi-scale, hierarchical). These principles guide how
    entities at different scales interact.
- name: Human-Agent Intervention Relationship
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:191-193)
    quote: This second strategy also incorporates human-in-the-loop interactions,
      enabling human intervention at various stages of research development
  description: Human users can establish intervention relationships with the agent
    system, providing feedback, refinement, or strategic guidance at multiple stages
    of the discovery process.
- name: Planner-Team Coordination Relationship
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 2:25-33)
    quote: The process begins with the selection of random keywords, followed by the
      generation of a knowledge path... Each term along the path is defined by an
      ontologist, who also elaborates on the relationships between them
  description: The Planner agent coordinates the team by establishing a workflow sequence.
    Other agents execute their roles according to this plan, creating temporal coordination
    relationships.
- name: Group Chat Manager Routing Relationship
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:737-738)
    quote: 'Group chat manager: chooses the next speaker based on the context and
      agent profiles and broadcasts the message to the whole group'
  description: The Group Chat Manager establishes routing relationships, selecting
    which agent speaks next and broadcasting messages. This creates a hub-and-spoke
    communication pattern in the multi-agent system.
- name: Tool-Agent Invocation Relationship
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 1:733-734)
    quote: 'Assistant: has access to external tools including a function to generate
      a knowledge path from two keywords and a function to assess the novelty and
      feasibility of the research idea'
  - chunk_ref: 15-SciAgents (Chunk 7:508-512)
    quote: The assistant will call the generate_path function with keyword_1 and keyword_2
      set to None to generate a path between randomly selected nodes.
  description: Merged from 2 sources. Explicit relationship between Agent entity and
    Resource (tool/function). The assistant agent invokes tools to generate knowledge
    paths. Shows Agent-performs->Activity and Activity-uses->Resource relationship
    patterns for tool orchestration.
- name: Semantic Scholar Novelty Assessment Relationship
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 2:125-127)
    quote: the assistant agent executes the tool to assess the novelty and feasibility
      of the proposed research idea against the literature. It then returns a detailed
      analysis
  description: The novelty assessment tool establishes relationships between proposed
    research ideas and existing literature, enabling evaluation of how novel a hypothesis
    is compared to published work.
- name: Subgraph-to-Neighbor Context Expansion
  sources:
  - chunk_ref: 15-SciAgents_Multi-Agent_Graph_Reasoning (Chunk 2:256-260)
    quote: After the path is found, a subgraph consisting of the path nodes and their
      second-hop neighbors is generated, providing a broader context for the discovered
      route
  description: Knowledge graph paths are expanded by including second-hop neighbors,
    establishing extended context relationships that provide richer substrate for
    reasoning.
- name: Agent-Role-Task Orchestration Pattern
  sources:
  - chunk_ref: 15-SciAgents (Chunk 3:894-906)
    quote: 'planner: A planner who can suggest a plan... assistant: An assistant who
      calls the appropriate tools... scientist: A scientist who can craft the research
      proposal'
  description: Defines explicit role-based relationships between specialized agents
    in a multi-agent system. Each agent (planner, assistant, ontologist, scientist,
    hypothesis_agent, outcome_agent, mechanism_agent, etc.) has a specific role that
    determines its responsibilities and interactions with other agents. This demonstrates
    Role -> Agent -> Task triadic relationship.
- name: Agent-to-Agent Delegation Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 3:924-940)
    quote: The ontologist will define each term... The scientist will use the definitions
      and relationships to craft a research proposal
  description: Shows sequential delegation pattern where output from one agent (ontologist's
    definitions) becomes input for another agent (scientist's proposal crafting).
    Establishes produces/consumes relationship between agents mediated through data
    artifacts.
- name: Knowledge Path as Entity Linkage
  sources:
  - chunk_ref: 15-SciAgents (Chunk 3:891-892)
    quote: silk -- provide functionalities -- biological materials -- can be integrated
      -- novel functionalities -- can be integrated -- biological materials
  description: Knowledge graph paths explicitly encode relationships between domain
    entities using predicate edges. The pattern Entity -- relationship_type -- Entity
    creates structured semantic connections that guide agent reasoning and hypothesis
    generation.
- name: Ontologist-Defined Term Relationships
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:103-128)
    quote: 'Silk -- provide functionalities -- biological materials: Silk, as a biological
      material, offers various functionalities such as strength, flexibility, and
      biocompatibility'
  - chunk_ref: 15-SciAgents (Chunk 7:599-621)
    quote: 'Tunable Processability -- Allows for -- Material Extrusion: The ability
      to adjust processing parameters enables the use of material extrusion techniques
      to create objects with specific properties.'
  description: Merged from 2 sources. Ontologist agent produces formal relationships
    between domain entities with explicit semantic predicates (provide functionalities,
    can be integrated, uses for creating, have, can guide). These relationships form
    the ontological backbone for agent reasoning.
- name: Bidirectional Entity Relationships
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:116-118)
    quote: Biological materials -- have -- multi-scale organization... Multi-scale
      organization -- have -- biological materials
  description: Some entity relationships are bidirectional/symmetric, indicating mutual
    dependency or composition. This pattern captures part-whole and attribute-bearer
    relationships that can be traversed in either direction.
- name: Negative Relationship Pattern
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:126-128)
    quote: Pigments -- do not use -- insects... Insects -- are -- energy-intensive
  description: Knowledge graphs can encode negative relationships (do not use) alongside
    positive ones. This enables agents to reason about constraints and exclusions,
    not just positive associations.
- name: Multi-Scale Organization Hierarchy
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:170-173)
    quote: 'Molecular Scale: Silk proteins will be functionalized... Microscale: The
      hierarchical organization... Macroscale: Low-temperature processing techniques'
  description: Entities can be organized across multiple scales (molecular, micro,
    macro) with relationships that span levels. This hierarchical structuring pattern
    enables reasoning about cross-scale interactions and emergent properties.
- name: Mechanism-Property Causal Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:374-376)
    quote: The lamellar structure of the biomimetic materials will facilitate efficient
      heat dissipation, analogous to the natural heat management observed in keratin
      scales
  description: Structural mechanisms (lamellar structure) causally relate to functional
    properties (heat transfer). This mechanism -> property relationship enables predictive
    reasoning about how design choices affect outcomes.
- name: Design Principle to Outcome Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:179-183)
    quote: 'Biomimicry: Emulate the seed dispersal mechanism of dandelions... Nanoscale
      Pigmentation: Utilize pigments to guide the self-assembly'
  description: Design principles (biomimicry, nanoscale pigmentation, low-temperature
    processing) relate to expected outcomes through implementation mechanisms. This
    establishes a traceability chain from design intent to material properties.
- name: Agent Performs Activity Pattern
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:79-83)
    quote: 'Ontologist: Define terms and relationships. Scientist: Craft the research
      proposal. Specialized Agents: Expand key aspects'
  description: Core Agent -> performs -> Activity relationship where each specialized
    agent type is associated with specific activities (define, craft, expand, critique).
    This maps directly to the foundational Agent-Activity triad.
- name: Activity Uses/Produces Entity Pattern
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:39-41)
    quote: The scientist will use the definitions and relationships to craft a research
      proposal based on the definitions and relationships provided by the ontologist
  description: Activities (crafting proposal) consume entities (definitions, relationships)
    and produce new entities (research proposal). This Activity -> uses/produces ->
    Entity relationship enables workflow tracking and data lineage.
- name: Critic Agent Feedback Loop
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:64-65)
    quote: The critic_agent will summarize, critique, and suggest improvements to
      the research proposal
  description: 'Feedback relationships where one agent (critic) evaluates artifacts
    produced by other agents. Creates cyclic relationship: Agent produces Entity,
    Critic Agent evaluates Entity, produces Improvement Suggestions that modify original
    Entity.'
- name: Entity Definition Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:89-100)
    quote: 'Silk: A natural protein fiber produced by certain insects... Biological
      Materials: Substances that are produced by or derived from living organisms'
  - chunk_ref: 15-SciAgents (Chunk 4:112-115)
    quote: Biological materials -- uses for creating -- low-temperature processing...
      Low-temperature processing -- uses for creating -- biological materials
  description: Merged from 2 sources. Processing relationships between materials and
    techniques. Bidirectional pattern shows that materials require processing methods,
    and processing methods are designed for specific material types.
- name: Hypothesis to Outcome Traceability
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:151-156)
    quote: 'Hypothesis: We hypothesize that integrating the multi-scale organizational
      properties of silk... Outcome: The expected outcome is the development of a
      silk-based composite material'
  description: Causal relationship chain from Hypothesis -> guides -> Experimental
    Design -> produces -> Outcome. Enables traceability from research questions to
    results.
- name: Mechanism Explains Property
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:188-191)
    quote: 'Self-Healing: The hierarchical organization may lead to self-healing properties,
      where minor damages can be repaired autonomously'
  description: 'Explanatory relationship where structural mechanisms (hierarchical
    organization) provide causal explanation for emergent properties (self-healing).
    Pattern: Structure -> enables -> Behavior/Property.'
- name: Comparison Differentiates Entities
  sources:
  - chunk_ref: 15-SciAgents (Chunk 4:196-199)
    quote: 'Traditional Silk: The proposed material will have superior mechanical
      strength (1.5 GPa vs. 1 GPa) and additional functionalities'
  description: 'Comparative relationships that differentiate entities along measurable
    dimensions. Pattern: Entity A -> differs_from -> Entity B -> along_dimension ->
    Property with quantitative delta.'
- name: Sequential Activity Dependency
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:63-65)
    quote: 'Biomimetic Design: Design the hierarchical structure... Genetic Engineering:
      Use synthetic biology techniques... Material Fabrication: Employ electrospinning'
  description: Sequential dependency relationships between activities where Activity
    A must complete before Activity B can begin. Establishes temporal ordering constraints
    in multi-step workflows.
- name: Tool-Activity Association
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:44-50)
    quote: 'Model Construction: Build molecular models of silk fibroin... Simulation
      Setup: Use molecular dynamics (MD) simulations... Validation: Validate the simulation
      results'
  description: 'Activities are associated with specific tools/methods (MD simulations,
    spectroscopy, tensile testing). Pattern: Activity -> uses_tool -> Tool/Method
    enables capability matching.'
- name: Iterative Optimization Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:69-70)
    quote: 'Iterative Optimization: Use the results from functional testing to iteratively
      optimize the design and fabrication process'
  description: 'Cyclic relationship where outputs feed back to refine inputs. Pattern:
    Activity -> produces -> Result -> informs -> Activity (same or different). Captures
    learning and improvement cycles.'
- name: Material-Application Suitability
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:253-267)
    quote: Soft Lithography -- improves for biological applications -- Biocompatibility...
      Biocompatibility -- make them ideal for biomedical applications
  description: 'Suitability relationships linking materials/techniques to application
    domains based on property matching. Pattern: Material -> has_property -> Property
    -> enables -> Application.'
- name: Biocompatibility Demonstration Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:270-282)
    quote: Biocompatibility -- demonstrate -- Biocompatible Materials... Biocompatible
      Materials -- demonstrate -- Biocompatibility
  description: Circular definitional relationship where property (biocompatibility)
    and material class (biocompatible materials) mutually define each other. Common
    in material science ontologies.
- name: Biomimetic-to-Biological Mapping
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:285-295)
    quote: Biomimetic Materials -- mimic the structure and function of natural biological
      systems -- Biomaterials
  description: 'Structural analogy relationship where engineered entities (biomimetic
    materials) map to natural templates (biological systems). Pattern: Engineered_Entity
    -> mimics -> Natural_Entity.'
- name: Test-Property Measurement Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:297-307)
    quote: Biomaterials -- investigated mechanical behavior and failure mechanisms
      under -- Cyclic Loading Conditions
  description: 'Testing relationship where materials are subjected to conditions that
    reveal properties. Pattern: Entity -> tested_under -> Condition -> reveals ->
    Property.'
- name: Material-Device Integration
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:304-313)
    quote: Biomaterials -- can be combined with -- Microfluidic Chips... Microfluidic
      Chips -- can be combined with -- Biomaterials
  description: Bidirectional integration relationship where materials can be incorporated
    into devices and vice versa. Enables reasoning about composite systems and hybrid
    architectures.
- name: Structure-to-Structure Containment
  sources:
  - chunk_ref: 15-SciAgents (Chunk 5:316-325)
    quote: Biomaterials -- is found in -- Lamellar Structure... Lamellar Structure
      -- is observed when fractured -- Keratin Scales
  description: 'Containment and observation relationships linking structural levels.
    Pattern: Higher_Structure -> contains/manifests -> Lower_Structure captures hierarchical
    composition.'
- name: Structure Affects Property
  sources:
  - chunk_ref: 15-SciAgents (Chunk 6:352)
    quote: Hierarchical structure -- affect -- mechanical stiffness
  description: Direct causal relationship between structural organization and material
    properties. This fundamental pattern (Structure -> affects -> Property) underlies
    much of materials science reasoning.
- name: Stimulus-Response Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 6:8-14)
    quote: The potential for adaptive heat transfer efficiency, where the thermal
      conductivity dynamically adjusts based on the thermal load
  description: 'Dynamic response relationships where entities adapt to stimuli. Pattern:
    Entity -> responds_to -> Stimulus -> by_changing -> Property. Captures feedback
    and adaptation behaviors.'
- name: Self-Healing Recovery Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 6:3-6)
    quote: Aim for a recovery rate of at least 70% of the original mechanical properties
      after inducing controlled damage
  description: 'Recovery relationship where damaged entity returns toward original
    state. Pattern: Entity -> damaged_by -> Event -> recovers_to -> Percentage of
    Original_State. Quantifies resilience.'
- name: Novelty-Feasibility Assessment Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 6:117-124)
    quote: 'Novelty: High - The integration of biomimetic materials with microfluidic
      technology... Feasibility: Moderate - While the proposed improvements and mechanisms
      are well-founded'
  description: 'Evaluation relationships where research proposals are assessed along
    multiple dimensions (novelty, feasibility). Pattern: Proposal -> evaluated_on
    -> Dimension -> scored_as -> Rating. Enables comparative analysis.'
- name: Multi-Agent Role Delegation Pattern
  sources:
  - chunk_ref: 15-SciAgents (Chunk 7:474-486)
    quote: 'planner: A planner who can suggest a plan to solve the task... assistant:
      An assistant who calls the appropriate tools... ontologist: An ontologist who
      defines each of the terms and discusses the relationships'
  description: Entity relationships showing structured delegation between specialized
    agents in multi-agent system. Agents have defined roles (planner, assistant, ontologist,
    scientist, hypothesis_agent, etc.) with explicit responsibilities. Demonstrates
    Role-to-Agent assignment and Agent-to-Task relationships in orchestrated workflows.
- name: Knowledge Path Relationship Chain
  sources:
  - chunk_ref: 15-SciAgents (Chunk 7:576-579)
    quote: tunable processability -- Allows for -- material extrusion -- Allows for
      Creation of -- controlled pore sizes -- Achieved through varying electrospun
      collagen micro/nanofiber deposition times
  description: Demonstrates ontological relationship chains connecting concepts through
    typed relationships (Allows for, Allows for Creation of, Achieved through). Shows
    how entities are linked through relationship predicates forming a knowledge graph
    structure.
- name: Hierarchical Structure Contribution Relationships
  sources:
  - chunk_ref: 15-SciAgents (Chunk 7:803-857)
    quote: Hexagonally Packed -- arranged in -- Platelets -- constituent part of --
      Nacre... Hierarchical Structure -- absorbing during fracture -- Destructive
      Energy
  description: Complex multi-hop relationship chains showing structural composition
    (constituent part of), spatial arrangement (arranged in), and functional relationships
    (absorbing during fracture). Demonstrates how entities relate through multiple
    relationship types forming ontological graphs.
- name: Agent-to-Agent Communication Flow
  sources:
  - chunk_ref: 15-SciAgents (Chunk 8:697-709)
    quote: 'planner: Who can suggest a step-by-step plan... assistant: An assistant
      who calls the appropriate tools and functions... caller: I am responsible for
      selecting the next role to speak. Call this agent immediately after each output'
  description: Entity relationship pattern for agent coordination showing caller-agent
    responsible for routing control flow between agents. Demonstrates Agent-delegates-to->Agent
    and Agent-follows->Agent relationship patterns in multi-agent orchestration.
- name: Research Proposal Aspect Relationships
  sources:
  - chunk_ref: 15-SciAgents (Chunk 8:722-733)
    quote: Each specialized agent (hypothesis_agent, outcome_agent, mechanism_agent,
      design_principles_agent, unexpected_properties_agent, comparison_agent, novelty_agent)
      will expand on their respective aspects of the research proposal.
  description: One-to-one relationship mapping between specialized agents and proposal
    aspects. Shows Role-responsible-for->Task relationships where each agent has a
    unique aspect to expand. Demonstrates functional decomposition through entity
    relationships.
- name: Entity-Definition-Relationship Triple Pattern
  sources:
  - chunk_ref: 15-SciAgents (Chunk 9:759-787)
    quote: 'Graphene -- bind -- Amyloid Fibrils: Graphene can interact with amyloid
      fibrils, potentially influencing their formation or stability.'
  description: Standard triple pattern (subject-predicate-object) for entity relationships.
    Shows Entity-relationship-Entity structure with semantic meaning attached to the
    relationship. Bidirectional relationships also noted (Amyloid Fibrils -- bind
    -- Graphene).
- name: Controlled Expression Relationship Chain
  sources:
  - chunk_ref: 15-SciAgents (Chunk 9:785-787)
    quote: 'Proteins -- controlled expression, secretion, and assembly -- Gene Circuits:
      The expression, secretion, and assembly of proteins can be regulated by engineered
      gene circuits.'
  description: Relationship showing control/regulation pattern between entities. Gene
    circuits control proteins through expression, secretion, and assembly - demonstrating
    Rule/Control-regulates->Entity relationship pattern.
- name: Scientist-Crafts-Proposal Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 9:793-794)
    quote: Caller, please select the scientist to craft the research proposal based
      on these definitions and relationships.
  description: 'Agent-Activity-Entity triad: scientist (Agent) crafts (Activity) research
    proposal (Entity) based on definitions and relationships (Data). Shows standard
    Agent-performs->Activity-produces->Entity pattern.'
- name: Composite Material Binding Relationships
  sources:
  - chunk_ref: 15-SciAgents (Chunk 10:5-7)
    quote: We hypothesize that the interaction between graphene and amyloid fibrils
      can be harnessed to create novel bioelectronic devices with enhanced electrical
      properties.
  description: 'Entity relationships in hypothesis: graphene (Entity) interacts-with
    amyloid fibrils (Entity) to create bioelectronic devices (Entity). Shows Entity-interacts->Entity-produces->Entity
    relationship chain for material science domain.'
- name: Gene Circuit-Protein Expression Control
  sources:
  - chunk_ref: 15-SciAgents (Chunk 10:44-47)
    quote: 'Gene Circuit Regulation: The hypothesis extends to the use of synthetic
      biology to control the production of amyloid-forming proteins. We propose that
      engineered gene circuits can precisely regulate the expression levels, secretion
      rates'
  description: 'Control relationship pattern: Gene circuits (Rule/Control entity)
    regulate proteins (Entity) through expression, secretion, assembly. Shows Rule-controls->Resource
    relationship pattern applicable to agent orchestration where rules govern resource
    production.'
- name: Agent-Memory-Decision Relationship
  sources:
  - chunk_ref: 15-SciAgents (Chunk 10:91-97)
    quote: 'Controlled Protein Expression: Engineered gene circuits will enable precise
      control over the expression, secretion, and assembly of amyloid-forming proteins.
      The expression levels will be fine-tuned to achieve desired protein concentrations'
  description: Demonstrates Data-informs->Agent-produces->Entity pattern where gene
    circuits (data/rules) inform production systems to achieve quantitative goals.
    Maps to agent systems where memory/context informs agent decisions.
- name: LLM-KG Synergy Relationship
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:50-51)
    quote: Knowledge graph (KG), which stores massive knowledge triples in a graph-structured
      format, has been broadly used to complement LLMs with external knowledge
  description: 'Entity relationship pattern: KG (Data entity) complements LLM (Agent
    entity) with external knowledge. Shows Data-augments->Agent relationship for knowledge-enhanced
    reasoning systems.'
- name: KG Triple Structure
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:176-183)
    quote: A knowledge graph typically consists of a large number of fact triples,
      expressed as G = {(e, r, e')|e, e' in E, r in R}, where E and R denote the entity
      set and relation set, respectively.
  description: 'Foundational entity relationship structure: subject entity (e) - relation
    (r) - object entity (e''). Formal definition of entity relationships as triples
    in knowledge graphs. Each entity has type (t) and unique ID.'
- name: Neighboring Relations Pattern
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:188-191)
    quote: we introduce neighboring relations to denote both the incoming and outgoing
      relations for a set of entities {e}, denoted as R{e} = {r|(e, r, e') in G} union
      {r|(e', r, e) in G}
  description: Bidirectional entity relationship pattern capturing both incoming and
    outgoing relations from entity set. Shows Entity-has->Relations (incoming/outgoing)
    pattern for graph traversal and reasoning.
- name: Agent-Tool-KG Orchestration
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:199-205)
    quote: domain-specific interface is helpful for LLMs to manipulate the structured
      data... we further assume that a toolbox can be provided to facilitate the access
      to the information of KG
  description: 'Three-way entity relationship: Agent (LLM) uses Toolbox (Resource)
    to access KG (Data). Shows Agent-uses->Resource-accesses->Data relationship pattern
    for structured data manipulation.'
- name: Agent-Toolbox-Executor-Memory Architecture
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:26-30)
    quote: In KG-Agent, we integrate the LLM, multifunctional toolbox, KG-based executor,
      and knowledge memory, and develop an iteration mechanism that autonomously selects
      the tool then updates the memory
  description: 'Core entity relationships in agent architecture: LLM (Agent) integrates-with
    Toolbox (Resource), Executor (Activity processor), Memory (Data store). Shows
    Agent-integrates->Resource, Agent-integrates->Activity, Agent-integrates->Data
    patterns.'
- name: Extraction Tool Relationships
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:241-249)
    quote: Extraction tools aim to facilitate the access to information from KG...
      we design five tools to support the access to the relations (get_relation),
      the head/tail entities (get_head_entity/get_tail_entity)
  description: 'Tool-Entity relationships for KG access: get_relation (Tool) extracts
    relations from entities, get_head_entity/get_tail_entity (Tools) extract related
    entities. Shows Resource(Tool)-operates-on->Entity relationship patterns.'
- name: Logic Tool Operations
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:251-255)
    quote: Logic tools aim to support basic manipulation operations on the extracted
      KG information, including entity counting (count), entity set intersection (intersect)
      and union (union), condition verification (judge)
  description: 'Logic operations as relationships between entity sets: count (Tool)
    operates-on entity set, intersect/union (Tools) combine entity sets. Shows Resource(Tool)-transforms->Entity
    pattern for logical operations.'
- name: Semantic Tool Relationships
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:257-259)
    quote: Semantic tools are developed by utilizing pre-trained models to implement
      specific functions, including relation retrieval (retrieve_relation) and entity
      disambiguation (disambiguate_entity)
  description: 'Semantic tools mediate Agent-Entity relationships: retrieve_relation
    matches relations semantically, disambiguate_entity resolves entity references.
    Shows Resource(Tool)-semantically-links->Entity pattern.'
- name: Knowledge Memory Structure
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:544-551)
    quote: The knowledge memory preserves the currently useful information to support
      the LLM-based planner for making decisions. It mainly contains four parts of
      information, i.e., natural language question, toolbox definition, current KG
      information, and history reasoning program
  description: 'Memory entity relationships: Memory contains Question (Goal), Toolbox
    (Resource definitions), KG Info (Data), History (Event log). Shows Data(Memory)-contains->Goal,
    Data(Memory)-contains->Resource, Data(Memory)-contains->Event patterns.'
- name: Planner-Tool Selection Relationship
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:554-565)
    quote: Based on the current knowledge memory, the LLM-based planner selects a
      tool to interact with KG at each step... the planner needs to invoke tools from
      the pre-defined toolbox to address four types of task requirements
  description: 'Agent-Resource selection pattern: Planner (Agent) selects Tool (Resource)
    based on Memory (Data) to address Task requirements. Shows Agent-uses->Data-to-select->Resource-for->Task
    relationship chain.'
- name: Executor-Memory Update Relationship
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:568-626)
    quote: After the planner generates the function call, the KG-based executor will
      execute it using a program compiler. It can cache or operate the intermediate
      variables, and extract new entities or relations from the KG. After execution,
      the knowledge memory will be accordingly updated
  description: 'Activity-Data update pattern: Executor (Activity processor) executes
    function call, updates Memory (Data). Shows Activity-modifies->Data pattern where
    execution results update agent state.'
- name: Iterative Reasoning Relationship
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:629-638)
    quote: The KG-Agent framework autonomously iterates the above tool selection and
      memory updation process to perform step-by-step reasoning, where the knowledge
      memory is used to maintain the accessed information from KG
  description: 'Cyclic Agent-Activity-Data relationship: Agent selects tool (Activity),
    updates Memory (Data), iterates. Shows Event-sequence relationship where activities
    occur in ordered steps until goal reached (answer entities found).'
- name: Query Graph to Reasoning Chain
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:420-434)
    quote: the query graph has a tree-like structure that can be directly mapped to
      a logical form... starting from the mentioned entity in the question (i.e.,
      Cristiano Ronaldo), we adopt breadth-first search (BFS) to visit all the nodes
      on the query graph
  description: 'Entity relationship traversal pattern: Query graph (structured Data)
    maps to reasoning chain via BFS traversal. Shows Data(Graph)-transforms-to->Data(Chain)
    relationship through entity traversal from topic entity to answer entity.'
- name: Function Call to Triple Mapping
  sources:
  - chunk_ref: 16-KG-Agent (Chunk 1:436-456)
    quote: we reformulate the triples into several function calls with the code format,
      which represents the tool invocation... we start from the get_relation(e) function
      call to obtain the current candidate relations {r} associated with e on the
      KG
  description: 'Triple-to-Activity mapping: KG triples (Entity relationships) map
    to function calls (Activities). Shows Data(Triple)-represents-as->Activity(Function)
    pattern for programmatic knowledge graph reasoning.'
- name: Triple-Based Knowledge Representation
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:35-39)
    quote: Knowledge graph (KG), representing facts in the form of triples, with vocabulary
      defined in a schema (also known as ontology), is a simple yet efficient and
      increasingly popular way of knowledge representation
  description: Entity relationships in KGs are represented as triples (subject-predicate-object),
    with schema/ontology defining the vocabulary. This establishes the fundamental
    structural relationship pattern for knowledge representation.
- name: Rule-Based Inference Relationships
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:79-85)
    quote: One rule, which can be simply represented as H <- B1 AND B2 AND ... Bn,
      means that the head atom H can be inferred by the body atoms B1, ..., Bn. For
      example, isfatherOf(X, Y) <- Male(X) AND isParentOf(X, Y)
  description: Logical rules define inferential relationships between entities through
    conditional statements. The example shows how entity relationships (isfatherOf)
    can be derived from other relationships (Male, isParentOf) through logical conjunction.
- name: Class Hierarchy Relationships
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:200-202)
    quote: Class hierarchies classify entity types, denoting entities as instantiations
      of classes. There are two tasks for injecting class hierarchies, encoding the
      types of entities and encoding hierarchies of entity types
  description: Entities participate in is-a/instantiation relationships with classes,
    and classes form hierarchical subsumption relationships with each other. This
    defines both type membership and taxonomic structure.
- name: Relation Hierarchy Subsumption
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:224-227)
    quote: Relation hierarchies contain subsumption relationships between relations;
      for example, hasFather is a sub-relation of hasParents
  description: Relations themselves form hierarchical structures where more specific
    relations (hasFather) are sub-relations of more general ones (hasParents). This
    creates a meta-level relationship structure for organizing predicates.
- name: Domain and Range Constraints
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:239-242)
    quote: For domain and range of relations, TRESCAL leverages them by filtering
      triples in KGs where entities are not compatible with the domain or range of
      relations
  description: Domain and range constraints define which entity types can participate
    in specific relationships. Domain constrains the subject type, range constrains
    the object type of a relation.
- name: Symmetric and Transitive Relation Properties
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:244-249)
    quote: To model Ansymmetric relations, ComplEx proposes to embed KGs in complex
      vector space... To further model Composition between relations, RotatE proposes
      to define each relation as a rotation... Rot-Pro proposes to model Transitive
      relations
  description: Relations have mathematical properties (symmetric, asymmetric, transitive,
    reflexive, compositional) that constrain how entity relationships behave. These
    properties enable inference of additional relationships from existing ones.
- name: Equivalent and Inverse Relation Properties
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:251-254)
    quote: we introduce relation properties constraining multiple relations that have
      been considered, including Equivalent and Inverse. Given these two pre-defined
      relation properties...
  description: Equivalent relations establish that two different relation names refer
    to the same relationship. Inverse relations establish that if R(a,b) holds, then
    R-inverse(b,a) also holds. These are inter-relation relationships.
- name: Query Answering Relationship Traversal
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:359-365)
    quote: Query answering returns correct entities in a KG as answers of a given
      structured query, where reasoning is usually considered for hidden answers...
      For example, path queries proposed in [Guu et al., 2015]
  description: Structured queries express complex relationship patterns involving
    path traversal, conjunction, disjunction, and negation over entity relationships.
    Entities are connected through multi-hop relationship paths.
- name: Conjunctive and Disjunctive Query Relationships
  sources:
  - chunk_ref: 17-KG_Reasoning_Logics_Embeddings_Survey (Chunk 1:394-406)
    quote: Apart from simple path queries, more complex queries, such as conjunctive
      logical queries and Existential Positive First-Order (EPFO), involving multiple
      unobserved edges, nodes, and even variables are also widely researched
  description: Complex queries combine entity relationships through logical operators
    (AND, OR, NOT) to express sophisticated relationship patterns across multiple
    entities and relationship types.
- name: Goal-Task Decomposition Relationship
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:453-461)
    quote: When faced with such challenges, the system adeptly breaks down the complex
      task into smaller, manageable tasks. These sub-tasks are subsequently distributed
      among various agents, each equipped with specific competencies
  description: Goals decompose into Tasks through a hierarchical breakdown relationship.
    Complex tasks further decompose into sub-tasks, creating a tree-like containment/derivation
    structure between goal and task entities.
- name: Agent-Task Assignment Relationship
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:458-461)
    quote: These sub-tasks are subsequently distributed among various agents, each
      equipped with specific competencies. A crucial aspect of this divide & conquer
      strategy lies in the effective orchestration of these interconnected sub-tasks
  description: Agents are assigned to Tasks through a performs/executes relationship.
    Task orchestration creates dependencies and sequencing between task entities that
    agents must respect.
- name: Agent-Role Association
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:467-474)
    quote: Each agent is endowed with a unique set of competencies, which include
      a clearly defined role, an individual memory, as well as access to further contextual
      resources... This enables the agents not only to reflect upon the tasks
  description: Agents have Roles that define their identity and responsibilities.
    The Role relationship is a has-a/occupies association that determines agent behavior,
    permissions, and competencies.
- name: Agent-Resource Utilization
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:487-493)
    quote: Some tasks require the utilization of contextual resources, such as expert
      tools, data, further specialized foundation models, or other applications. These
      resources extend their ability to gather environmental information
  description: Agents utilize Resources (tools, data, models) through a uses/leverages
    relationship. Resources extend agent capabilities for task execution.
- name: Agent Collaboration Network
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 1:477-484)
    quote: The interaction layer provides the workspace for a network of such collaborating
      LLM-powered agents. While executing the assigned tasks, these specialized agents
      collaborate with each other via prompt-driven message exchanges
  description: Agents form collaboration networks with peer-to-peer relationships
    for message exchange, task delegation, and result evaluation. The network entity
    contains multiple agent entities.
- name: Agent Action Composition
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:30-49)
    quote: 'the following sub-types of Action performed by the Agents can be distinguished:
      DecomposeTask, Create Task, DelegateTask, ExecuteTask, EvaluateResult, MergeResult'
  description: Agents perform Actions that have typed relationships with Tasks and
    Results. Actions can be composed (part-of) within other Actions, creating hierarchical
    action structures.
- name: Task Delegation Relationship
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:43)
    quote: 'DelegateTask: Delegating a task to another agent, addressed as Receiver'
  description: The DelegateTask action establishes a sender-receiver relationship
    between agents, where one agent (delegator) assigns task responsibility to another
    agent (receiver).
- name: Task-Result Production
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:47-49)
    quote: 'EvaluateResult: Assessing the outcomes of a task. MergeResult: Integrating
      or combining two or more task results'
  description: Tasks produce Results through execution. Results can be evaluated and
    merged, establishing produces/yields and combines-into relationships between task
    and result entities.
- name: Agent-Prompt Interaction
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:56-60)
    quote: an Agent Prompt generated by an Agent and triggered within a certain Action
      is send to and then processed by the LLM, which generates a Response informing
      and/or guiding the next steps within the triggering action
  description: Agents generate Prompts that are sent to LLMs, which produce Responses.
    This establishes a generates/sends and receives/processes relationship chain between
    Agent, Prompt, LLM, and Response entities.
- name: Prompt Augmentation Relationship
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:59-66)
    quote: Before the LLM receives the Agent Prompt, it may undergo Prompt Augmentation.
      This process can integrate additional specifics like the aspects or parts of
      the agent's Role or Memory, Context Information
  description: Prompts are augmented with information from Role, Memory, and Context
    entities. This establishes an enhances/enriches relationship where multiple source
    entities contribute to the prompt entity.
- name: Communication Protocol Governance
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:75-79)
    quote: A Communication Protocol provides a structured framework and methodology
      for agents' collaboration, guiding the execution of specific Actions by establishing
      rules and mechanisms for message exchanges
  description: Communication Protocols govern Agent collaboration through a regulates/constrains
    relationship. The protocol entity defines permissible interactions between agent
    entities.
- name: Context Resource Types
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:99-101)
    quote: For executing the task-related actions, the LLM-powered agents are able
      to leverage specialized competencies and further information provided by additional
      Context which can be distinguished into Tools, Data, and Foundation Models
  description: 'Context is a supertype with three subtypes: Tools, Data, and Foundation
    Models. This establishes is-a/subtype-of relationships in the resource type hierarchy.'
- name: Tool Categorization Hierarchy
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:104-124)
    quote: 'Tools in terms of contextual resources for multi-agent systems can be
      categorized into the following distinct groups: Search and Analysis Tools, Execution
      Tools, Reasoning Tools, Development Tools, Communication Tools'
  description: Tools are categorized into subtypes (Search/Analysis, Execution, Reasoning,
    Development, Communication), creating a tool taxonomy with is-a relationships.
- name: Data Type Categorization
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:127-144)
    quote: 'Data types in multi-agent architectures encompass: Structured Text Data,
      Unstructured Text Data, Multimodal Data, Domain-specific Data'
  description: Data entities are categorized into types based on structure and domain,
    establishing a data type taxonomy with is-a relationships and associated processing
    requirements.
- name: Foundation Model Modality Types
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:150-167)
    quote: 'Foundation Models refer to expansive machine learning models trained on
      vast amounts of data... we categorize them as follows: Natural Language Processing
      (NLP) Models, Computer Vision Models, Audio Models, Multimodal Models'
  description: Foundation Models are categorized by modality (NLP, Vision, Audio,
    Multimodal), with LLMs as a subtype of NLP Models. This creates a model type hierarchy.
- name: Autonomy-Alignment Tension
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:185-204)
    quote: Autonomy and alignment represent cross-cutting concerns, influencing various
      architectural concepts and mechanisms... Alignment, on the one hand, primarily
      manifests through the implementation of dedicated Alignment Techniques
  description: Autonomy and Alignment have a tension/balance relationship that influences
    all architectural components. They are cross-cutting concerns that affect multiple
    entity relationships.
- name: User-Goal Specification
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:189-191)
    quote: The user-prompted Goal can be further refined pre-runtime through supplementary
      Preferences provided by the Human User via the User Interface
  description: Human Users specify Goals and Preferences that define system behavior.
    This establishes specifies/defines relationships from User to Goal/Preference
    entities.
- name: Viewpoint Architectural Dependencies
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:683-694)
    quote: To effectively design and understand autonomous LLM-powered multi-agent
      systems, it's essential to recognize the relationships and interdependencies
      between architectural components and viewpoints
  description: Architectural viewpoints (Goal-driven Task Mgmt, Agent Composition,
    Multi-Agent Collaboration, Context Interaction) have use/dependency relationships
    between them.
- name: Availability-Driven Dependencies
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:697-706)
    quote: For low-autonomy multi-agent systems... the architecture operates predominantly
      under pre-established automation. In these systems, functionality largely relies
      on pre-configured rules and mechanisms
  description: In low-autonomy systems, Goal-driven Task Management depends on Agent
    Composition, Multi-Agent Collaboration, and Context Interaction through availability-driven
    dependencies.
- name: Requirements-Driven Dependencies
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 2:779-801)
    quote: high-autonomy multi-agent systems... have the ability to self-organize.
      In these systems, the architectural infrastructure and dynamics as well as the
      context interaction are self-organizing and thus capable of adapting
  description: 'In high-autonomy systems, dependencies are inverted: other viewpoints
    adapt to Goal-driven Task Management requirements, establishing adapts-to relationships.'
- name: Decomposition-Orchestration-Synthesis Flow
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 3:118-124)
    quote: 'Taxonomic aspects of Goal-driven Task Management comprise the three constituting
      phases: Decomposition (how the goal or complex task is broken down into manageable
      sub-tasks), Orchestration... and Synthesis'
  description: 'Task Management has three phases with sequential/flow relationships:
    Decomposition precedes Orchestration precedes Synthesis. Each phase processes
    and transforms task/result entities.'
- name: Communication-Prompt-Action Flow
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 3:158-165)
    quote: For the taxonomic classification within Multi-Agent Collaboration, we consider
      Communication-Protocol Management, Prompt Engineering, and Action Management
  description: 'Multi-Agent Collaboration involves interdependent aspects: Communication
    Protocol governs Prompt Engineering which enables Action Management. These have
    adapts-to dependencies.'
- name: Agent Generation-Role-Memory-Network
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 3:201-208)
    quote: The aspects of Agent Composition applied by the taxonomy comprise Agent
      Generation, Role Definition, Memory Usage, and Network Management
  description: 'Agent Composition aspects have dependencies: Agent Generation creates
    agents, Role Definition characterizes them, Memory Usage enables learning, Network
    Management organizes their relationships.'
- name: Resource Integration-Utilization Flow
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 3:239-243)
    quote: For Context Interaction, the taxonomic aspects comprise Resources Integration
      (how the integration of contextual resources... is achieved), and Resources
      Utilization (how these resources are actually utilized)
  description: 'Context Interaction has two phases: Integration (making resources
    available) precedes Utilization (actually using resources). Integration enables
    Utilization.'
- name: Task-Management Agent Types
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 4:12-18)
    quote: They employ a multi-cycle process framework performed by dedicated task-management
      agents represented by certain generic agent types, including a single task-execution
      agent
  description: Task-Management Agents are specialized agent types (Task-Creation,
    Task-Prioritization, Task-Execution) that have performs relationships with specific
    task management actions.
- name: Role-Agent Collaboration Pattern
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 4:51-67)
    quote: Role-Agent Systems employ an interplay or simulation between multiple dedicated
      roles agents. This collaboration can serve different purposes, such as simulating
      a discussion or solving tasks
  description: Role Agents have instructor-executor relationships where one agent
    instructs and another executes. This creates asymmetric collaboration patterns
    between role-playing agents.
- name: Bounded Autonomy Dependency Pattern
  sources:
  - chunk_ref: 18-Multi-Agent_Architecture_Taxonomy_LLM (Chunk 4:77-90)
    quote: Autonomous decomposition directly depends on the user-prompted goal. Autonomous
      action management depends on strict or predefined communication protocol. Autonomous
      resource utilization depends on strict resource integration
  description: 'High-autonomy aspects depend on low-autonomy aspects for control:
    Decomposition depends-on Goal, Action Management depends-on Communication Protocol,
    Resource Utilization depends-on Resource Integration.'
- name: Thought Graph Structure
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:17-21)
    quote: The key idea and primary advantage of GoT is the ability to model the information
      generated by an LLM as an arbitrary graph, where units of information ('LLM
      thoughts') are vertices, and edges correspond to dependencies between these
      vertices
  description: Thoughts are modeled as vertices with dependency edges between them,
    forming an arbitrary directed graph structure. This establishes a depends-on/derived-from
    relationship between thought entities.
- name: Thought Aggregation Relationship
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:20-22)
    quote: This approach enables combining arbitrary LLM thoughts into synergistic
      outcomes, distilling the essence of whole networks of thoughts, or enhancing
      thoughts using feedback loops
  description: Multiple thoughts can be combined/aggregated into new synthesized thoughts,
    establishing a many-to-one combines-into relationship. Feedback loops create reflexive
    enhancement relationships.
- name: Chain-of-Thought Sequential Relationship
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:47-49)
    quote: Chain-of-Thought (CoT) is an approach for prompting, in which one includes
      the intermediate steps of reasoning within the prompt (intermediate 'thoughts'),
      besides the task input/output
  description: In CoT, thoughts form a linear chain with next/precedes relationships.
    Each thought depends on exactly one predecessor, creating a sequential reasoning
    path.
- name: Tree-of-Thoughts Branching Relationship
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:58-61)
    quote: CoT and CoT-SC were extended with Tree of Thoughts (ToT), which models
      the LLM reasoning process with a tree. This facilitates using different paths
      of thoughts, and offers novel capabilities such as backtracking
  description: In ToT, thoughts form parent-child relationships in a tree structure.
    Each thought can have multiple children but only one parent, enabling branching
    exploration.
- name: Graph Reasoning Decomposition
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:234-252)
    quote: We model the reasoning process as a directed graph G = (V, E); V is a set
      of vertices and E is a subset of V x V... A directed edge (t1, t2) indicates
      that thought t2 has been constructed using t1 as 'direct input'
  description: The reasoning process is modeled as a directed graph where vertices
    are thoughts and edges are construction/derivation dependencies. This establishes
    a constructed-from relationship.
- name: Heterogeneous Thought Classes
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:253-259)
    quote: In certain use cases, graph nodes belong to different classes. For example,
      in writing tasks, some vertices model plans of writing a paragraph, while other
      vertices model the actual paragraphs of text
  description: Thoughts can be typed/classified (e.g., plan vs. content), creating
    a heterogeneous graph with is-a relationships between thoughts and thought classes.
- name: Thought Transformation Relationships
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:306-341)
    quote: GoT enables novel transformations of thoughts thanks to the graph-based
      model for reasoning. We refer to them as graph-enabled transformations
  description: Thought transformations (aggregation, refining, generation) modify
    the graph by adding vertices and edges. Each transformation type creates specific
    relationship patterns between source and target thoughts.
- name: Aggregation Transformation Pattern
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:344-352)
    quote: with GoT, one can aggregate arbitrary thoughts into new ones, to combine
      and reinforce the advantages of these thoughts... V+ = {v+} and E+ = {(v1, v+),
      ..., (vk, v+)}
  description: Aggregation creates many-to-one relationships where k input thoughts
    (v1...vk) contribute to one output thought (v+). This enables merging reasoning
    paths.
- name: Refining Transformation Pattern
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:355-358)
    quote: 'Another thought transformation is the refining of a current thought v
      by modifying its content: V+ = {} and E+ = {(v, v)}. This loop in the graph
      indicates an iterated thought'
  description: Refining creates a self-loop relationship (v, v) where a thought references
    itself for iterative improvement. This is a reflexive enhancement relationship.
- name: Generation Transformation Pattern
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:360-364)
    quote: one can generate one or more new thoughts based on an existing single thought
      v... V+ = {v1+, ..., vk+} and E+ = {(v, v1+), ..., (v, vk+)}
  description: Generation creates one-to-many relationships where one input thought
    spawns k output thoughts. This enables branching exploration of reasoning alternatives.
- name: Thought Scoring and Ranking
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:367-377)
    quote: Thoughts are scored to understand whether the current solution is good
      enough. A score is modeled as a general function E(v, G, ptheta)... GoT can
      also rank thoughts... R(G, ptheta, h)
  description: Thoughts have evaluation relationships with the reasoning graph and
    can be ranked relative to each other. Scoring establishes a quality relationship
    between thought and metric.
- name: Controller-Component Orchestration
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:383-395)
    quote: The GoT architecture consists of a set of interacting modules... the Prompter,
      the Parser, the Scoring module, and the Controller... The Controller coordinates
      the entire reasoning process
  description: The Controller entity coordinates Prompter, Parser, and Scoring module
    entities. It contains Graph of Operations and Graph Reasoning State, establishing
    containment and coordination relationships.
- name: Graph of Operations Structure
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:434-443)
    quote: The user constructs a GoO instance, which prescribes the execution plan
      of thought operations. The GoO is a static structure... Each operation object
      knows its predecessor and successor operations
  description: Operations in GoO have predecessor/successor relationships forming
    an execution plan. This establishes temporal/causal ordering between operation
    entities.
- name: Latency-Volume Tradeoff Relationship
  sources:
  - chunk_ref: 19-Graph_of_Thoughts_LLM_Reasoning (Chunk 1:728-754)
    quote: We now show that GoT improves upon previous prompting schemes in terms
      of the tradeoff between latency (number of hops in the graph of thoughts to
      reach a given final thought) and volume
  description: Thoughts have reachability relationships measured by volume (number
    of thoughts that can reach a given thought). GoT enables high volume with low
    latency through aggregation.
