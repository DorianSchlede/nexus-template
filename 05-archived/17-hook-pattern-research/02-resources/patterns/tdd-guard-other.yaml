# TDD Guard Hook Patterns - Non-PreToolUse Hooks
# Source: https://github.com/nizos/tdd-guard
# Language: TypeScript
# Purpose: TDD enforcement through Claude Code hooks

metadata:
  repository: tdd-guard
  author: nizos
  language: TypeScript
  description: |
    TDD Guard enforces Test-Driven Development by intercepting file operations.
    When Claude Code attempts to edit or write files, TDD Guard captures, analyzes,
    validates TDD compliance using an AI model, blocks violations, and guides corrections.
  hook_events_used:
    - SessionStart
    - PostToolUse
    - UserPromptSubmit
  architecture: |
    Monolithic CLI application with unified entry point. All hook types route through
    the same processHookData function which dispatches to specialized handlers based
    on hook_event_name. Uses dependency injection and interface-driven design.

patterns:
  # ============================================================================
  # PATTERN 1: Session State Reset
  # ============================================================================
  - pattern_name: "session-state-reset"
    hook_event: "SessionStart"
    source_repo: "tdd-guard"
    source_file: "src/hooks/sessionHandler.ts"
    description: |
      Clears transient session data (test results, todos, modifications, lint data)
      on session start while preserving persistent configuration. Ensures each
      session begins with a clean slate.
    implementation:
      matcher: "startup|resume|clear"
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Clears transient storage files while preserving config on SessionStart events"
      code_snippet: |
        export class SessionHandler {
          private readonly storage: Storage

          constructor(storage?: Storage) {
            this.storage = storage ?? new FileStorage()
          }

          async processSessionStart(hookData: string): Promise<void> {
            const parsedData = JSON.parse(hookData)
            const sessionStartResult = SessionStartSchema.safeParse(parsedData)

            if (!sessionStartResult.success) {
              return
            }

            await this.ensureInstructionsExist()
            await this.storage.clearTransientData()
          }

          private async ensureInstructionsExist(): Promise<void> {
            const existingInstructions = await this.storage.getInstructions()
            if (!existingInstructions) {
              await this.storage.saveInstructions(RULES)
            }
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - session cleanup only"
    use_case:
      category: "Context"
      when_to_use: |
        When hook maintains state across tool calls that should be reset between sessions.
        Useful for clearing caches, temporary data, or accumulated state that should
        not persist across conversation boundaries.
      when_not_to_use: |
        If state needs to persist across sessions (e.g., user preferences, learned patterns).
        Also avoid if session start processing would cause noticeable latency.
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies:
        - "zod (schema validation)"

  # ============================================================================
  # PATTERN 2: Default Instructions Initialization
  # ============================================================================
  - pattern_name: "default-instructions-init"
    hook_event: "SessionStart"
    source_repo: "tdd-guard"
    source_file: "src/hooks/sessionHandler.ts"
    description: |
      Ensures TDD rule instructions exist on session start. If no custom instructions
      file exists, creates one with default TDD rules. Preserves existing custom
      instructions if already present.
    implementation:
      matcher: "startup|resume|clear"
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Idempotent initialization of instruction file with sensible defaults"
      code_snippet: |
        private async ensureInstructionsExist(): Promise<void> {
          const existingInstructions = await this.storage.getInstructions()
          if (!existingInstructions) {
            await this.storage.saveInstructions(RULES)
          }
        }

        // From rules.ts - the default RULES content:
        export const RULES = `## TDD Fundamentals

        ### The TDD Cycle
        The foundation of TDD is the Red-Green-Refactor cycle:

        1. **Red Phase**: Write ONE failing test that describes desired behavior
        2. **Green Phase**: Write MINIMAL code to make the test pass
        3. **Refactor Phase**: Improve code structure while keeping tests green
        ...`
    context_loading:
      mechanism: "none"
      what_loaded: |
        Creates instructions.md file in data directory containing TDD rules.
        This file is later read and used as context for AI validation.
    use_case:
      category: "Context"
      when_to_use: |
        When hook requires configuration or instruction files that should have
        sensible defaults. Good for onboarding - users get working behavior
        immediately but can customize later.
      when_not_to_use: |
        If defaults would be harmful or confusing. If file creation could
        conflict with user's project structure.
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  # ============================================================================
  # PATTERN 3: User Command Toggle
  # ============================================================================
  - pattern_name: "user-command-toggle"
    hook_event: "UserPromptSubmit"
    source_repo: "tdd-guard"
    source_file: "src/hooks/userPromptHandler.ts"
    description: |
      Intercepts special user commands ("tdd-guard on", "tdd-guard off") to
      enable/disable the guard mid-session. Commands are consumed by the hook
      and do not reach Claude, providing seamless UX.
    implementation:
      matcher: ""
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Intercept and consume special commands, toggle persistent state, stop propagation"
      code_snippet: |
        export class UserPromptHandler {
          private readonly guardManager: GuardManager
          private readonly GUARD_COMMANDS = {
            ON: 'tdd-guard on',
            OFF: 'tdd-guard off'
          } as const

          async processUserCommand(hookData: string): Promise<ValidationResult | undefined> {
            const data = JSON.parse(hookData)

            // Only process UserPromptSubmit events
            if (data.hook_event_name !== 'UserPromptSubmit') {
              return undefined
            }

            const command = data.prompt?.toLowerCase()

            switch (command) {
              case this.GUARD_COMMANDS.ON:
                await this.guardManager.enable()
                return this.createBlockResult('TDD Guard enabled')

              case this.GUARD_COMMANDS.OFF:
                await this.guardManager.disable()
                return this.createBlockResult('TDD Guard disabled')

              default:
                return undefined
            }
          }

          private createBlockResult(message: string): ValidationResult {
            return {
              decision: undefined,
              reason: message,
              continue: false,
              stopReason: message
            }
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - state change only"
    use_case:
      category: "Productivity"
      when_to_use: |
        When users need runtime control over hook behavior without editing config.
        Perfect for workflows where enforcement should be temporarily suspended
        (e.g., debugging, quick prototyping, demo mode).
      when_not_to_use: |
        If commands could conflict with normal user prompts. If toggle state
        should not persist across sessions. If command pattern is too generic.
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies:
        - "GuardManager (state persistence)"

  # ============================================================================
  # PATTERN 4: Guard State Check (Early Exit)
  # ============================================================================
  - pattern_name: "guard-state-early-exit"
    hook_event: "UserPromptSubmit"
    source_repo: "tdd-guard"
    source_file: "src/hooks/userPromptHandler.ts"
    description: |
      Checks if the guard is disabled and returns early with no-op result,
      bypassing all validation logic. Provides efficient skip path when
      user has disabled enforcement.
    implementation:
      matcher: ""
      decision_type: "allow"
      exit_code: "0"
    technique:
      summary: "Check persistent state flag early, return default result if disabled"
      code_snippet: |
        async getDisabledResult(): Promise<ValidationResult | undefined> {
          const isEnabled = await this.guardManager.isEnabled()
          if (!isEnabled) {
            return { decision: undefined, reason: '' }
          }
          return undefined
        }

        // Called from processHookData.ts:
        const disabledResult = await userPromptHandler.getDisabledResult()
        if (disabledResult) {
          return disabledResult
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Productivity"
      when_to_use: |
        Pair with user-command-toggle pattern. Allows hooks to be disabled at
        runtime without uninstalling. Essential for any hook that provides
        an on/off toggle.
      when_not_to_use: |
        For critical safety hooks that should never be disabled. If state
        checking adds unacceptable latency to every hook call.
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies:
        - "GuardManager (reads config.json)"

  # ============================================================================
  # PATTERN 5: PostToolUse Lint Enforcement
  # ============================================================================
  - pattern_name: "post-tool-lint-enforcement"
    hook_event: "PostToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/postToolLint.ts"
    description: |
      Runs linter (ESLint) on modified files after Edit/Write/MultiEdit operations.
      Blocks further operations if lint issues exist and user was previously notified,
      enforcing code quality during the TDD refactor phase.
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Extract file paths from tool input, run linter, track notification state, block on repeat issues"
      code_snippet: |
        export async function handlePostToolLint(
          hookData: string,
          storage: Storage,
          linter: Linter
        ): Promise<ValidationResult> {
          const validatedHookData = parseAndValidateHookData(hookData)
          if (!validatedHookData) {
            return DEFAULT_RESULT
          }

          // Extract file paths from tool operation
          const filePaths = extractFilePaths(validatedHookData)
          if (filePaths.length === 0) {
            return DEFAULT_RESULT
          }

          // Get current lint data to check hasNotifiedAboutLintIssues state
          const storedLintData = await getStoredLintData(storage)

          // Run linting on the files
          const lintResults = await linter.lint(filePaths)

          // Create and save lint data
          const lintData = createLintData(lintResults, storedLintData)
          await storage.saveLint(JSON.stringify(lintData))

          const hasIssues = lintResults.errorCount > 0 || lintResults.warningCount > 0

          // Block if:
          // 1. PreToolUse has notified (flag is true)
          // 2. There are still issues
          if (storedLintData?.hasNotifiedAboutLintIssues && hasIssues) {
            return createBlockResult(lintData)
          }

          return DEFAULT_RESULT
        }

        function extractFilePaths(hookData: HookData): string[] {
          const toolInput = hookData.tool_input
          if (!toolInput || typeof toolInput !== 'object') return []

          const paths: string[] = []

          if ('file_path' in toolInput && typeof toolInput.file_path === 'string') {
            paths.push(toolInput.file_path)
          }

          // Handle multi-edit operations
          if ('edits' in toolInput && Array.isArray(toolInput.edits)) {
            for (const edit of toolInput.edits) {
              if ('file_path' in edit && typeof edit.file_path === 'string') {
                paths.push(edit.file_path)
              }
            }
          }

          return [...new Set(paths)] // Remove duplicates
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: |
        When blocking, provides formatted lint issues in the reason:
        "Lint issues detected: [file:line:col severity message]
        Please fix these issues before proceeding."
    use_case:
      category: "Quality"
      when_to_use: |
        Enforcing code quality standards after file modifications. Works in
        tandem with PreToolUse notification - first warn, then block on repeat.
        Ideal for TDD refactor phase enforcement.
      when_not_to_use: |
        If linting is slow and would disrupt workflow. If project doesn't
        have linter configured. If code quality is not a priority.
    quality:
      complexity: "medium"
      performance: "50-100ms"
      dependencies:
        - "ESLint (optional, via LinterProvider)"
        - "zod (schema validation)"

  # ============================================================================
  # PATTERN 6: File Path Extraction from Tool Input
  # ============================================================================
  - pattern_name: "tool-input-file-extraction"
    hook_event: "PostToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/postToolLint.ts"
    description: |
      Extracts file paths from tool_input for various tool types (Edit, Write,
      MultiEdit). Handles both single file_path and arrays of edits with
      file paths. Deduplicates results.
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Parse tool_input structure, extract file_path fields, handle arrays, deduplicate"
      code_snippet: |
        function extractFilePaths(hookData: HookData): string[] {
          const toolInput = hookData.tool_input
          if (!toolInput || typeof toolInput !== 'object') return []

          const paths: string[] = []

          if ('file_path' in toolInput && typeof toolInput.file_path === 'string') {
            paths.push(toolInput.file_path)
          }

          // Handle multi-edit operations
          if ('edits' in toolInput && Array.isArray(toolInput.edits)) {
            for (const edit of toolInput.edits) {
              if ('file_path' in edit && typeof edit.file_path === 'string') {
                paths.push(edit.file_path)
              }
            }
          }

          return [...new Set(paths)] // Remove duplicates
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - utility function"
    use_case:
      category: "Observability"
      when_to_use: |
        Any hook that needs to know which files were affected by a tool operation.
        Reusable utility pattern for file-based hooks.
      when_not_to_use: |
        If only tool name matters, not file paths. If file paths are not
        relevant to the hook's purpose.
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  # ============================================================================
  # PATTERN 7: Two-Phase Notification/Block Pattern
  # ============================================================================
  - pattern_name: "two-phase-notification-block"
    hook_event: "PostToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/postToolLint.ts"
    description: |
      Implements a two-phase enforcement pattern: 1) PreToolUse sets a notification
      flag and warns the user, 2) PostToolUse blocks if the flag is set AND issues
      persist. This gives the agent one chance to fix issues before blocking.
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Track notification state in storage, warn first time, block on persistence"
      code_snippet: |
        function createLintData(
          lintResults: LintResult,
          storedLintData: LintData | null
        ): LintData {
          const hasIssues = lintResults.errorCount > 0 || lintResults.warningCount > 0

          return {
            ...lintResults,
            hasNotifiedAboutLintIssues: hasIssues
              ? (storedLintData?.hasNotifiedAboutLintIssues ?? false)  // Preserve flag when issues exist
              : false  // Reset flag when no issues
          }
        }

        // Block logic in handlePostToolLint:
        // Block if:
        // 1. PreToolUse has notified (flag is true)
        // 2. There are still issues
        if (storedLintData?.hasNotifiedAboutLintIssues && hasIssues) {
          return createBlockResult(lintData)
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: |
        Detailed lint error report with file paths, line numbers, and messages.
        Includes problem count summary and actionable guidance.
    use_case:
      category: "Quality"
      when_to_use: |
        When immediate blocking would be too disruptive but repeated issues
        should be enforced. Provides a "warning shot" before hard blocking.
        Good for teaching/onboarding scenarios.
      when_not_to_use: |
        For critical safety issues that must be blocked immediately.
        If the two-phase dance creates confusing UX.
    quality:
      complexity: "medium"
      performance: "10-50ms"
      dependencies:
        - "Storage (for state persistence)"

  # ============================================================================
  # PATTERN 8: Formatted Issue Reporting
  # ============================================================================
  - pattern_name: "formatted-issue-reporting"
    hook_event: "PostToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/postToolLint.ts"
    description: |
      Formats lint issues into a structured, readable report grouped by file.
      Provides clear feedback to Claude about what needs fixing, including
      line numbers, severity, messages, and rule names.
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Group issues by file, format with line:col, include severity and rule, add summary"
      code_snippet: |
        function createBlockResult(lintData: LintData): ValidationResult {
          const formattedIssues = formatLintIssues(lintData.issues)
          const summary = `\n\u2716 ${lintData.errorCount + lintData.warningCount} problems (${lintData.errorCount} errors, ${lintData.warningCount} warnings)`

          return {
            decision: 'block',
            reason: `Lint issues detected:${formattedIssues}\n${summary}\n\nPlease fix these issues before proceeding.`
          }
        }

        function formatLintIssues(issues: LintData['issues']): string {
          const issuesByFile = new Map<string, string[]>()

          for (const issue of issues) {
            if (!issuesByFile.has(issue.file)) {
              issuesByFile.set(issue.file, [])
            }
            const ruleInfo = issue.rule ? `  ${issue.rule}` : ''
            issuesByFile.get(issue.file)!.push(
              `  ${issue.line}:${issue.column}  ${issue.severity}  ${issue.message}${ruleInfo}`
            )
          }

          let formattedIssues = ''
          for (const [file, fileIssues] of issuesByFile) {
            formattedIssues += `\n${file}\n${fileIssues.join('\n')}`
          }

          return formattedIssues
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: |
        Formatted lint report in ESLint-style output:
        /path/to/file.ts
          10:5  error  Missing semicolon  semi
          15:1  warning  Unexpected console statement  no-console
        [count] problems (X errors, Y warnings)
    use_case:
      category: "Communication"
      when_to_use: |
        When providing feedback that Claude needs to act on. Structured formatting
        helps Claude parse and understand the issues. Mimics familiar tool output.
      when_not_to_use: |
        For simple yes/no decisions. If the information doesn't need to
        be actionable by Claude.
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  # ============================================================================
  # PATTERN 9: Persistent State via JSON Files
  # ============================================================================
  - pattern_name: "json-file-state-persistence"
    hook_event: "PostToolUse"
    source_repo: "tdd-guard"
    source_file: "src/storage/FileStorage.ts"
    description: |
      Uses JSON files in .claude/tdd-guard/data/ directory for state persistence.
      Separates transient data (cleared on session start) from persistent config.
      Provides type-safe storage abstraction.
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Abstract Storage interface with FileStorage implementation using JSON files"
      code_snippet: |
        export const TRANSIENT_DATA = ['test', 'todo', 'modifications', 'lint'] as const

        export interface Storage {
          saveTest(content: string): Promise<void>
          saveTodo(content: string): Promise<void>
          saveModifications(content: string): Promise<void>
          saveLint(content: string): Promise<void>
          saveConfig(content: string): Promise<void>
          saveInstructions(content: string): Promise<void>
          getTest(): Promise<string | null>
          getTodo(): Promise<string | null>
          getModifications(): Promise<string | null>
          getLint(): Promise<string | null>
          getConfig(): Promise<string | null>
          getInstructions(): Promise<string | null>
          clearTransientData(): Promise<void>
        }

        export class FileStorage implements Storage {
          private readonly filePaths: Record<string, string>

          constructor(config?: Config) {
            this.config = config ?? new Config()
            this.filePaths = {
              test: this.config.testResultsFilePath,
              todo: this.config.todosFilePath,
              modifications: this.config.modificationsFilePath,
              lint: this.config.lintFilePath,
              config: this.config.configFilePath,
              instructions: this.config.instructionsFilePath,
            }
          }

          async clearTransientData(): Promise<void> {
            await Promise.all(
              TRANSIENT_DATA.map((fileType) =>
                this.deleteFileIfExists(this.filePaths[fileType])
              )
            )
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: |
        State files stored in .claude/tdd-guard/data/:
        - test.json: Latest test results
        - todos.json: Current todo state
        - modifications.json: File change history
        - lint.json: Lint results with notification flag
        - config.json: Guard enable/disable state
        - instructions.md: TDD validation rules
    use_case:
      category: "Context"
      when_to_use: |
        Any hook needing state across multiple hook invocations within a session.
        Using .claude/ subdirectory keeps state organized and gitignore-friendly.
      when_not_to_use: |
        For simple stateless hooks. If file I/O latency is a concern.
        If state should not survive process restart.
    quality:
      complexity: "medium"
      performance: "10-50ms"
      dependencies: []

  # ============================================================================
  # PATTERN 10: Unified Hook Router
  # ============================================================================
  - pattern_name: "unified-hook-router"
    hook_event: "PostToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/processHookData.ts"
    description: |
      Single entry point that routes all hook events (SessionStart, UserPromptSubmit,
      PreToolUse, PostToolUse) to specialized handlers. Enables unified configuration
      where the same command handles multiple hook types.
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Parse hook_event_name, dispatch to specialized handlers, compose results"
      code_snippet: |
        export async function processHookData(
          inputData: string,
          deps: ProcessHookDataDeps = {}
        ): Promise<ValidationResult> {
          const parsedData = JSON.parse(inputData)

          // Initialize dependencies
          const storage = deps.storage ?? new FileStorage()
          const guardManager = new GuardManager(storage)
          const userPromptHandler = deps.userPromptHandler ?? new UserPromptHandler(guardManager)

          // Process SessionStart events
          if (parsedData.hook_event_name === 'SessionStart') {
            await sessionHandler.processSessionStart(inputData)
            return defaultResult
          }

          // Process user commands
          const stateResult = await userPromptHandler.processUserCommand(inputData)
          if (stateResult) {
            return stateResult
          }

          // Check if guard is disabled
          const disabledResult = await userPromptHandler.getDisabledResult()
          if (disabledResult) {
            return disabledResult
          }

          // Check if this is a PostToolUse event
          if (hookResult.data.hook_event_name === 'PostToolUse') {
            return await lintHandler.handle(inputData)
          }

          // PreToolUse validation logic...
          return await performValidation(deps)
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - routing logic only"
    use_case:
      category: "Coordination"
      when_to_use: |
        When building a multi-hook system that shares state and logic. Simplifies
        configuration (one command for all hooks) and enables cross-hook coordination.
      when_not_to_use: |
        For simple single-purpose hooks. If hooks are truly independent with no
        shared state. If separate binaries are preferred for isolation.
    quality:
      complexity: "medium"
      performance: "<10ms"
      dependencies:
        - "zod (schema validation)"
        - "SessionHandler"
        - "UserPromptHandler"
        - "PostToolLintHandler"

  # ============================================================================
  # PATTERN 11: File Ignore Patterns
  # ============================================================================
  - pattern_name: "file-ignore-patterns"
    hook_event: "PostToolUse"
    source_repo: "tdd-guard"
    source_file: "src/guard/GuardManager.ts"
    description: |
      Skips validation for files matching configurable glob patterns. Default patterns
      exclude non-code files (*.md, *.json, *.yml, etc.). Uses minimatch for flexible
      pattern matching.
    implementation:
      matcher: ""
      decision_type: "allow"
      exit_code: "0"
    technique:
      summary: "Check file path against ignore patterns before processing, skip if match"
      code_snippet: |
        export class GuardManager {
          private readonly minimatchOptions = {
            matchBase: true, // allows *.ext to match in any directory
            nobrace: false, // enables brace expansion {a,b}
            dot: true, // allows patterns to match files/dirs starting with .
          } as const

          static readonly DEFAULT_IGNORE_PATTERNS = [
            '*.md',
            '*.txt',
            '*.log',
            '*.json',
            '*.yml',
            '*.yaml',
            '*.xml',
            '*.html',
            '*.css',
            '*.rst',
          ]

          async getIgnorePatterns(): Promise<string[]> {
            const config = await this.getConfig()
            return config?.ignorePatterns ?? GuardManager.DEFAULT_IGNORE_PATTERNS
          }

          async shouldIgnoreFile(filePath: string): Promise<boolean> {
            const patterns = await this.getIgnorePatterns()
            return patterns.some((pattern) =>
              minimatch(filePath, pattern, this.minimatchOptions)
            )
          }
        }

        // Called from processHookData.ts:
        const filePath = extractFilePath(parsedData)
        if (filePath && await guardManager.shouldIgnoreFile(filePath)) {
          return defaultResult
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Productivity"
      when_to_use: |
        When hook validation should not apply to all file types. Essential for
        reducing noise and false positives. Allow users to customize via config.
      when_not_to_use: |
        For hooks that must examine all files regardless of type.
        If pattern matching adds significant overhead.
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies:
        - "minimatch (glob pattern matching)"

# Additional context for researchers:
architecture_notes:
  entry_point: |
    src/cli/tdd-guard.ts - Reads stdin, calls processHookData, outputs JSON to stdout.
    Same binary handles all hook types via unified router pattern.

  data_directory: |
    .claude/tdd-guard/data/ - Stores all state files:
    - test.json: Latest test runner output
    - todos.json: Claude's current todo list
    - modifications.json: File change history
    - lint.json: ESLint results with notification tracking
    - config.json: Guard enable/disable state
    - instructions.md: Custom TDD validation rules

  hook_configuration: |
    {
      "hooks": {
        "SessionStart": [{ "matcher": "startup|resume|clear", "hooks": [{ "type": "command", "command": "tdd-guard" }] }],
        "UserPromptSubmit": [{ "hooks": [{ "type": "command", "command": "tdd-guard" }] }],
        "PreToolUse": [{ "matcher": "Write|Edit|MultiEdit|TodoWrite", "hooks": [{ "type": "command", "command": "tdd-guard" }] }],
        "PostToolUse": [{ "matcher": "Write|Edit|MultiEdit", "hooks": [{ "type": "command", "command": "tdd-guard" }] }]
      }
    }

  dependency_injection: |
    Uses constructor injection for testability. All handlers accept optional
    dependencies, defaulting to production implementations. Enables MemoryStorage
    for unit tests.
