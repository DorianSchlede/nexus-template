# TDD Guard PreToolUse Hook Patterns
# Extracted from: https://github.com/nizos/tdd-guard
# Focus: PreToolUse implementations for TDD enforcement

patterns:

  # =============================================================================
  # PATTERN 1: TDD Validation Gate
  # =============================================================================
  - pattern_name: "tdd-validation-gate"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/processHookData.ts"
    description: "Intercepts Write/Edit/MultiEdit operations and validates them against TDD principles using an AI model. Blocks operations that violate test-first development."
    implementation:
      matcher: "Write|Edit|MultiEdit|TodoWrite"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Captures file operations, builds context from test results/modifications/todos, sends to AI model for TDD compliance check, returns block decision with actionable reason."
      code_snippet: |
        export async function processHookData(
          inputData: string,
          deps: ProcessHookDataDeps = {}
        ): Promise<ValidationResult> {
          const parsedData = JSON.parse(inputData)
          const storage = deps.storage ?? new FileStorage()
          const guardManager = new GuardManager(storage)

          // Skip validation for ignored files based on patterns
          const filePath = extractFilePath(parsedData)
          if (filePath && await guardManager.shouldIgnoreFile(filePath)) {
            return defaultResult
          }

          // Check if guard is disabled and return early
          const disabledResult = await userPromptHandler.getDisabledResult()
          if (disabledResult) {
            return disabledResult
          }

          // Perform TDD validation
          return await performValidation(deps)
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "AI-generated TDD violation explanation with specific next steps for the agent to follow. Examples: 'Over-implementation violation - create only empty class first', 'Multiple test addition - write only ONE test at a time'."
    use_case:
      category: "Quality"
      when_to_use: "When enforcing strict TDD methodology in AI-assisted development. Prevents implementation without failing tests, over-implementation, and multiple test additions."
      when_not_to_use: "Quick prototyping, exploratory coding, or when working on non-testable files like configuration or documentation."
    quality:
      complexity: "high"
      performance: ">100ms"
      dependencies: ["zod", "minimatch", "dotenv", "@anthropic-ai/sdk"]

  # =============================================================================
  # PATTERN 2: Lint Issue Notification Block
  # =============================================================================
  - pattern_name: "lint-notification-block"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/processHookData.ts"
    description: "When tests are passing but lint issues exist, blocks further edits until refactoring is addressed. Implements the Refactor phase of Red-Green-Refactor."
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Checks if tests are passing and lint issues exist. If conditions met and not yet notified, blocks with refactoring instructions. Uses hasNotifiedAboutLintIssues flag to avoid repeated blocking."
      code_snippet: |
        async function checkLintNotification(
          storage: Storage,
          hookData: HookData
        ): Promise<ValidationResult> {
          // Check if tests are passing
          const testStr = await storage.getTest()
          const testResult = TestResultSchema.safeParse(JSON.parse(testStr))
          if (!isTestPassing(testResult.data)) {
            return defaultResult
          }

          // Get lint data
          const lintData = LintDataSchema.parse(JSON.parse(await storage.getLint()))
          const hasIssues = lintData.errorCount > 0 || lintData.warningCount > 0

          // Block if issues exist and not yet notified
          if (hasIssues && !lintData.hasNotifiedAboutLintIssues) {
            await storage.saveLint(JSON.stringify({
              ...lintData,
              hasNotifiedAboutLintIssues: true
            }))

            return {
              decision: 'block',
              reason: 'Code quality issues detected. Fix those first...'
            }
          }
          return defaultResult
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Refactoring guidance including SOLID principles, DRY, design patterns, and architectural improvements. Applies equally to implementation and test code."
    use_case:
      category: "Quality"
      when_to_use: "During the Refactor phase of TDD when tests are green but code quality issues remain. Enforces cleanup before adding new features."
      when_not_to_use: "When lint is not configured or when working on files that should bypass lint checks."
    quality:
      complexity: "medium"
      performance: "10-50ms"
      dependencies: ["zod"]

  # =============================================================================
  # PATTERN 3: File Pattern Ignore Gate
  # =============================================================================
  - pattern_name: "file-pattern-ignore-gate"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/guard/GuardManager.ts"
    description: "Skips validation entirely for files matching configurable glob patterns. Default patterns exclude markdown, config files, and other non-code files."
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "allow"
      exit_code: "0"
    technique:
      summary: "Uses minimatch with glob patterns to check if file path should bypass validation. Supports matchBase for simple patterns like *.md, brace expansion, and dotfiles."
      code_snippet: |
        export class GuardManager {
          private readonly minimatchOptions = {
            matchBase: true,  // allows *.ext to match in any directory
            nobrace: false,   // enables brace expansion {a,b}
            dot: true,        // allows patterns to match files starting with .
          } as const

          static readonly DEFAULT_IGNORE_PATTERNS = [
            '*.md', '*.txt', '*.log', '*.json',
            '*.yml', '*.yaml', '*.xml', '*.html',
            '*.css', '*.rst',
          ]

          async shouldIgnoreFile(filePath: string): Promise<boolean> {
            const patterns = await this.getIgnorePatterns()
            return patterns.some((pattern) =>
              minimatch(filePath, pattern, this.minimatchOptions)
            )
          }
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - validation is bypassed entirely for matching files"
    use_case:
      category: "Productivity"
      when_to_use: "When you want to exclude documentation, configuration files, or other non-code files from TDD enforcement."
      when_not_to_use: "When all files should be validated regardless of type."
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: ["minimatch"]

  # =============================================================================
  # PATTERN 4: Guard Toggle State Check
  # =============================================================================
  - pattern_name: "guard-toggle-state-check"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/processHookData.ts"
    description: "Checks if TDD Guard is currently enabled before performing validation. Allows users to temporarily disable enforcement via 'tdd-guard off' command."
    implementation:
      matcher: "Write|Edit|MultiEdit|TodoWrite"
      decision_type: "allow"
      exit_code: "0"
    technique:
      summary: "Reads guard enabled state from persistent storage. If disabled, returns early with empty result allowing operation to proceed without validation."
      code_snippet: |
        // In processHookData
        const disabledResult = await userPromptHandler.getDisabledResult()
        if (disabledResult) {
          return disabledResult  // { decision: undefined, reason: '' }
        }

        // In UserPromptHandler
        async getDisabledResult(): Promise<ValidationResult | undefined> {
          const isEnabled = await this.guardManager.isEnabled()
          if (!isEnabled) {
            return { decision: undefined, reason: '' }
          }
          return undefined
        }

        // In GuardManager
        async isEnabled(): Promise<boolean> {
          const config = await this.getConfig()
          return config?.guardEnabled ?? true
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - validation is bypassed when guard is disabled"
    use_case:
      category: "Productivity"
      when_to_use: "When you need to temporarily bypass TDD enforcement for specific tasks without removing the hook configuration."
      when_not_to_use: "When TDD enforcement should always be active regardless of user commands."
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: ["zod"]

  # =============================================================================
  # PATTERN 5: TodoWrite Skip Pattern
  # =============================================================================
  - pattern_name: "todowrite-skip-validation"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/processHookData.ts"
    description: "Captures TodoWrite operations for context but skips TDD validation. Todo items are persisted and used as context for future validations."
    implementation:
      matcher: "TodoWrite"
      decision_type: "allow"
      exit_code: "0"
    technique:
      summary: "Uses discriminated union with Zod to identify TodoWrite operations. Persists todo state for context but returns immediately without blocking."
      code_snippet: |
        function shouldSkipValidation(hookData: HookData): boolean {
          const operationResult = ToolOperationSchema.safeParse({
            ...hookData,
            tool_input: hookData.tool_input,
          })
          return !operationResult.success ||
                 isTodoWriteOperation(operationResult.data)
        }

        // Type guard for TodoWrite
        export const isTodoWriteOperation = (
          op: ToolOperation
        ): op is TodoWriteOperation => op.tool_name === 'TodoWrite'

        // Discriminated union schema
        export const ToolOperationSchema = z.discriminatedUnion('tool_name', [
          EditOperationSchema,
          MultiEditOperationSchema,
          WriteOperationSchema,
          TodoWriteOperationSchema,
        ])
    context_loading:
      mechanism: "none"
      what_loaded: "TodoWrite data is persisted to storage for future context, but no blocking or modification occurs."
    use_case:
      category: "Context"
      when_to_use: "When you want to capture tool operations for context without blocking them. Useful for metadata operations like todos, bookmarks, or tags."
      when_not_to_use: "When the operation should be validated or blocked based on its content."
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: ["zod"]

  # =============================================================================
  # PATTERN 6: AI-Powered TDD Compliance Validation
  # =============================================================================
  - pattern_name: "ai-tdd-compliance-validator"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/validation/validator.ts"
    description: "Sends operation context to an AI model that evaluates TDD compliance and returns a structured block/approve decision with explanation."
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Builds dynamic context from modifications, test results, todos, and lint data. Sends to AI model with TDD rules prompt. Parses JSON response with decision and reason."
      code_snippet: |
        export async function validator(
          context: Context,
          modelClient: IModelClient = new ClaudeCli()
        ): Promise<ValidationResult> {
          try {
            const prompt = generateDynamicContext(context)
            const response = await modelClient.ask(prompt)
            return parseModelResponse(response)
          } catch (error) {
            return {
              decision: 'block',
              reason: `Error during validation: ${error.message}`,
            }
          }
        }

        function parseModelResponse(response: string): ValidationResult {
          const jsonString = extractJsonString(response)
          const parsed = JSON.parse(jsonString)
          return {
            decision: parsed.decision ?? undefined,
            reason: parsed.reason,
          }
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Detailed TDD violation explanation generated by AI model. Includes specific violation type, why it violates TDD, and exact next steps to take."
    use_case:
      category: "Quality"
      when_to_use: "When you need intelligent, context-aware validation that can understand code semantics and TDD principles beyond simple pattern matching."
      when_not_to_use: "When fast, deterministic validation is required or when AI costs are a concern."
    quality:
      complexity: "high"
      performance: ">100ms"
      dependencies: ["@anthropic-ai/sdk", "claude CLI"]

  # =============================================================================
  # PATTERN 7: Multi-Language File Type Detection
  # =============================================================================
  - pattern_name: "multi-language-file-detection"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/hooks/fileTypeDetection.ts"
    description: "Detects programming language from file path to select appropriate test result parser. Supports Python, PHP, and JavaScript/TypeScript."
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Extracts file_path from tool_input and checks file extension. Returns language type for appropriate test result schema selection."
      code_snippet: |
        export function detectFileType(
          hookData: unknown
        ): 'python' | 'javascript' | 'php' {
          const toolInput = (hookData as {
            tool_input?: Record<string, unknown>
          }).tool_input

          if (toolInput && typeof toolInput === 'object' &&
              'file_path' in toolInput) {
            const filePath = toolInput.file_path
            if (typeof filePath === 'string') {
              if (filePath.endsWith('.py')) return 'python'
              if (filePath.endsWith('.php')) return 'php'
            }
          }
          return 'javascript'
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - used internally for schema selection, not context injection"
    use_case:
      category: "Context"
      when_to_use: "When hook behavior needs to vary based on file type or language. Useful for language-specific validation, formatting, or tool selection."
      when_not_to_use: "When a single behavior applies to all file types."
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  # =============================================================================
  # PATTERN 8: Context Assembly from Multiple Sources
  # =============================================================================
  - pattern_name: "multi-source-context-assembly"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/cli/buildContext.ts"
    description: "Assembles validation context from multiple persistent storage sources: modifications, test results, todos, lint data, and custom instructions."
    implementation:
      matcher: "Write|Edit|MultiEdit"
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Uses Promise.all to fetch all context sources in parallel from storage. Processes lint data and formats modifications before returning unified context object."
      code_snippet: |
        export async function buildContext(storage: Storage): Promise<Context> {
          const [modifications, rawTest, todo, lint, instructions] =
            await Promise.all([
              storage.getModifications(),
              storage.getTest(),
              storage.getTodo(),
              storage.getLint(),
              storage.getInstructions(),
            ])

          let processedLintData
          try {
            if (lint) {
              const rawLintData = LintDataSchema.parse(JSON.parse(lint))
              processedLintData = processLintData(rawLintData)
            }
          } catch {
            processedLintData = processLintData()
          }

          return {
            modifications: formatModifications(modifications ?? ''),
            test: rawTest ?? '',
            todo: todo ?? '',
            lint: processedLintData,
            instructions: instructions ?? undefined,
          }
        }
    context_loading:
      mechanism: "systemMessage"
      what_loaded: "Complete context including: file modifications (old/new content), test results (pass/fail with output), todo items, lint issues, and custom TDD rules."
    use_case:
      category: "Context"
      when_to_use: "When validation requires multiple data sources that need to be combined. Enables rich context for AI-based decisions."
      when_not_to_use: "When validation only needs the immediate tool input without historical context."
    quality:
      complexity: "medium"
      performance: "10-50ms"
      dependencies: ["zod"]

  # =============================================================================
  # PATTERN 9: Zod Schema-Based Input Validation
  # =============================================================================
  - pattern_name: "zod-schema-input-validation"
    hook_event: "PreToolUse"
    source_repo: "tdd-guard"
    source_file: "src/contracts/schemas/toolSchemas.ts"
    description: "Uses Zod schemas with discriminated unions to parse and validate hook input data. Provides type-safe access to tool-specific fields."
    implementation:
      matcher: "Write|Edit|MultiEdit|TodoWrite"
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Defines Zod schemas for each tool type (Edit, MultiEdit, Write, TodoWrite). Uses discriminatedUnion on tool_name for efficient parsing. Provides type guards for runtime checking."
      code_snippet: |
        // Base schema for all hooks
        export const HookDataSchema = HookContextSchema.extend({
          tool_name: z.string(),
          tool_input: z.unknown(),
        })

        // Tool-specific operation schemas
        export const EditOperationSchema = HookContextSchema.extend({
          tool_name: z.literal('Edit'),
          tool_input: EditSchema,  // file_path, old_string, new_string
        })

        // Discriminated union for efficient parsing
        export const ToolOperationSchema = z.discriminatedUnion('tool_name', [
          EditOperationSchema,
          MultiEditOperationSchema,
          WriteOperationSchema,
          TodoWriteOperationSchema,
        ])

        // Type guards for runtime checking
        export const isEditOperation = (op: ToolOperation): op is EditOperation =>
          op.tool_name === 'Edit'
    context_loading:
      mechanism: "none"
      what_loaded: "N/A - used for input validation and type safety"
    use_case:
      category: "Safety"
      when_to_use: "When you need type-safe parsing of hook input with clear error messages. Essential for TypeScript hooks that process structured data."
      when_not_to_use: "For simple hooks that only check tool_name without processing tool_input."
    quality:
      complexity: "medium"
      performance: "<10ms"
      dependencies: ["zod"]

# =============================================================================
# SUMMARY
# =============================================================================
summary:
  total_patterns: 9
  categories:
    Quality: 3
    Productivity: 2
    Context: 3
    Safety: 1
  key_techniques:
    - "AI-powered semantic validation with structured JSON responses"
    - "Multi-source context assembly for rich validation context"
    - "Glob pattern matching for file-based bypass"
    - "State machine for notification flags (hasNotifiedAboutLintIssues)"
    - "Zod discriminated unions for type-safe tool operation handling"
    - "Parallel Promise.all for efficient multi-source data fetching"
  architecture_highlights:
    - "Modular design with dependency injection (Storage, ModelClient, Linter)"
    - "Clear separation: hooks (capture) -> processors (format) -> validators (decide)"
    - "Persistent storage for cross-hook state (.claude/tdd-guard/data/)"
    - "Support for multiple AI clients (SDK, API, CLI)"
    - "Multi-language support via test reporters (Vitest, Jest, pytest, PHPUnit, Go, Rust)"
