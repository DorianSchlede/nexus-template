# Claude Hooks TypeScript SDK - Pattern Extraction
# Source: https://github.com/johnlindquist/claude-hooks
# Language: TypeScript
# Extracted: 2025-12-31

metadata:
  source_repo: "claude-hooks"
  language: "TypeScript"
  runtime: "Bun"
  architecture: "oclif CLI + Bun template system"
  description: "TypeScript-powered hook system for Claude Code with full type safety, auto-completion, and strongly-typed payloads"
  repository_url: "https://github.com/johnlindquist/claude-hooks"
  npm_package: "claude-hooks"

# ==============================================================================
# SDK ABSTRACTIONS
# ==============================================================================
sdk_abstractions:
  - pattern_name: "type-safe-hook-runner"
    source_file: "templates/hooks/lib.ts"
    description: "Central hook dispatcher that routes stdin JSON payloads to type-safe handlers based on hook_type argument"
    technique:
      summary: "Single entrypoint script receives hook type as CLI arg, parses stdin JSON, routes to registered handler functions with full TypeScript typing"
      code_snippet: |
        export function runHook(handlers: HookHandlers): void {
          const hook_type = process.argv[2]

          process.stdin.on('data', async (data) => {
            try {
              const inputData = JSON.parse(data.toString())
              const payload: HookPayload = {
                ...inputData,
                hook_type: hook_type as HookPayload['hook_type'],
              }

              switch (payload.hook_type) {
                case 'PreToolUse':
                  if (handlers.preToolUse) {
                    const response = await handlers.preToolUse(payload)
                    console.log(JSON.stringify(response))
                  } else {
                    console.log(JSON.stringify({}))
                  }
                  break
                // ... other cases
              }
            } catch (error) {
              console.log(JSON.stringify({action: 'continue'}))
            }
          })
        }
    use_case:
      category: "SDK"
      when_to_use: "When building a unified TypeScript hook system with all handlers in one file"
      when_not_to_use: "When you need separate processes for each hook type"
    quality:
      complexity: "medium"
      performance: "<10ms"
      dependencies: ["bun"]

  - pattern_name: "typed-handler-registry"
    source_file: "templates/hooks/lib.ts"
    description: "Interface defining all possible hook handlers with proper payload and response types"
    technique:
      summary: "TypeScript interface with optional handler functions for each hook type, enabling compile-time type checking"
      code_snippet: |
        export interface HookHandlers {
          preToolUse?: PreToolUseHandler
          postToolUse?: PostToolUseHandler
          notification?: NotificationHandler
          stop?: StopHandler
          subagentStop?: SubagentStopHandler
          userPromptSubmit?: UserPromptSubmitHandler
          preCompact?: PreCompactHandler
          sessionStart?: SessionStartHandler
        }
    use_case:
      category: "SDK"
      when_to_use: "When defining a type-safe hook registration system"
      when_not_to_use: "When hooks are simple shell scripts"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "session-state-persistence"
    source_file: "templates/hooks/session.ts"
    description: "Utility for persisting hook payloads to session-specific JSON files in temp directory"
    technique:
      summary: "Appends hook invocations to session-specific JSON file for debugging and analysis"
      code_snippet: |
        const SESSIONS_DIR = path.join(tmpdir(), 'claude-hooks-sessions')

        export async function saveSessionData(hookType: string, payload: HookPayload): Promise<void> {
          try {
            await mkdir(SESSIONS_DIR, {recursive: true})
            const sessionFile = path.join(SESSIONS_DIR, `${payload.session_id}.json`)

            let sessionData: Array<{timestamp: string; hookType: string; payload: HookPayload}> = []
            try {
              const existing = await readFile(sessionFile, 'utf-8')
              sessionData = JSON.parse(existing)
            } catch {}

            sessionData.push({ timestamp: new Date().toISOString(), hookType, payload })
            await writeFile(sessionFile, JSON.stringify(sessionData, null, 2))
          } catch (error) {
            console.error('Failed to save session data:', error)
          }
        }
    context_loading:
      mechanism: "state_file"
      what_loaded: "Complete hook invocation history per session for debugging"
    use_case:
      category: "Observability"
      when_to_use: "When debugging hook behavior or analyzing session patterns"
      when_not_to_use: "In production where disk I/O overhead is a concern"
    quality:
      complexity: "low"
      performance: "10-50ms"
      dependencies: ["node:fs/promises", "node:os"]

  - pattern_name: "transcript-reader-utilities"
    source_file: "templates/hooks/lib.ts"
    description: "Comprehensive utilities for reading and parsing Claude transcript JSONL files"
    technique:
      summary: "Async stream-based transcript parsing with typed message interfaces for user/assistant/summary messages"
      code_snippet: |
        export async function getInitialMessage(transcriptPath: string): Promise<string | null> {
          const fileStream = fs.createReadStream(transcriptPath)
          const rl = readline.createInterface({ input: fileStream, crlfDelay: Infinity })

          for await (const line of rl) {
            if (!line.trim()) continue
            const message = JSON.parse(line) as TranscriptMessage
            if (message.type === 'summary') continue
            if (message.type === 'user' && message.message.role === 'user') {
              if (typeof message.message.content === 'string') {
                return message.message.content
              }
            }
          }
          return null
        }

        export async function getConversationHistory(transcriptPath: string): Promise<Array<{role: 'user' | 'assistant'; content: string}>>
        export async function getToolUsage(transcriptPath: string): Promise<Array<{tool: string; input: Record<string, unknown>; timestamp: string}>>
    context_loading:
      mechanism: "transcript_reading"
      what_loaded: "Full conversation history, tool usage patterns, initial user message"
    use_case:
      category: "Context"
      when_to_use: "When hooks need conversation context or history for decision-making"
      when_not_to_use: "For simple stateless hooks that don't need context"
    quality:
      complexity: "medium"
      performance: "50-100ms"
      dependencies: ["fs", "readline"]

  - pattern_name: "transcript-message-types"
    source_file: "templates/hooks/lib.ts"
    description: "Complete TypeScript interfaces for Claude transcript JSONL message format"
    technique:
      summary: "Discriminated union types for transcript messages (summary, user, assistant) with full content typing"
      code_snippet: |
        export interface TranscriptUserMessage {
          parentUuid: string | null
          isSidechain: boolean
          userType: 'external'
          cwd: string
          sessionId: string
          version: string
          gitBranch?: string
          type: 'user'
          message: {
            role: 'user'
            content: string | Array<{tool_use_id?: string; type: 'tool_result' | 'text'; content?: string; is_error?: boolean}>
          }
          uuid: string
          timestamp: string
        }

        export interface TranscriptAssistantMessage {
          message: {
            id: string; type: 'message'; role: 'assistant'; model: string
            content: Array<{type: 'text' | 'tool_use'; text?: string; id?: string; name?: string; input?: Record<string, unknown>}>
            usage: {input_tokens: number; output_tokens: number; /* ... */}
          }
          type: 'assistant'
        }

        export type TranscriptMessage = TranscriptSummary | TranscriptUserMessage | TranscriptAssistantMessage
    use_case:
      category: "SDK"
      when_to_use: "When building tools that analyze or process Claude transcripts"
      when_not_to_use: "When not interacting with transcript files"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

# ==============================================================================
# TYPE DEFINITIONS
# ==============================================================================
type_definitions:
  payload_types:
    - name: "PreToolUsePayload"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "session_id", type: "string" }
        - { name: "transcript_path", type: "string" }
        - { name: "hook_event_name", type: "'PreToolUse'" }
        - { name: "tool_name", type: "string" }
        - { name: "tool_input", type: "Record<string, unknown>" }

    - name: "PostToolUsePayload"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "session_id", type: "string" }
        - { name: "transcript_path", type: "string" }
        - { name: "hook_event_name", type: "'PostToolUse'" }
        - { name: "tool_name", type: "string" }
        - { name: "tool_input", type: "Record<string, unknown>" }
        - { name: "tool_response", type: "Record<string, unknown> & { success?: boolean }" }

    - name: "NotificationPayload"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "session_id", type: "string" }
        - { name: "transcript_path", type: "string" }
        - { name: "hook_event_name", type: "'Notification'" }
        - { name: "message", type: "string" }
        - { name: "title", type: "string (optional)" }

    - name: "StopPayload"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "session_id", type: "string" }
        - { name: "transcript_path", type: "string" }
        - { name: "hook_event_name", type: "'Stop'" }
        - { name: "stop_hook_active", type: "boolean" }

    - name: "SubagentStopPayload"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "session_id", type: "string" }
        - { name: "transcript_path", type: "string" }
        - { name: "hook_event_name", type: "'SubagentStop'" }
        - { name: "stop_hook_active", type: "boolean" }

    - name: "UserPromptSubmitPayload"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "session_id", type: "string" }
        - { name: "transcript_path", type: "string" }
        - { name: "hook_event_name", type: "'UserPromptSubmit'" }
        - { name: "prompt", type: "string" }

    - name: "PreCompactPayload"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "session_id", type: "string" }
        - { name: "transcript_path", type: "string" }
        - { name: "hook_event_name", type: "'PreCompact'" }
        - { name: "trigger", type: "'manual' | 'auto'" }

    - name: "SessionStartPayload"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "session_id", type: "string" }
        - { name: "transcript_path", type: "string" }
        - { name: "hook_event_name", type: "'SessionStart'" }
        - { name: "source", type: "string" }

  response_types:
    - name: "BaseHookResponse"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "continue", type: "boolean (optional)" }
        - { name: "stopReason", type: "string (optional)" }
        - { name: "suppressOutput", type: "boolean (optional)" }

    - name: "PreToolUseResponse"
      source_file: "templates/hooks/lib.ts"
      extends: "BaseHookResponse"
      fields:
        - { name: "permissionDecision", type: "'allow' | 'deny' | 'ask' (optional)" }
        - { name: "permissionDecisionReason", type: "string (optional)" }

    - name: "PostToolUseResponse"
      source_file: "templates/hooks/lib.ts"
      extends: "BaseHookResponse"
      fields:
        - { name: "decision", type: "'block' (optional)" }
        - { name: "reason", type: "string (optional)" }

    - name: "StopResponse"
      source_file: "templates/hooks/lib.ts"
      extends: "BaseHookResponse"
      fields:
        - { name: "decision", type: "'block' (optional)" }
        - { name: "reason", type: "string (required when decision is 'block')" }

    - name: "UserPromptSubmitResponse"
      source_file: "templates/hooks/lib.ts"
      extends: "BaseHookResponse"
      fields:
        - { name: "decision", type: "'approve' | 'block' (optional)" }
        - { name: "reason", type: "string (optional)" }
        - { name: "contextFiles", type: "string[] (optional)" }
        - { name: "updatedPrompt", type: "string (optional)" }
        - { name: "hookSpecificOutput", type: "{ hookEventName: 'UserPromptSubmit'; additionalContext?: string } (optional)" }

    - name: "PreCompactResponse"
      source_file: "templates/hooks/lib.ts"
      extends: "BaseHookResponse"
      fields:
        - { name: "decision", type: "'approve' | 'block' (optional)" }
        - { name: "reason", type: "string (optional)" }

    - name: "SessionStartResponse"
      source_file: "templates/hooks/lib.ts"
      extends: "BaseHookResponse"
      fields:
        - { name: "decision", type: "'approve' | 'block' (optional)" }
        - { name: "reason", type: "string (optional)" }
        - { name: "hookSpecificOutput", type: "{ hookEventName: 'SessionStart'; additionalContext?: string } (optional)" }

  tool_input_types:
    - name: "BashToolInput"
      source_file: "templates/hooks/lib.ts"
      fields:
        - { name: "command", type: "string" }
        - { name: "timeout", type: "number (optional)" }
        - { name: "description", type: "string (optional)" }

    - name: "ToolInputs.Write"
      source_file: "scripts/session-type-reference.ts"
      fields:
        - { name: "file_path", type: "string" }
        - { name: "content", type: "string" }

    - name: "ToolInputs.Edit"
      source_file: "scripts/session-type-reference.ts"
      fields:
        - { name: "file_path", type: "string" }
        - { name: "old_string", type: "string" }
        - { name: "new_string", type: "string" }
        - { name: "replace_all", type: "boolean (optional)" }

    - name: "ToolInputs.Read"
      source_file: "scripts/session-type-reference.ts"
      fields:
        - { name: "file_path", type: "string" }
        - { name: "limit", type: "number (optional)" }
        - { name: "offset", type: "number (optional)" }

    - name: "ToolInputs.Glob"
      source_file: "scripts/session-type-reference.ts"
      fields:
        - { name: "pattern", type: "string" }
        - { name: "path", type: "string (optional)" }

    - name: "ToolInputs.Grep"
      source_file: "scripts/session-type-reference.ts"
      fields:
        - { name: "pattern", type: "string" }
        - { name: "path", type: "string (optional)" }
        - { name: "include", type: "string (optional)" }

  type_guards:
    - name: "isPreToolUseInput"
      source_file: "scripts/session-type-reference.ts"
      description: "Check if input is PreToolUse payload"
      implementation: "'tool_name' in input && !('tool_response' in input)"

    - name: "isPostToolUseInput"
      source_file: "scripts/session-type-reference.ts"
      description: "Check if input is PostToolUse payload"
      implementation: "'tool_name' in input && 'tool_response' in input"

    - name: "isNotificationInput"
      source_file: "scripts/session-type-reference.ts"
      description: "Check if input is Notification payload"
      implementation: "'message' in input && 'title' in input"

    - name: "isStopInput"
      source_file: "scripts/session-type-reference.ts"
      description: "Check if input is Stop or SubagentStop payload"
      implementation: "'stop_hook_active' in input"

# ==============================================================================
# HOOK PATTERNS
# ==============================================================================
patterns:
  - pattern_name: "session-start-source-detection"
    hook_event: "SessionStart"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Detects the source of a new Claude session (VSCode, web, terminal) and logs session metadata"
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Reads payload.source field to determine session origin and applies source-specific initialization logic"
      code_snippet: |
        const sessionStart: SessionStartHandler = async (payload) => {
          await saveSessionData('SessionStart', {...payload, hook_type: 'SessionStart'} as const)

          console.log(`New session started from: ${payload.source}`)
          console.log(`Session ID: ${payload.session_id}`)

          if (payload.source === 'vscode') {
            console.log('VS Code session detected - enabling IDE-specific features')
          } else if (payload.source === 'web') {
            console.log('Web session detected')
          }

          return {} // Empty object means continue normally
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Context"
      when_to_use: "When you need different behavior based on where Claude is running"
      when_not_to_use: "When session source is irrelevant to your use case"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "dangerous-command-blocker"
    hook_event: "PreToolUse"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Blocks dangerous bash commands like 'rm -rf /' or 'rm -rf ~' with deny decision and explanation"
    implementation:
      matcher: ""
      decision_type: "deny"
      exit_code: "0"
    technique:
      summary: "Pattern matching on bash command string to detect destructive operations, returns deny decision with reason"
      code_snippet: |
        const preToolUse: PreToolUseHandler = async (payload) => {
          if (payload.tool_name === 'Bash' && payload.tool_input && 'command' in payload.tool_input) {
            const command = (payload.tool_input as {command: string}).command
            console.log(`Running command: ${command}`)

            if (command.includes('rm -rf /') || command.includes('rm -rf ~')) {
              console.error('Dangerous command detected! Blocking execution.')
              return {
                permissionDecision: 'deny',
                permissionDecisionReason: `Dangerous command detected: ${command}`,
              }
            }
          }
          return {} // Empty object means continue with default behavior
        }
    context_loading:
      mechanism: "permissionDecisionReason"
      what_loaded: "Explanation of why command was blocked, shown to Claude"
    use_case:
      category: "Safety"
      when_to_use: "Always - as a basic safety layer for bash command execution"
      when_not_to_use: "Never - this is a fundamental safety pattern"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "file-edit-logger"
    hook_event: "PreToolUse"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Logs when Claude is about to edit files, showing the file path"
    implementation:
      matcher: ""
      decision_type: "allow"
      exit_code: "0"
    technique:
      summary: "Checks for Edit tool usage and extracts file_path from tool_input for logging"
      code_snippet: |
        if (payload.tool_name === 'Edit' && payload.tool_input) {
          const {file_path} = payload.tool_input as {file_path: string}
          console.log(`Claude is editing: ${file_path}`)
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Observability"
      when_to_use: "When tracking file modifications for audit or debugging"
      when_not_to_use: "When logging overhead is a concern"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "file-write-success-logger"
    hook_event: "PostToolUse"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Logs successful file write operations after completion"
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Checks for Write tool and tool_response to confirm successful file operations"
      code_snippet: |
        const postToolUse: PostToolUseHandler = async (payload) => {
          await saveSessionData('PostToolUse', {...payload, hook_type: 'PostToolUse'} as const)

          if (payload.tool_name === 'Write' && payload.tool_response) {
            console.log(`File written successfully!`)
          }

          return {}
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Observability"
      when_to_use: "When tracking successful file operations for confirmation"
      when_not_to_use: "When minimal logging is preferred"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "notification-logger"
    hook_event: "Notification"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Logs Claude notification messages to console"
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Passes through notification message to console output"
      code_snippet: |
        const notification: NotificationHandler = async (payload) => {
          await saveSessionData('Notification', {...payload, hook_type: 'Notification'} as const)
          console.log(`${payload.message}`)
          return {}
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Communication"
      when_to_use: "For basic notification logging or as a base for custom notification handlers"
      when_not_to_use: "When notifications need to be routed elsewhere (desktop, Slack, etc.)"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "session-end-logger"
    hook_event: "Stop"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Logs when a Claude session ends"
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Simple session end logging with state persistence"
      code_snippet: |
        const stop: StopHandler = async (payload) => {
          await saveSessionData('Stop', {...payload, hook_type: 'Stop'} as const)
          console.log(`Session ended`)
          return {}
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Observability"
      when_to_use: "For session lifecycle tracking"
      when_not_to_use: "When you need to prevent Claude from stopping"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "subagent-stop-guard"
    hook_event: "SubagentStop"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Handles subagent (Task tool) completion with stop_hook_active loop prevention"
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Checks stop_hook_active flag to prevent infinite hook loops when subagent stops"
      code_snippet: |
        const subagentStop: SubagentStopHandler = async (payload) => {
          await saveSessionData('SubagentStop', {...payload, hook_type: 'SubagentStop'} as const)
          console.log(`Subagent task completed`)

          if (payload.stop_hook_active) {
            console.log('Stop hook is already active, skipping additional processing')
          }

          return {}
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Coordination"
      when_to_use: "When using Task tool and need to handle subagent completion"
      when_not_to_use: "When not using multi-agent workflows"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "dangerous-prompt-blocker"
    hook_event: "UserPromptSubmit"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Blocks user prompts containing dangerous keywords like 'delete all'"
    implementation:
      matcher: ""
      decision_type: "block"
      exit_code: "0"
    technique:
      summary: "Pattern matching on user prompt text to detect dangerous requests"
      code_snippet: |
        const userPromptSubmit: UserPromptSubmitHandler = async (payload) => {
          await saveSessionData('UserPromptSubmit', {...payload, hook_type: 'UserPromptSubmit'} as const)
          console.log(`User prompt: ${payload.prompt}`)

          if (payload.prompt.includes('delete all')) {
            console.error('Dangerous prompt detected! Blocking.')
            return {decision: 'block', reason: 'Prompts containing "delete all" are not allowed'}
          }

          return {}
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Safety"
      when_to_use: "When enforcing prompt-level safety policies"
      when_not_to_use: "When all prompts should be allowed through"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "auto-context-file-injection"
    hook_event: "UserPromptSubmit"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Automatically adds relevant files to context based on prompt keywords (e.g., adds test files when 'test' is mentioned)"
    implementation:
      matcher: ""
      decision_type: "allow"
      exit_code: "0"
    technique:
      summary: "Analyzes prompt content and returns contextFiles array with glob patterns for relevant files"
      code_snippet: |
        const userPromptSubmit: UserPromptSubmitHandler = async (payload) => {
          const contextFiles: string[] = []

          if (payload.prompt.toLowerCase().includes('test')) {
            contextFiles.push('**/*.test.ts', '**/*.test.js')
            console.log('Auto-adding test files to context')
          }

          return contextFiles.length > 0 ? {contextFiles} : {}
        }
    context_loading:
      mechanism: "contextFiles"
      what_loaded: "Glob patterns for files to add to Claude's context based on prompt content"
    use_case:
      category: "Productivity"
      when_to_use: "When you want Claude to automatically have relevant files in context"
      when_not_to_use: "When manual context control is preferred"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "pre-compact-trigger-logger"
    hook_event: "PreCompact"
    source_repo: "claude-hooks"
    source_file: "templates/hooks/index.ts"
    description: "Logs context compaction events with trigger type (manual vs auto)"
    implementation:
      matcher: ""
      decision_type: "none"
      exit_code: "0"
    technique:
      summary: "Checks trigger field to distinguish between manual and automatic compaction"
      code_snippet: |
        const preCompact: PreCompactHandler = async (payload) => {
          await saveSessionData('PreCompact', {...payload, hook_type: 'PreCompact'} as const)
          console.log(`Compact triggered: ${payload.trigger}`)

          if (payload.trigger === 'auto') {
            console.log('Allowing automatic compaction')
          }

          return {}
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Context"
      when_to_use: "When tracking compaction events or implementing custom compaction logic"
      when_not_to_use: "When compaction behavior is not a concern"
    quality:
      complexity: "low"
      performance: "<10ms"
      dependencies: []

  - pattern_name: "validation-helpers"
    hook_event: "N/A (utility)"
    source_repo: "claude-hooks"
    source_file: "scripts/session-type-reference.ts"
    description: "Runtime validation functions for hook responses to ensure required fields are present"
    implementation:
      matcher: "N/A"
      decision_type: "N/A"
      exit_code: "N/A"
    technique:
      summary: "Validation functions that check response objects match expected schema for each hook type"
      code_snippet: |
        export function validateStopResponse(response: StopResponse): string | null {
          if (response.decision === 'block' && !response.reason) {
            return 'reason is required when decision is "block"'
          }
          return null
        }

        export function validateHookResponse(
          hookType: 'PreToolUse' | 'PostToolUse' | 'Stop' | 'SubagentStop' | 'Notification',
          response: any,
        ): string | null {
          if ('decision' in response) {
            switch (hookType) {
              case 'PreToolUse':
                if (response.decision && !['approve', 'block'].includes(response.decision)) {
                  return `Invalid decision for PreToolUse: ${response.decision}`
                }
                break
              // ... other cases
            }
          }
          return null
        }
    context_loading:
      mechanism: "none"
      what_loaded: "N/A"
    use_case:
      category: "Quality"
      when_to_use: "When building hook systems that need runtime validation"
      when_not_to_use: "When TypeScript compile-time checking is sufficient"
    quality:
      complexity: "medium"
      performance: "<10ms"
      dependencies: []

# ==============================================================================
# ARCHITECTURE PATTERNS
# ==============================================================================
architecture_patterns:
  - pattern_name: "unified-handler-file"
    source_file: "templates/hooks/index.ts"
    description: "All hook handlers defined in single index.ts file, using shared lib.ts for types and runner"
    technique:
      summary: "Single entrypoint that imports handlers and types, registers all handlers with runHook()"
      code_snippet: |
        import type { PreToolUseHandler, PostToolUseHandler, /* ... */ } from './lib'
        import {runHook} from './lib'
        import {saveSessionData} from './session'

        const sessionStart: SessionStartHandler = async (payload) => { /* ... */ }
        const preToolUse: PreToolUseHandler = async (payload) => { /* ... */ }
        // ... other handlers

        runHook({
          sessionStart,
          preToolUse,
          postToolUse,
          notification,
          stop,
          subagentStop,
          userPromptSubmit,
          preCompact,
        })

  - pattern_name: "cli-scaffolding"
    source_file: "src/commands/init.ts"
    description: "oclif-based CLI that scaffolds complete hook project with bun init, types, and settings.json"
    technique:
      summary: "CLI command that creates .claude/hooks directory, runs bun init, copies templates, and generates settings.json"
      code_snippet: |
        // Generated settings.json structure
        settings.hooks = {
          Notification: [{ matcher: '', hooks: [{ type: 'command', command: 'bun .claude/hooks/index.ts Notification' }] }],
          Stop: [{ matcher: '', hooks: [{ type: 'command', command: 'bun .claude/hooks/index.ts Stop' }] }],
          PreToolUse: [{ matcher: '', hooks: [{ type: 'command', command: 'bun .claude/hooks/index.ts PreToolUse' }] }],
          PostToolUse: [{ matcher: '', hooks: [{ type: 'command', command: 'bun .claude/hooks/index.ts PostToolUse' }] }],
          SubagentStop: [{ matcher: '', hooks: [{ type: 'command', command: 'bun .claude/hooks/index.ts SubagentStop' }] }],
          UserPromptSubmit: [{ matcher: '', hooks: [{ type: 'command', command: 'bun .claude/hooks/index.ts UserPromptSubmit' }] }],
          PreCompact: [{ matcher: '', hooks: [{ type: 'command', command: 'bun .claude/hooks/index.ts PreCompact' }] }],
        }

  - pattern_name: "hook-type-as-cli-argument"
    source_file: "templates/hooks/lib.ts"
    description: "Hook type passed as CLI argument, allowing single script to handle all hook types"
    technique:
      summary: "process.argv[2] contains hook type, enabling switch-based routing to appropriate handler"
      code_snippet: |
        export function runHook(handlers: HookHandlers): void {
          const hook_type = process.argv[2]  // 'PreToolUse', 'PostToolUse', etc.

          process.stdin.on('data', async (data) => {
            const inputData = JSON.parse(data.toString())
            const payload: HookPayload = { ...inputData, hook_type }

            switch (payload.hook_type) {
              case 'PreToolUse': /* ... */
              case 'PostToolUse': /* ... */
              // ...
            }
          })
        }

# ==============================================================================
# HOOKS NOT FOUND
# ==============================================================================
hooks_not_found:
  - hook_event: "SessionStart"
    note: "SessionStart is fully implemented with source detection pattern"
    status: "found"

# ==============================================================================
# USE CASE CATALOG
# ==============================================================================
use_case_catalog:
  - use_case: "Dangerous command blocking"
    hook_type: "PreToolUse"
    source_repo: "claude-hooks"
    description: "Block rm -rf / and rm -rf ~ commands with deny decision"

  - use_case: "File edit logging"
    hook_type: "PreToolUse"
    source_repo: "claude-hooks"
    description: "Log file paths when Claude edits files"

  - use_case: "Bash command logging"
    hook_type: "PreToolUse"
    source_repo: "claude-hooks"
    description: "Log all bash commands before execution"

  - use_case: "File write confirmation"
    hook_type: "PostToolUse"
    source_repo: "claude-hooks"
    description: "Log successful file write operations"

  - use_case: "Notification logging"
    hook_type: "Notification"
    source_repo: "claude-hooks"
    description: "Pass-through notification messages to console"

  - use_case: "Session end tracking"
    hook_type: "Stop"
    source_repo: "claude-hooks"
    description: "Log and persist session end events"

  - use_case: "Subagent completion handling"
    hook_type: "SubagentStop"
    source_repo: "claude-hooks"
    description: "Handle Task tool completion with loop prevention"

  - use_case: "Dangerous prompt blocking"
    hook_type: "UserPromptSubmit"
    source_repo: "claude-hooks"
    description: "Block prompts containing dangerous keywords"

  - use_case: "Auto context file injection"
    hook_type: "UserPromptSubmit"
    source_repo: "claude-hooks"
    description: "Add relevant files to context based on prompt keywords"

  - use_case: "Compaction event logging"
    hook_type: "PreCompact"
    source_repo: "claude-hooks"
    description: "Track manual vs automatic compaction triggers"

  - use_case: "Session source detection"
    hook_type: "SessionStart"
    source_repo: "claude-hooks"
    description: "Detect if session started from VSCode, web, or terminal"

  - use_case: "Session data persistence"
    hook_type: "All"
    source_repo: "claude-hooks"
    description: "Persist all hook invocations to session-specific JSON files"

  - use_case: "Transcript analysis"
    hook_type: "All (utility)"
    source_repo: "claude-hooks"
    description: "Read and parse Claude transcript JSONL for conversation history and tool usage"

  - use_case: "Hook project scaffolding"
    hook_type: "N/A (CLI)"
    source_repo: "claude-hooks"
    description: "Generate complete TypeScript hook project with npx claude-hooks"

# ==============================================================================
# CONTEXT LOADING MECHANISMS
# ==============================================================================
context_loading_mechanisms:
  - mechanism: "permissionDecisionReason"
    hook_events: ["PreToolUse"]
    description: "Explanation shown to Claude when blocking/denying tool execution"
    example: "permissionDecisionReason: 'Dangerous command detected: rm -rf /'"

  - mechanism: "contextFiles"
    hook_events: ["UserPromptSubmit"]
    description: "Array of glob patterns for files to add to Claude's context"
    example: "contextFiles: ['**/*.test.ts', '**/*.test.js']"

  - mechanism: "reason (block)"
    hook_events: ["UserPromptSubmit", "Stop", "SubagentStop", "PostToolUse"]
    description: "Explanation shown when blocking prompt or preventing stop"
    example: "reason: 'Prompts containing \"delete all\" are not allowed'"

  - mechanism: "transcript_path"
    hook_events: ["All"]
    description: "Path to JSONL transcript file, enabling hooks to read full conversation history"
    example: "Provided in all payloads, can use getConversationHistory() to parse"

  - mechanism: "hookSpecificOutput.additionalContext"
    hook_events: ["SessionStart", "UserPromptSubmit"]
    description: "Additional context that can be injected into hook responses"
    example: "hookSpecificOutput: { hookEventName: 'SessionStart', additionalContext: '...' }"

  - mechanism: "state_file"
    hook_events: ["All"]
    description: "Session data persisted to temp directory JSON files via saveSessionData()"
    example: "Session history saved to <tempdir>/claude-hooks-sessions/<session_id>.json"
