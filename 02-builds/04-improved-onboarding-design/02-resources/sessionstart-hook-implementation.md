# SessionStart Hook Implementation Documentation

> **Generated by**: Explore subagent ad54f16
> **Date**: 2026-01-24
> **Purpose**: Complete documentation of SessionStart hook state detection and routing logic

---

## Executive Summary

The SessionStart hook implements a sophisticated **MECE (Mutually Exclusive, Collectively Exhaustive)** state detection system that determines if a session should resume a build or display a menu. It uses a three-tier detection priority: session ID match (exact), transcript parsing (fallback), and most recent build (resume-only).

---

## File Location

**Primary File:** `.claude/hooks/session_start.py`

---

## 1. HOOK STATE DETECTION LOGIC

### A. Extract Learning Completed Flags

**File:** `/00-system/core/nexus/state.py:360-398`

```python
def extract_learning_completed(config_path: Path) -> Dict[str, bool]:
    """
    Extract learning_tracker.completed from user-config.yaml.

    Returns dict mapping skill keys to completion status:
    - setup_memory: bool
    - create_folders: bool
    - learn_integrations: bool
    - learn_builds: bool
    - learn_skills: bool
    - learn_nexus: bool
    """
```

### B. Derive State Flags

**File:** `.claude/hooks/session_start.py:602-618`

```python
# Extract learning_tracker (single source of truth)
learning_completed = extract_learning_completed(config_path)

# Derive state from learning_tracker flags
goals_personalized = learning_completed.get("setup_memory", False)
workspace_configured = learning_completed.get("create_folders", False)
```

### C. Build Pending Onboarding List

**File:** `/00-system/core/nexus/state.py:335-357`

```python
def build_pending_onboarding(learning_completed: Dict[str, bool]) -> List[Dict[str, Any]]:
    """
    Build list of pending onboarding skills.

    Iterates through ONBOARDING_SKILLS constant (config.py:77-114)
    Returns list of incomplete skills with metadata:
    - key: "setup_memory" | "create_folders" | "learn_builds" | ...
    - name: Display name (e.g., "setup-memory")
    - trigger: Command trigger (e.g., "setup memory")
    - priority: "critical" | "high" | "medium"
    - time: Estimated duration
    """
```

---

## 2. MECE STATE CLASSIFICATION LOGIC

**Function:** `determine_context_mode()` (Lines 98-226 in session_start.py)

**Decision Tree:**

1. **Case 1: New Session**
   - Condition: `source == "new"`
   - Output: `mode="startup"`, `action="display_menu"`
   - Code: Lines 136-144

2. **Case 2: Session Resume with Build Detection**
   - Priority 1: Session ID match in resume-context.md (bulletproof)
   - Priority 2: Fallback transcript parsing
   - Code: Lines 146-158

3. **Case 3: Compact without Build**
   - Condition: `source == "compact"` AND `not last_build`
   - Output: `mode="startup"`, `action="continue_working"`
   - Code: Lines 159-169

4. **Case 4: Resume without Build**
   - Condition: `source == "resume"` AND `not last_build`
   - Output: `mode="startup"`, `action="display_menu"`
   - Code: Lines 171-183

5. **Case 5: Build Detected**
   - Validates build exists in workspace (safety check)
   - Detects phase: `detect_build_phase()` (build_state.py:314-377)
   - Output: `mode="compact"`, `action="continue_working"`, `skill="plan-build"` OR `"execute-build"`
   - Code: Lines 186-216

---

## 3. TEMPLATE SELECTION LOGIC

### STARTUP Mode Template Selection (Lines 464-711)

**Triggers when:** No active build detected

**Loads:**
1. Orchestrator instructions (00-system/core/orchestrator.md)
2. User goals (01-memory/goals.md)
3. Active builds list
4. Skills (via `build_skills_xml_compact()`)
5. State detection (goals_personalized, workspace_configured, pending_onboarding)
6. Dynamic instruction (via `build_next_action_instruction()`)

### COMPACT Mode Template Selection (Lines 713-868)

**Triggers when:** Build detected in session resume/compact

**Loads:**
1. Resume build metadata (build_id, phase, skill)
2. System files (orchestrator, system-map, memory-map, workspace-map)
3. Build files (from `files_to_load` in resume-context.md)
4. Skill file (plan-build SKILL.md or execute-build SKILL.md)
5. Phase-specific instruction template:
   - `compact_planning` (if `phase=="planning"`)
   - `compact_execution` (if `phase=="execution"`)

---

## 4. ONBOARDING SKILLS LIST

**File:** `/00-system/core/nexus/config.py:77-114`

```python
ONBOARDING_SKILLS: Dict[str, Dict[str, str]] = {
    "setup_memory": {
        "name": "setup-memory",
        "trigger": "setup memory",
        "priority": "critical",
        "time": "8 min",
    },
    "create_folders": {
        "name": "create-folders",
        "trigger": "create folders",
        "priority": "high",
        "time": "5-8 min",
    },
    "learn_builds": {
        "name": "learn-builds",
        "trigger": "learn builds",
        "priority": "high",
        "time": "8-10 min",
    },
    "learn_skills": {
        "name": "learn-skills",
        "trigger": "learn skills",
        "priority": "high",
        "time": "10-12 min",
    },
    "learn_integrations": {
        "name": "learn-integrations",
        "trigger": "learn integrations",
        "priority": "high",
        "time": "10-12 min",
    },
    "learn_nexus": {
        "name": "learn-nexus",
        "trigger": "learn nexus",
        "priority": "medium",
        "time": "15-18 min",
    },
}
```

---

## 5. COMPLETE FLOW

```
SessionStart Hook Triggered
    ↓
main() [Lines 948-1113]
    ↓
Parse JSON input (session_id, source, transcript_path)
    ↓
Determine workspace root (Lines 899-945)
    ↓
Validate workspace exists & transcript belongs to it
    ↓
determine_context_mode() [Lines 98-226]
    ├─ Case 1: NEW → mode="startup", action="display_menu"
    ├─ Case 2: Session ID match → mode="compact", action="continue_working"
    ├─ Case 3: Transcript parsing → mode="compact", action="continue_working"
    ├─ Case 4: Resume without build → mode="startup", action="display_menu"
    └─ Case 5: Build detected → detect_build_phase() → mode="compact"
    ↓
Build XML Context based on mode:
    ├─ If mode="startup" [Lines 464-711]: build_startup_xml()
    └─ If mode="compact" [Lines 713-868]: build_compact_xml()
    ↓
Output Hook Response [Lines 1027-1049]
    ↓
Performance check & logging [Lines 1042-1111]
```

---

## 6. KEY DETECTION METHODS

### A. Session ID Detection (transcript.py:26-105)

```python
find_build_by_session_id(builds_dir, session_id)
    ├─ Priority 1: Check session_ids list in resume-context.md
    ├─ Priority 2: Check legacy session_id field (backward compat)
    └─ Returns: build_id or None
```

### B. Transcript Parsing (transcript.py:108-210)

```python
parse_transcript_for_build(transcript_path, workspace_builds_dir)
    ├─ Reads last 500 JSONL entries
    ├─ Extracts file_path from tool_use entries
    ├─ Matches 02-builds/{id}-{name}/ pattern
    ├─ Multi-build detection: 3+ builds = no single active build
    ├─ Validates build exists in workspace (safety)
    └─ Returns: (build_id or None, detection_method)
```

### C. Build Phase Detection (build_state.py:314-377)

```python
detect_phase_from_metadata(build_path)
    ├─ Priority 1: resume-context.md (current_phase + next_action)
    ├─ Priority 2: steps.md checkbox analysis (fallback)
    └─ Returns: (phase_string, skill_name)
```

---

## 7. STATE METADATA STRUCTURE

```python
state_metadata = {
    "state_hash": state_hash,  # MD5[:8] of state flags
    "goals_personalized": bool,
    "goals_is_template": bool,
    "goals_path": str,
    "workspace_configured": bool,
    "workspace_is_template": bool,
    "workspace_path": str,
    "onboarding_complete": bool,
    "pending_onboarding_count": int,
    "build_dir": str,
}
```

---

## 8. MULTI-WINDOW SAFETY CHECKS

1. **Workspace validation** (Lines 970-987)
   - Derives workspace from hook location
   - Validates transcript path belongs to workspace
   - Falls back to "new" mode if mismatch

2. **Build validation** (Lines 187-204)
   - Verifies build exists in expected workspace path
   - Logs error on cross-workspace build detection
   - Defaults to startup mode for safety

---

## Performance Optimization

**Target execution time:** <200ms

- **Token targets:**
  - STARTUP: ~20K tokens (5K margin from 25K budget)
  - COMPACT: ~10K tokens (minimal context)
- Logging to cache files instead of stderr
- Estimated tokens calculation: length / 4 chars per token
